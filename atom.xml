<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Wu&#39;s Blog</title>
  <subtitle>The closer you think you are,the less you will actually see.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-03T12:03:29.605Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Andorid下的webview缓存全解析</title>
    <link href="http://yoursite.com/2017/06/03/Android%E4%B8%8BwebView%E7%BC%93%E5%AD%98%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/06/03/Android下webView缓存全解析/</id>
    <published>2017-06-03T09:11:53.000Z</published>
    <updated>2017-06-03T12:03:29.605Z</updated>
    
    <content type="html"><![CDATA[<p>#Android下webview缓存详解</p>
<h2 id="HTML5缓存介绍"><a href="#HTML5缓存介绍" class="headerlink" title="HTML5缓存介绍"></a>HTML5缓存介绍</h2><ul>
<li>HTML 5 Web 存储<ul>
<li>在客户端存储数据（DOM Storage 分为 sessionStorage 和 localStorage。HTML5 中引入了 DOM Storage 机制用于存储键值对，它的设计目的是提供大规模、易用的存储功能， 并且程序员可以通过调用标准的接口，简单地访问存储的数据。目前，许多新版本的浏览器都支持 DOM Storage 功能。 当老版本的浏览器不支持 HTML5 提供的 DOM Storage 机制时，可以考虑用 Dojo 来实现相同的功能。）</li>
<li>HTML5 提供了两种在客户端存储数据的新方法：<ul>
<li>localStorage - 没有时间限制的数据存储</li>
<li>sessionStorage - 针对一个 session 的数据存储<ul>
<li>之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。HTML5 使用 JavaScript 来存储和访问数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HTML 5 应用程序缓存<ul>
<li>什么是应用程序缓存（Application Cache）？<ul>
<li>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。</li>
</ul>
</li>
<li>应用程序缓存为应用带来三个优势：<ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
<li>浏览器支持<ul>
<li>所有主流浏览器均支持应用程序缓存，除了 Internet Explorer。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Android中WebView的缓存可以分为页面缓存和数据缓存-以下分别对两者进行阐述"><a href="#Android中WebView的缓存可以分为页面缓存和数据缓存-以下分别对两者进行阐述" class="headerlink" title="Android中WebView的缓存可以分为页面缓存和数据缓存,以下分别对两者进行阐述:"></a>Android中WebView的缓存可以分为页面缓存和数据缓存,以下分别对两者进行阐述:</h2><ul>
<li>页面缓存是指加载一个网页时的html、JS、CSS等页面或者资源数据。这些缓存资源是由于浏览器的行为而产生，开发者只能通过配置HTTP响应头影响浏览器的行为才能间接地影响到这些缓存数据。他们的索引存放在/data/data/package_name/databases下。他们的文件存放在/data/data/package_name/cache/xxxwebviewcachexxx下。文件夹的名字在2.x和4.x上有所不同，但都文件夹名字中都包含webviewcache。<ul>
<li>1、缓存构成<ul>
<li>/data/data/package_name/cache/</li>
<li>/data/data/package_name/database/webview.db</li>
<li>/data/data/package_name/database/webviewCache.db</li>
</ul>
</li>
<li>2、缓存模式(5种)<ul>
<li>LOAD_CACHE_ONLY:  不使用网络，只读取本地缓存数据</li>
<li>LOAD_DEFAULT:  根据cache-control决定是否从网络上取数据。</li>
<li>LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式</li>
<li>LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</li>
<li>LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。<ul>
<li>如：www.taobao.com的cache-control为no-cache，在模式LOAD_DEFAULT下，无论如何都会从网络上取数据，如果没有网络，就会出现错误页面；在LOAD_CACHE_ELSE_NETWORK模式下，无论是否有网络，只要本地有缓存，都使用缓存。本地没有缓存时才从网络上获取。www.360.com.cn的cache-control为max-age=60，在两种模式下都使用本地缓存数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>数据缓存分为两种：AppCache和DOM Storage（Web Storage）。他们是因为页面开发者的直接行为而产生。所有的缓存数据都由开发者直接完全地掌控。<ul>
<li>AppCache使我们能够有选择的缓冲web浏览器中所有的东西，从页面、图片到脚本、css等等。尤其在涉及到应用于网站的多个页面上的CSS和JavaScript文件的时候非常有用。其大小目前通常是5M。<ul>
<li>在Android上需要手动开启（setAppCacheEnabled），并设置路径（setAppCachePath）和容量（setAppCacheMaxSize）</li>
<li>Android中Webkit使用一个db文件来保存AppCache数据（my_path/ApplicationCache.db）</li>
</ul>
</li>
<li>如果需要存储一些简单的用key/value对即可解决的数据，DOM Storage是非常完美的方案。根据作用范围的不同，有Session Storage和Local Storage两种，分别用于会话级别的存储（页面关闭即消失）和本地化存储（除非主动删除，否则数据永远不会过期）。<ul>
<li>在Android中可以手动开启DOM Storage（setDomStorageEnabled），设置存储路径（setDatabasePath）</li>
<li>Android中Webkit会为DOM Storage产生两个文件（my_path/localstorage/http_h5.m.taobao.com_0.localstorage和my_path/localstorage/Databases.db）</li>
</ul>
</li>
<li>另外，在Android中清除缓存时，如果需要清除Local Storage的话，仅仅删除Local Storage的本地存储文件是不够的，内存里面有缓存数据。如果再次进入页面，Local Storage中的缓存数据同样存在。需要杀死程序运行的当前进程再重新启动才可以。</li>
</ul>
</li>
</ul>
<h2 id="webSetting关于缓存相关的API"><a href="#webSetting关于缓存相关的API" class="headerlink" title="webSetting关于缓存相关的API"></a>webSetting关于缓存相关的API</h2><ul>
<li>setAppCacheEnabled (boolean flag)<ul>
<li>应用缓存API是否可用，默认值false, 结合setAppCachePath(String)使用。</li>
</ul>
</li>
<li>setAppCachePath(String)<ul>
<li>设置应用缓存文件的路径。为了让应用缓存API可用，此方法必须传入一个应用可写的路径。该方法只会执行一次，重复调用会被忽略。</li>
</ul>
</li>
<li>setAppCacheMaxSize (long appCacheMaxSize)<ul>
<li>已废弃。设置应用缓存内容的最大值。所传值会被近似为数据库支持的最近似值，因此这是一个指示值，而不是一个固定值。所传值若小于数据库大小不会让数据库调整大小。默认值是MAX_VALUE，建议将默认值设置为最大值。</li>
</ul>
</li>
<li>setCacheMode (int mode)<ul>
<li>重写使用缓存的方式，默认值LOAD_DEFAULT。缓存的使用方式基于导航类型，正常的页面加载，检测缓存，需要时缓存内容复现。导航返回时，内容不会复现，只有内容会从缓存盘中恢复。该方法允许客户端通过指定LOAD_DEFAULT, LOAD_CACHE_ELSE_NETWORK, LOAD_NO_CACHE or LOAD_CACHE_ONLY的其中一项来重写其行为。</li>
</ul>
</li>
<li>setDatabaseEnabled (boolean flag)<ul>
<li>数据库存储API是否可用，默认值false。如何正确设置数据存储API参见setDatabasePath(String)。该设置对同一进程中的所有WebView实例均有效。注意，只能在当前进程的任意WebView加载页面之前修改此项，因为此节点之后WebView的实现类可能会忽略该项设置的改变。</li>
</ul>
</li>
<li>setDatabasePath (String databasePath)<ul>
<li>已废弃，数据库路径由实现（implementation）管理，调用此方法无效。设置数据库的存储路径，为了保证数据库正确运行，该方法必须使用一个应用可写的路径。此方法只能执行一次，重复调用会被忽略。</li>
</ul>
</li>
<li>setDomStorageEnabled (boolean flag)<ul>
<li>DOM存储API是否可用，默认false。</li>
</ul>
</li>
</ul>
<h2 id="webSetting相关API总结："><a href="#webSetting相关API总结：" class="headerlink" title="webSetting相关API总结："></a>webSetting相关API总结：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line">setAllowContentAccess (boolean allow)</div><div class="line">是否允许在WebView中访问内容URL（Content Url），默认允许。内容Url访问允许WebView从安装在系统中的内容提供者载入内容。</div><div class="line"></div><div class="line">setAllowFileAccess (boolean allow)</div><div class="line">是否允许访问文件，默认允许。注意，这里只是允许或禁止对文件系统的访问，Assets 和 resources 文件使用file:///android_asset和file:///android_res仍是可访问的。</div><div class="line"></div><div class="line">setAllowFileAccessFromFileURLs (boolean flag)</div><div class="line">是否允许运行在一个URL环境（the context of a file scheme URL）中的JavaScript访问来自其他URL环境的内容，为了保证安全，应该不允许。也请注意，这项设置只影响对file schema 资源的JavaScript访问，其他形式的访问，例如来自图片HTML单元的访问不受影响。为了防止相同的域策略（same domain policy）对ICE_CREAM_SANDWICH以及更老机型的侵害，应该显式地设置此值为false。</div><div class="line"></div><div class="line">setAllowUniversalAccessFromFileURLs (boolean flag)</div><div class="line">是否允许运行在一个file schema URL环境下的JavaScript访问来自其他任何来源的内容，包括其他file schema URLs. 参见setAllowFileAccessFromFileURLs(boolean)，为了确保安全，应该设置为不允许，注意这项设置只影响对file schema 资源的JavaScript访问，其他形式的访问，例如来自图片HTML单元的访问不受影响。为了防止相同的域策略（same domain policy）对ICE_CREAM_SANDWICH以及更老机型的侵害，应该显式地设置此值为false。ICE_CREAM_SANDWICH_MR1 以及更老的版本此默认值为true，JELLY_BEAN以及更新版本此默认值为false</div><div class="line"></div><div class="line">setAppCacheEnabled (boolean flag)</div><div class="line">应用缓存API是否可用，默认值false, 结合setAppCachePath(String)使用。</div><div class="line"></div><div class="line">setAppCachePath(String)</div><div class="line">设置应用缓存文件的路径。为了让应用缓存API可用，此方法必须传入一个应用可写的路径。该方法只会执行一次，重复调用会被忽略。</div><div class="line"></div><div class="line">setAppCacheMaxSize (long appCacheMaxSize)</div><div class="line">已废弃。设置应用缓存内容的最大值。所传值会被近似为数据库支持的最近似值，因此这是一个指示值，而不是一个固定值。所传值若小于数据库大小不会让数据库调整大小。默认值是MAX_VALUE，建议将默认值设置为最大值。</div><div class="line"></div><div class="line">setBlockNetworkImage (boolean flag)</div><div class="line">是否禁止从网络（通过http和https URI schemes访问的资源）下载图片资源，默认值为false。注意，除非getLoadsImagesAutomatically()返回true,否则该方法无效。还请注意，即使此项设置为false，使用setBlockNetworkLoads(boolean)禁止所有网络加载也会阻止网络图片的加载。当此项设置的值从true变为false，WebView当前显示的内容所引用的网络图片资源会自动获取。</div><div class="line"></div><div class="line">setBlockNetworkLoads (boolean flag)</div><div class="line">是否禁止从网络下载数据，如果app有INTERNET权限，默认值为false，否则默认为true。使用setBlockNetworkImage(boolean) 只会禁止图片资源的加载。注意此值由true变为false，当前WebView展示的内容所引用的网络资源不会自动加载，直到调用了重载。如果APP没有INTERNET权限，设置此值为false会抛出SecurityException。</div><div class="line"></div><div class="line">setBuiltInZoomControls (boolean enabled)</div><div class="line">是否使用内置的缩放机制。内置的缩放机制包括屏幕上的缩放控件（浮于WebView内容之上）和缩放手势的运用。通过setDisplayZoomControls(boolean)可以控制是否显示这些控件，默认值为false。</div><div class="line"></div><div class="line">setCacheMode (int mode)</div><div class="line">重写使用缓存的方式，默认值LOAD_DEFAULT。缓存的使用方式基于导航类型，正常的页面加载，检测缓存，需要时缓存内容复现。导航返回时，内容不会复现，只有内容会从缓存盘中恢复。该方法允许客户端通过指定LOAD_DEFAULT, LOAD_CACHE_ELSE_NETWORK, LOAD_NO_CACHE or LOAD_CACHE_ONLY的其中一项来重写其行为。</div><div class="line"></div><div class="line">setCursiveFontFamily (String font)</div><div class="line">设置WebView字体库字体，默认“cursive”</div><div class="line"></div><div class="line">setDatabaseEnabled (boolean flag)</div><div class="line">数据库存储API是否可用，默认值false。如何正确设置数据存储API参见setDatabasePath(String)。该设置对同一进程中的所有WebView实例均有效。注意，只能在当前进程的任意WebView加载页面之前修改此项，因为此节点之后WebView的实现类可能会忽略该项设置的改变。</div><div class="line"></div><div class="line">setDatabasePath (String databasePath)</div><div class="line">已废弃，数据库路径由实现（implementation）管理，调用此方法无效。</div><div class="line">设置数据库的存储路径，为了保证数据库正确运行，该方法必须使用一个应用可写的路径。此方法只能执行一次，重复调用会被忽略。</div><div class="line"></div><div class="line">setDefaultFixedFontSize (int size)</div><div class="line">设置默认固定的字体大小，默认为16，可取值1到72</div><div class="line"></div><div class="line">setDefaultFontSize (int size)</div><div class="line">设置默认的字体大小，默认16，可取值1到72</div><div class="line"></div><div class="line">setDefaultTextEncodingName (String encoding)</div><div class="line">设置默认的字符编码集，默认”UTF-8”.</div><div class="line"></div><div class="line">setDefaultZoom (WebSettings.ZoomDensity zoom)</div><div class="line">已废弃。设置默认的缩放密度，必须在UI线程调用，默认值MEDIUM.该项设置在新应用中不推荐使用。如果WebView用于展示手机页面，可以通过调整页面的’meta viewport’ 标记中的’width’ 和 ‘initial-scale’属性实现预期效果，对于漏用标记的页面，可以使用setInitialScale(int)和setUseWideViewPort(boolean) .</div><div class="line"></div><div class="line">setDisplayZoomControls (boolean enabled)</div><div class="line">使用内置的缩放机制时是否展示缩放控件，默认值true。参见setBuiltInZoomControls(boolean).</div><div class="line"></div><div class="line">setDomStorageEnabled (boolean flag)</div><div class="line">DOM存储API是否可用，默认false。</div><div class="line"></div><div class="line">setEnableSmoothTransition (boolean enable)</div><div class="line">已废弃，将来会成为空操作（no-op），设置当panning或者缩放或者持有当前WebView的window没有焦点时是否允许其光滑过渡，若为true，WebView会选择一个性能最大化的解决方案。例如过渡时WebView的内容可能不更新。若为false，WebView会保持精度（fidelity），默认值false。</div><div class="line"></div><div class="line">setFantasyFontFamily (String font)</div><div class="line">设置fantasy字体集（font family）的名字默认为“fantasy”</div><div class="line"></div><div class="line">setFixedFontFamily (String font)</div><div class="line">设置固定的字体集的名字，默认为”monospace”。</div><div class="line"></div><div class="line">setGeolocationDatabasePath (String databasePath)</div><div class="line">定位数据库的保存路径，为了确保定位权限和缓存位置的持久化，该方法应该传入一个应用可写的路径。</div><div class="line"></div><div class="line">setGeolocationEnabled (boolean flag)</div><div class="line">定位是否可用，默认为true。请注意，为了确保定位API在WebView的页面中可用，必须遵守如下约定:</div><div class="line">(1) app必须有定位的权限，参见ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION；</div><div class="line">(2) app必须提供onGeolocationPermissionsShowPrompt(String, GeolocationPermissions.Callback)回调方法的实现，在页面通过JavaScript定位API请求定位时接收通知。</div><div class="line">作为可选项，可以在数据库中存储历史位置和Web初始权限，参见setGeolocationDatabasePath(String).</div><div class="line"></div><div class="line">setJavaScriptCanOpenWindowsAutomatically (boolean flag)</div><div class="line">让JavaScript自动打开窗口，默认false。适用于JavaScript方法window.open()。</div><div class="line"></div><div class="line">setJavaScriptEnabled (boolean flag)</div><div class="line">设置WebView是否允许执行JavaScript脚本，默认false，不允许。</div><div class="line"></div><div class="line">setLayoutAlgorithm (WebSettings.LayoutAlgorithm l)</div><div class="line">设置布局，会引起WebView的重新布局（relayout）,默认值NARROW_COLUMNS</div><div class="line"></div><div class="line">setLightTouchEnabled (boolean enabled)</div><div class="line">已废弃。从 JELLY_BEAN 开始，该设置无效。允许使用轻触摸做出选择和光标悬停。</div><div class="line"></div><div class="line">setLoadWithOverviewMode (boolean overview)</div><div class="line">是否允许WebView度超出以概览的方式载入页面，默认false。即缩小内容以适应屏幕宽度。该项设置在内容宽度超出WebView控件的宽度时生效，例如当getUseWideViewPort() 返回true时。</div><div class="line"></div><div class="line">setLoadsImagesAutomatically (boolean flag)</div><div class="line">WebView是否下载图片资源，默认为true。注意，该方法控制所有图片的下载，包括使用URI嵌入的图片（使用setBlockNetworkImage(boolean) 只控制使用网络URI的图片的下载）。如果该设置项的值由false变为true，WebView展示的内容所引用的所有的图片资源将自动下载。</div><div class="line"></div><div class="line">setMediaPlaybackRequiresUserGesture (boolean require)</div><div class="line">WebView是否需要用户的手势进行媒体播放，默认值为true。</div><div class="line"></div><div class="line">setMinimumFontSize (int size)</div><div class="line">设置最小的字号，默认为8</div><div class="line"></div><div class="line">setMinimumLogicalFontSize (int size)</div><div class="line">设置最小的本地字号，默认为8。</div><div class="line"></div><div class="line">setMixedContentMode (int mode)</div><div class="line">当一个安全的来源（origin）试图从一个不安全的来源加载资源时配置WebView的行为。默认情况下，KITKAT及更低版本默认值为MIXED_CONTENT_ALWAYS_ALLOW，LOLLIPOP版本默认值MIXED_CONTENT_NEVER_ALLOW，WebView首选的最安全的操作模式为MIXED_CONTENT_NEVER_ALLOW ，不鼓励使用MIXED_CONTENT_ALWAYS_ALLOW。</div><div class="line"></div><div class="line">setNeedInitialFocus (boolean flag)</div><div class="line">调用requestFocus(int, Android.graphics.Rect)时是否需要设置节点获取焦点，默认值为true。</div><div class="line"></div><div class="line">setOffscreenPreRaster (boolean enabled)</div><div class="line">当WebView切换到后台但仍然与窗口关联时是否raster tiles，打开它可以避免在WebView从后台切换到前台时重新绘制，默认值false。在这种模式下后台的WebView占用更多的内存。请按如下准则显示内存的使用：</div><div class="line">    WebView的尺寸不能比设备的屏幕尺寸更大；</div><div class="line">    限制在少数WebView上使用该模式；</div><div class="line">    在可见的WebView和即将显现的WebView上使用；</div><div class="line"></div><div class="line">setPluginState (WebSettings.PluginState state)</div><div class="line">在API18以上已废弃。未来将不支持插件，不要使用。告诉WebView启用、禁用或者有即用（on demand）的插件，即用模式是指如果存在一个可以处理嵌入内容的插件，会显示一个占位图标，点击时开启。默认值OFF。</div><div class="line"></div><div class="line">setRenderPriority (WebSettings.RenderPriority priority)</div><div class="line">在API18以上已废弃。不建议调整线程优先级，未来版本不会支持这样做。设置绘制（Render，很多书上翻译成渲染，貌似很专业，但是不易懂，不敢苟同）线程的优先级。不像其他设置，同一进程中只需调用一次，默认值NORMAL。</div><div class="line"></div><div class="line">setSansSerifFontFamily (String font)</div><div class="line">设置无衬线字体集（sans-serif font family）的名字。默认值”sans-serif”.</div><div class="line"></div><div class="line">setSaveFormData (boolean save)</div><div class="line">WebView是否保存表单数据，默认值true。</div><div class="line"></div><div class="line">setSavePassword (boolean save)</div><div class="line">API18以上版本已废弃。未来版本将不支持保存WebView中的密码。设置WebView是否保存密码，默认true。</div><div class="line"></div><div class="line">setSerifFontFamily (String font)</div><div class="line">设置衬线字体集（serif font family）的名字，默认“sans-serif”。</div><div class="line"></div><div class="line">setStandardFontFamily (String font)</div><div class="line">设置标准字体集的名字，默认值“sans-serif”。</div><div class="line"></div><div class="line">setSupportMultipleWindows (boolean support)</div><div class="line">设置WebView是否支持多窗口。如果设置为true，主程序要实现onCreateWindow(WebView, boolean, boolean, Message)，默认false。</div><div class="line"></div><div class="line">setSupportZoom (boolean support)</div><div class="line">WebView是否支持使用屏幕上的缩放控件和手势进行缩放，默认值true。设置setBuiltInZoomControls(boolean)可以使用特殊的缩放机制。该项设置不会影响zoomIn() and zoomOut()的缩放操作。</div><div class="line"></div><div class="line">setTextSize (WebSettings.TextSize t)</div><div class="line">API14版本以上已废弃。请取代使用setTextZoom(int)。设置页面文本的尺寸，默认NORMAL。</div><div class="line"></div><div class="line">setTextZoom (int textZoom)</div><div class="line">设置页面上的文本缩放百分比，默认100。</div><div class="line"></div><div class="line">setUseWideViewPort (boolean use)</div><div class="line">WebView是否支持HTML的“viewport”标签或者使用wide viewport。设置值为true时，布局的宽度总是与WebView控件上的设备无关像素（device-dependent pixels）宽度一致。当值为true且页面包含viewport标记，将使用标签指定的宽度。如果页面不包含标签或者标签没有提供宽度，那就使用wide viewport。</div><div class="line"></div><div class="line">setUserAgentString (String ua)</div><div class="line">设置WebView的用户代理字符串。如果字符串为null或者empty，将使用系统默认值。注意从KITKAT版本开始，加载网页时改变用户代理会让WebView再次初始化加载。</div><div class="line"></div><div class="line">supportMultipleWindows ()</div><div class="line">获取WebView是否支持多窗口的值。</div><div class="line"></div><div class="line">supportZoom ()</div><div class="line">获取WebView是否支持缩放的值。</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下webview缓存的文章
    
    </summary>
    
      <category term="webView缓存" scheme="http://yoursite.com/categories/webView%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="Android,webView,cache" scheme="http://yoursite.com/tags/Android-webView-cache/"/>
    
  </entry>
  
  <entry>
    <title>Andorid下的webview的CookieManager全解析</title>
    <link href="http://yoursite.com/2017/05/25/Android%E4%B8%8BwebView%E7%9A%84CookieManager%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/05/25/Android下webView的CookieManager全解析/</id>
    <published>2017-05-25T09:11:53.000Z</published>
    <updated>2017-06-03T12:03:47.572Z</updated>
    
    <content type="html"><![CDATA[<p>#Android下webview的CookieManager详解</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=340395&auto=1&height=66"></iframe>

<h2 id="CookieManager介绍"><a href="#CookieManager介绍" class="headerlink" title="CookieManager介绍"></a>CookieManager介绍</h2><ul>
<li>java.net.CookieManager<ul>
<li>java.net.CookieManager供java工程使用的（略）</li>
</ul>
</li>
<li>android.webkit.CookieManager<ul>
<li>android.webkit.CookieManager包下提供了供andorid系统使用的一个cookie管理的类<ul>
<li>Manages the cookies used by an application’s WebView instances.<ul>
<li>Cookies are manipulated according to RFC2109.<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Android APP应用的某些功能, 需要调用内嵌的WebView去加载某个URL使用.  但用户在手机APP已经成功登录过了. 这时, 如果在内置浏览器去打开网页还需要用户再输入登录一次, 似乎显得不够人性化.  又或者, 用户在内置浏览器(WebView) 访问过一些页面, 想把这些有用的 Cookies 信息保存在本地.  因此, 我们会想, 要是能管理APP上浏览器(WebView) 在该站点URL的 Cookies, 使后台识别为已登录, 棒棒哒~</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li><p>1、客户端通过以下代码设置cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CookieManager cookieManager = CookieManager.getInstance();   //获取单例对象</div><div class="line">cookieManager.setCookie(url, &quot;uid=test_value&quot;); 	    	//同步方法，给url设置cookie字段，key为uid,value为test_value</div></pre></td></tr></table></figure>
</li>
<li><p>2、CookieManager会将这个Cookie存入该应用程序/data/data/databases/目录下的webviewCookiesChromium.db数据库的cookies表中</p>
</li>
<li><p>3、打开网页，WebView从数据库中读取该cookie值，放到http请求的头部，传递到服务器</p>
</li>
<li><p>4、客户端可以在某些时刻清除该应用程序用到的所有cookies</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CookieManager cookieManager = CookieManager.getInstance(); //获取单例对象</div><div class="line">cookieManager.removeAllCookie();//清除所有的cookie</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="天坑所在"><a href="#天坑所在" class="headerlink" title="天坑所在"></a>天坑所在</h2><ul>
<li>removeAllCookie（）与removeSessionCookies（）竟然是异步的删除cookie的方法，但是却没有回调。所以会出现一种您觉得你删除成功了，其实并没有删除成功的情况，那你再次登录可能会存在cookie同步不合预期的情况产生。<h2 id="API解析"><a href="#API解析" class="headerlink" title="API解析"></a>API解析</h2></li>
<li>以下来解析源码，read the funk source code:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Gets the singleton CookieManager instance.</div><div class="line"> *</div><div class="line"> * @return the singleton CookieManager instance</div><div class="line"> */</div><div class="line">public static synchronized CookieManager getInstance() &#123;  //获取单例对象</div><div class="line">    return WebViewFactory.getProvider().getCookieManager();   </div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets whether the application&apos;s &#123;@link WebView&#125; instances should send and</div><div class="line"> * accept cookies.</div><div class="line"> * By default this is set to true and the WebView accepts cookies.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * When this is true</div><div class="line"> * &#123;@link CookieManager#setAcceptThirdPartyCookies setAcceptThirdPartyCookies&#125; and</div><div class="line"> * &#123;@link CookieManager#setAcceptFileSchemeCookies setAcceptFileSchemeCookies&#125;</div><div class="line"> * can be used to control the policy for those specific types of cookie.</div><div class="line"> *</div><div class="line"> * @param accept whether &#123;@link WebView&#125; instances should send and accept</div><div class="line"> *               cookies</div><div class="line"> */</div><div class="line">public abstract void setAcceptCookie(boolean accept);  //设置是否接受cookie,默认是true</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether the application&apos;s &#123;@link WebView&#125; instances send and accept</div><div class="line"> * cookies.</div><div class="line"> *</div><div class="line"> * @return true if &#123;@link WebView&#125; instances send and accept cookies</div><div class="line"> */</div><div class="line">public abstract boolean acceptCookie(); //获取webview是否接受cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets whether the &#123;@link WebView&#125; should allow third party cookies to be set.</div><div class="line"> * Allowing third party cookies is a per WebView policy and can be set</div><div class="line"> * differently on different WebView instances.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Apps that target &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125; or below</div><div class="line"> * default to allowing third party cookies. Apps targeting</div><div class="line"> * &#123;@link android.os.Build.VERSION_CODES#LOLLIPOP&#125; or later default to disallowing</div><div class="line"> * third party cookies.</div><div class="line"> *</div><div class="line"> * @param webview the &#123;@link WebView&#125; instance to set the cookie policy on</div><div class="line"> * @param accept whether the &#123;@link WebView&#125; instance should accept</div><div class="line"> *               third party cookies</div><div class="line"> */</div><div class="line">public abstract void setAcceptThirdPartyCookies(WebView webview, boolean accept);//  设置跨域cookie读取,当Build.Version小于kitkat时候，默认值是true,之后的为false</div><div class="line">     </div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether the &#123;@link WebView&#125; should allow third party cookies to be set.</div><div class="line"> *</div><div class="line"> * @param webview the &#123;@link WebView&#125; instance to get the cookie policy for</div><div class="line"> * @return true if the &#123;@link WebView&#125; accepts third party cookies</div><div class="line"> */</div><div class="line">public abstract boolean acceptThirdPartyCookies(WebView webview);  //获取是否设置了跨域cookie读取</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets a cookie for the given URL. Any existing cookie with the same host,</div><div class="line"> * path and name will be replaced with the new cookie. The cookie being set</div><div class="line"> * will be ignored if it is expired.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookie is to be set</div><div class="line"> * @param value the cookie as a string, using the format of the &apos;Set-Cookie&apos;</div><div class="line"> *              HTTP response header</div><div class="line"> */</div><div class="line">public abstract void setCookie(String url, String value); //根据URL设置cookie字段</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets a cookie for the given URL. Any existing cookie with the same host,</div><div class="line"> * path and name will be replaced with the new cookie. The cookie being set</div><div class="line"> * will be ignored if it is expired.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This method is asynchronous.</div><div class="line"> * If a &#123;@link ValueCallback&#125; is provided,</div><div class="line"> * &#123;@link ValueCallback#onReceiveValue(T) onReceiveValue()&#125; will be called on the current</div><div class="line"> * thread&apos;s &#123;@link android.os.Looper&#125; once the operation is complete.</div><div class="line"> * The value provided to the callback indicates whether the cookie was set successfully.</div><div class="line"> * You can pass &#123;@code null&#125; as the callback if you don&apos;t need to know when the operation</div><div class="line"> * completes or whether it succeeded, and in this case it is safe to call the method from a</div><div class="line"> * thread without a Looper.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookie is to be set</div><div class="line"> * @param value the cookie as a string, using the format of the &apos;Set-Cookie&apos;</div><div class="line"> *              HTTP response header</div><div class="line"> * @param callback a callback to be executed when the cookie has been set</div><div class="line"> */</div><div class="line">public abstract void setCookie(String url, String value, ValueCallback&lt;Boolean&gt; callback);//根据url覆盖cookie某字段的值</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets the cookies for the given URL.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookies are requested</div><div class="line"> * @return value the cookies as a string, using the format of the &apos;Cookie&apos;</div><div class="line"> *               HTTP request header</div><div class="line"> */</div><div class="line">public abstract String getCookie(String url);  //根据url获取cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * See &#123;@link #getCookie(String)&#125;.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookies are requested</div><div class="line"> * @param privateBrowsing whether to use the private browsing cookie jar</div><div class="line"> * @return value the cookies as a string, using the format of the &apos;Cookie&apos;</div><div class="line"> *               HTTP request header</div><div class="line"> * @hide Used by Browser and by WebViewProvider implementations.</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">public abstract String getCookie(String url, boolean privateBrowsing);  //系统api</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets cookie(s) for a given uri so that it can be set to &quot;cookie:&quot; in http</div><div class="line"> * request header.</div><div class="line"> *</div><div class="line"> * @param uri the WebAddress for which the cookies are requested</div><div class="line"> * @return value the cookies as a string, using the format of the &apos;Cookie&apos;</div><div class="line"> *               HTTP request header</div><div class="line"> * @hide Used by RequestHandle and by WebViewProvider implementations.</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">public synchronized String getCookie(WebAddress uri) &#123; //系统api</div><div class="line">    return getCookie(uri.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all session cookies, which are cookies without an expiration</div><div class="line"> * date.</div><div class="line"> * @deprecated use &#123;@link #removeSessionCookies(ValueCallback)&#125; instead.</div><div class="line"> */</div><div class="line">public abstract void removeSessionCookie();  //清除未过期的cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all session cookies, which are cookies without an expiration</div><div class="line"> * date.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This method is asynchronous.</div><div class="line"> * If a &#123;@link ValueCallback&#125; is provided,</div><div class="line"> * &#123;@link ValueCallback#onReceiveValue(T) onReceiveValue()&#125; will be called on the current</div><div class="line"> * thread&apos;s &#123;@link android.os.Looper&#125; once the operation is complete.</div><div class="line"> * The value provided to the callback indicates whether any cookies were removed.</div><div class="line"> * You can pass &#123;@code null&#125; as the callback if you don&apos;t need to know when the operation</div><div class="line"> * completes or whether any cookie were removed, and in this case it is safe to call the</div><div class="line"> * method from a thread without a Looper.</div><div class="line"> * @param callback a callback which is executed when the session cookies have been removed</div><div class="line"> */</div><div class="line">public abstract void removeSessionCookies(ValueCallback&lt;Boolean&gt; callback);  //坑爹的异步方法</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all cookies.</div><div class="line"> * @deprecated Use &#123;@link #removeAllCookies(ValueCallback)&#125; instead.</div><div class="line"> */</div><div class="line">@Deprecated</div><div class="line">public abstract void removeAllCookie();</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all cookies.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This method is asynchronous.</div><div class="line"> * If a &#123;@link ValueCallback&#125; is provided,</div><div class="line"> * &#123;@link ValueCallback#onReceiveValue(T) onReceiveValue()&#125; will be called on the current</div><div class="line"> * thread&apos;s &#123;@link android.os.Looper&#125; once the operation is complete.</div><div class="line"> * The value provided to the callback indicates whether any cookies were removed.</div><div class="line"> * You can pass &#123;@code null&#125; as the callback if you don&apos;t need to know when the operation</div><div class="line"> * completes or whether any cookies were removed, and in this case it is safe to call the</div><div class="line"> * method from a thread without a Looper.</div><div class="line"> * @param callback a callback which is executed when the cookies have been removed</div><div class="line"> */</div><div class="line">public abstract void removeAllCookies(ValueCallback&lt;Boolean&gt; callback); //清除所有cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether there are stored cookies.</div><div class="line"> *</div><div class="line"> * @return true if there are stored cookies</div><div class="line"> */</div><div class="line">public abstract boolean hasCookies();  //获取是否有cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * See &#123;@link #hasCookies()&#125;.</div><div class="line"> *</div><div class="line"> * @param privateBrowsing whether to use the private browsing cookie jar</div><div class="line"> * @hide Used by Browser and WebViewProvider implementations.</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">public abstract boolean hasCookies(boolean privateBrowsing); //系统api</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all expired cookies.</div><div class="line"> * @deprecated The WebView handles removing expired cookies automatically.</div><div class="line"> */</div><div class="line">@Deprecated</div><div class="line">public abstract void removeExpiredCookie();   //清除过期的cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Ensures all cookies currently accessible through the getCookie API are</div><div class="line"> * written to persistent storage.</div><div class="line"> * This call will block the caller until it is done and may perform I/O.</div><div class="line"> */</div><div class="line">public abstract void flush(); //确保cookie都是写进本地了，会阻塞IO</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether the application&apos;s &#123;@link WebView&#125; instances send and accept</div><div class="line"> * cookies for file scheme URLs.</div><div class="line"> *</div><div class="line"> * @return true if &#123;@link WebView&#125; instances send and accept cookies for</div><div class="line"> *         file scheme URLs</div><div class="line"> */</div><div class="line">// Static for backward compatibility.</div><div class="line">public static boolean allowFileSchemeCookies() &#123;  </div><div class="line">    return getInstance().allowFileSchemeCookiesImpl();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Implements &#123;@link #allowFileSchemeCookies()&#125;.</div><div class="line"> *</div><div class="line"> * @hide Only for use by WebViewProvider implementations</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">protected abstract boolean allowFileSchemeCookiesImpl();</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets whether the application&apos;s &#123;@link WebView&#125; instances should send and</div><div class="line"> * accept cookies for file scheme URLs.</div><div class="line"> * Use of cookies with file scheme URLs is potentially insecure and turned</div><div class="line"> * off by default.</div><div class="line"> * Do not use this feature unless you can be sure that no unintentional</div><div class="line"> * sharing of cookie data can take place.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Note that calls to this method will have no effect if made after a</div><div class="line"> * &#123;@link WebView&#125; or CookieManager instance has been created.</div><div class="line"> */</div><div class="line">// Static for backward compatibility.</div><div class="line">public static void setAcceptFileSchemeCookies(boolean accept) &#123;</div><div class="line">    getInstance().setAcceptFileSchemeCookiesImpl(accept);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Implements &#123;@link #setAcceptFileSchemeCookies(boolean)&#125;.</div><div class="line"> *</div><div class="line"> * @hide Only for use by WebViewProvider implementations</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">protected abstract void setAcceptFileSchemeCookiesImpl(boolean accept);</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下webview的CookieManager的文章
    
    </summary>
    
      <category term="webView的CookieManager" scheme="http://yoursite.com/categories/webView%E7%9A%84CookieManager/"/>
    
    
      <category term="Android,webView,cookie,CookieManager" scheme="http://yoursite.com/tags/Android-webView-cookie-CookieManager/"/>
    
  </entry>
  
  <entry>
    <title>设计模式全解析</title>
    <link href="http://yoursite.com/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/05/07/设计模式全解析/</id>
    <published>2017-05-07T09:49:51.000Z</published>
    <updated>2017-05-07T11:32:32.653Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>#设计模式全解析（不断更新中…）：</p>
</blockquote>
<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><ul>
<li><p>java 语言面向对象的三大特征：封装、继承、多态。</p>
<ul>
<li>封装性<ul>
<li>封装性就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义：<ul>
<li>把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位（即对象）。</li>
<li>信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界〔或者说形成一道屏障〕，只保留有限的对外接口使之与外部发生联系。</li>
</ul>
</li>
<li>封装的原则在软件上的反映是：要求使对象以外的部分不能随意存取对象的内部数据（属性），从而有效的避免了外部错误对它的”交叉感染”，使软件错误能够局部化，大大减少查错和排错的难度。</li>
</ul>
</li>
<li><p>继承性</p>
<ul>
<li>特殊类的对象拥有其一般类的全部属性与服务，称作特殊类对一般类的继承。一个类可以是多个一般类的特殊类，它从多个一般类中继承了属性与服务，这称为多继承。在java语言中，通常我们称一般类为父类（superclass,超类），特殊类为子类(subclass)。</li>
</ul>
</li>
<li><p>多态性</p>
<ul>
<li>对象的多态性是指在一般类中定义的属性或服务被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或服务在一般类及其各个特殊 类中具有不同的语义。例如：”几何图形”的”绘图”方法，”椭圆”和”多边形”都是”几何图”的子类，其”绘图”方法功能不同。</li>
</ul>
</li>
</ul>
</li>
<li><p>java 语言面向对象的六大原则</p>
<ul>
<li>开闭原则</li>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特原则</li>
</ul>
</li>
<li><p>23种传统设计模式：（已经完成11种）</p>
<ul>
<li>1.单例设计模式　（完成）</li>
<li>2.工厂方法模式　（完成）</li>
<li>3.抽象工厂模式　（完成）</li>
<li>4.模板方法模式　（完成）</li>
<li>5.建造者模式　（完成）</li>
<li>6.代理模式　（完成）</li>
<li>7.原型模式</li>
<li>8.中介者模式</li>
<li>9.命令模式</li>
<li>10.责任链模式</li>
<li>11.装饰模式　（完成）</li>
<li>12.策略模式　（完成）</li>
<li>13.适配器模式（完成）</li>
<li>14.迭代器模式</li>
<li>15.组合模式</li>
<li>16.观察者模式（完成）</li>
<li>17.门面模式</li>
<li>18.备忘录模式</li>
<li>19.访问者模式</li>
<li>20.状态模式</li>
<li>21.解释器模式</li>
<li>22.享元模式（完成）</li>
<li>23.桥梁模式</li>
</ul>
</li>
<li>23种传统设计模式PK<ul>
<li>创建类模式包含工厂方法模式、建造者模式，抽象工厂模式，单例模式和原型模式（5种），他们都能提供对象的创建和管理职责。其中单例模式和原型模式比较容易理解，单例模式是要在内存中只有一个对象，原型模式是要通过复制的方式产生一个新的对象，这两个不容易混淆，剩下的就是工厂方法模式、抽象工厂模式和建造者模式了。这三个之间有较多的相似性。</li>
<li>结构类模式包括适配器模式，桥梁模式，组合模式，装饰模式，门面模式，享元模式和代理模式（7种），为什么叫结构类模式呢，因为他们都是通过组合类或者对象产生更大结构以适应更高层次的逻辑需求的。</li>
<li>行为类模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式（11种）。</li>
</ul>
</li>
<li>23种传统设计模式混编<ul>
<li>比如说：<ul>
<li>命令模式 +　责任链模式</li>
<li>工厂方法模式 +　策略模式</li>
<li>观察者模式　＋　中介者模式</li>
</ul>
</li>
</ul>
</li>
<li>新的设计模式<ul>
<li>规格模式、对象池模式、雇工模式、黑板模式、空对象模式…</li>
</ul>
</li>
</ul>
<h1 id="女孩儿与设计模式"><a href="#女孩儿与设计模式" class="headerlink" title="女孩儿与设计模式"></a>女孩儿与设计模式</h1><blockquote>
<p>形象的总结一下设计模式。</p>
</blockquote>
<ul>
<li><p>1.SINGLETON 单例模式</p>
<ul>
<li><p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
</li>
<li><p>俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)。</p>
</li>
</ul>
</li>
<li><p>2.FACTORY METHOD 工厂方法模式</p>
<ul>
<li><p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
</li>
<li><p>请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。</p>
</li>
</ul>
</li>
<li><p>3.FACTORY 工厂模式</p>
<ul>
<li><p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
</li>
<li><p>追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory。</p>
</li>
</ul>
</li>
<li><p>4.BUILDER 建造模式</p>
<ul>
<li><p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
</li>
<li><p>MM最爱听的就是“我爱你”这句话了，见到不同地方的MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）</p>
</li>
</ul>
</li>
<li><p>5.PROTOTYPE 原型模式</p>
<ul>
<li><p>原型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
</li>
<li><p>跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。 原型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。</p>
</li>
</ul>
</li>
<li><p>6.ADAPTER 适配器模式</p>
<ul>
<li><p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
</li>
<li><p>在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)。</p>
</li>
</ul>
</li>
<li><p>7.BRIDGE 桥梁模式</p>
<ul>
<li><p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
</li>
<li><p>早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。</p>
</li>
</ul>
</li>
<li><p>8.COMPOSITE 合成模式</p>
<ul>
<li><p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
</li>
<li><p>Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？</p>
</li>
</ul>
</li>
<li><p>9.DECORATOR 装饰模式</p>
<ul>
<li><p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
</li>
<li><p>Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
</li>
</ul>
</li>
<li><p>10.FACADE 门面（外观）模式</p>
<ul>
<li><p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
</li>
<li><p>我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。</p>
</li>
</ul>
</li>
<li><p>11.FLYWEIGHT 享元模式</p>
<ul>
<li><p>享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
</li>
<li><p>每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。</p>
</li>
</ul>
</li>
<li><p>12.PROXY 代理模式</p>
<ul>
<li><p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
</li>
<li><p>跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
</li>
</ul>
</li>
<li><p>13.CHAIN OF RESPONSIBLEITY 责任链模式</p>
<ul>
<li><p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
</li>
<li><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!</p>
</li>
</ul>
</li>
<li><p>14.COMMAND 命令模式</p>
<ul>
<li><p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
</li>
<li><p>俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”</p>
</li>
</ul>
</li>
<li><p>15.INTERPRETER 解释器模式</p>
<ul>
<li><p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
</li>
<li><p>俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。</p>
</li>
</ul>
</li>
<li><p>16.ITERATOR 迭代子模式</p>
<ul>
<li><p>迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
</li>
<li><p>我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” ……</p>
</li>
</ul>
</li>
<li><p>17.MEDIATOR 调停者模式</p>
<ul>
<li><p>调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
</li>
<li><p>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
</li>
</ul>
</li>
<li><p>18.MEMENTO 备忘录模式</p>
<ul>
<li><p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
</li>
<li><p>同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
</li>
</ul>
</li>
<li><p>19.OBSERVER 观察者模式</p>
<ul>
<li><p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
</li>
<li><p>想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>
</li>
</ul>
</li>
<li><p>20.STATE 状态模式</p>
<ul>
<li><p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
</li>
<li><p>跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。</p>
</li>
</ul>
</li>
<li><p>21.STRATEGY 策略模式</p>
<ul>
<li><p>策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
</li>
<li><p>跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。</p>
</li>
</ul>
</li>
<li><p>22.TEMPLATE METHOD 模板模式</p>
<ul>
<li><p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
</li>
<li><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)。</p>
</li>
</ul>
</li>
<li><p>23.VISITOR 访问者模式</p>
<ul>
<li><p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
</li>
<li><p>情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了。</p>
</li>
</ul>
</li>
</ul>
<h1 id="设计模式各个击破"><a href="#设计模式各个击破" class="headerlink" title="设计模式各个击破"></a>设计模式各个击破</h1><p>##1.单例设计模式</p>
<ul>
<li>保证类在内存中只有一个对象。</li>
<li>如何保证类在内存中只有一个对象呢？<ul>
<li>控制类的创建，不让其他类来创建本类的对象，也就是私有化构造；</li>
<li>在本类中定义本类的对象；</li>
<li>提供公共的访问方式；</li>
</ul>
</li>
<li><p>单例的几种写法</p>
<ul>
<li><p>饿汉式：直接new出对象，这种就是以空间换时间</p>
<pre><code>//饿汉式
class Singleton {
    //1,私有构造函数
    private Singleton(){}
    //2,创建本类对象
    private static Singleton s = new Singleton();
    //3,对外提供公共的访问方法
    public static Singleton getInstance() {
        return s;
    }

    public static void print() {
        System.out.println(&quot;饿汉式的方法&quot;);
    }
}
</code></pre></li>
<li><p>(2)懒汉式 面试写这种方式。多线程的问题？</p>
<pre><code>//懒汉式,单例的延迟加载模式
class Singleton {
    //1,私有构造函数
    private Singleton(){}
    //2,声明一个本类的引用
    private static Singleton s;
    //3,对外提供公共的访问方法
    public static Singleton getInstance() {
        if(s == null)
            //线程1,线程2（可能某个对象在wait()）
            s = new Singleton();
        return s;
    }

    public static void print() {
        System.out.println(&quot;懒汉式的方法&quot;);
    }
}
 * 饿汉式和懒汉式的区别
 * 1,饿汉式是空间换时间,懒汉式是时间换空间
 * 2,在多线程访问时,饿汉式不会创建多个对象,而懒汉式有可能会创建多个对象
 */

由于懒汉式存在线程安全的问题，所以我们可以这样做：
使用双重检测锁机制，先检测是否为空，如果为空再对该单例类加锁，再判断一次是否为空，这样既解决了线程的安全问题，也避免了每次使用单例都要加锁带来的系统资源的消耗。代码如下：
class Singleton {
    //1,私有构造函数
    private Singleton(){}
    //2,声明一个本类的引用
    private static volatile Singleton s;
    //3,对外提供公共的访问方法
    public static Singleton getInstance() {
        if(s == null)
            Synchronized(Singleton.class){
                if(s == null) {
                    s = new Singleton();
                }
            }
        return s;
    }

    public static void print() {
        System.out.println(&quot;懒汉式的方法&quot;);
    }
}
</code></pre></li>
<li><p>(3)第三种格式</p>
<pre><code>class Singleton {
    private Singleton() {}

    public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改
}
</code></pre></li>
</ul>
</li>
</ul>
<p>##2.装饰设计模式</p>
<ul>
<li><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<pre><code>public class Demo_Wrap {

    /**
     * @param args
     * 装饰设计模式的好处是:
     * 耦合性不强,被装饰的类的变化与装饰类的变化无关
     */
    public static void main(String[] args) {
        AdvanceStudent as = new AdvanceStudent(new Student());
        as.code();
    }

}

interface Coder {
    public void code();
}

class Student implements Coder {

    @Override
    public void code() {
        System.out.println(&quot;javase&quot;);
        System.out.println(&quot;javaweb&quot;);
    }

}

class AdvanceStudent implements Coder {
    //1,获取被装饰类的引用
    private Student s;                        //获取学生引用

    //2,在构造方法中传入被装饰类的对象
    public AdvanceStudent(Student s) {
        this.s = s;
    }

    //3,对原有的功能进行升级
    @Override
    public void code() {
        s.code();
        System.out.println(&quot;ssh&quot;);
        System.out.println(&quot;数据库&quot;);
        System.out.println(&quot;大数据&quot;);
        System.out.println(&quot;...&quot;);
    }
}
</code></pre></li>
</ul>
<p>##3.简单工厂设计模式</p>
<ul>
<li>简单工厂模式概述<ul>
<li>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例</li>
</ul>
</li>
<li>优点<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责</li>
</ul>
</li>
<li>缺点<ul>
<li>这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</li>
</ul>
</li>
<li>案例演示<ul>
<li>动物抽象类：public abstract Animal { public abstract void eat(); }</li>
<li>具体狗类：public class Dog extends Animal {}</li>
<li>具体猫类：public class Cat extends Animal {}</li>
<li>开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。</li>
</ul>
</li>
<li><pre><code>//动物抽象类
public abstract class Animal {
    public abstract void eat();
}
</code></pre></li>
</ul>
<pre><code>//猫类
public class Cat extends Animal {

    @Override
    public void eat() {
        System.out.println(&quot;猫吃鱼&quot;);
    }

}


//狗类
public class Dog extends Animal {

    @Override
    public void eat() {
        System.out.println(&quot;狗吃肉&quot;);
    }

}

//动物工厂类
public class AnimalFactory {
    /*public static Dog createDog() {
        return new Dog();
    }

    public static Cat createCat() {
        return new Cat();
    }*/

    //发现方法会定义很多,复用性太差
    //改进
    public static Animal createAnimal(String name) {
        if(&quot;dog&quot;.equals(name)) {
            return new Dog();
        }else if(&quot;cat&quot;.equals(name)) {
            return new Cat();
        }else {
            return null;
        }
    }
}

//测试类
public class Test {

    /**
     * @param args
     */
    public static void main(String[] args) {
        //Dog d = AnimalFactory.createDog();

        Dog d = (Dog) AnimalFactory.createAnimal(&quot;dog&quot;);
        d.eat();

        Cat c = (Cat) AnimalFactory.createAnimal(&quot;cat&quot;);
        c.eat();
    }
}
</code></pre><p>##3.工厂方法设计模式</p>
<ul>
<li>工厂方法模式概述<ul>
<li>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</li>
</ul>
</li>
<li>优点<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li>
</ul>
</li>
<li>缺点<ul>
<li>需要额外的编写代码，增加了工作量</li>
</ul>
</li>
<li>案例演示<ul>
<li>动物抽象类：public abstract Animal { public abstract void eat(); }</li>
<li>工厂接口：public interface Factory {public abstract Animal createAnimal();}</li>
<li>具体狗类：public class Dog extends Animal {}</li>
<li>具体猫类：public class Cat extends Animal {}<br>开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。</li>
<li>狗工厂：public class DogFactory implements Factory {<pre><code>    public Animal createAnimal() {…}
}
</code></pre></li>
<li>猫工厂：public class CatFactory implements Factory {<pre><code>    public Animal createAnimal() {…}
}  
</code></pre></li>
</ul>
</li>
</ul>
<pre><code>//动物抽象类
public abstract class Animal {
    public abstract void eat();
}

//工厂接口
public interface Factory {
    public Animal createAnimal();
}

//猫工厂类
public class CatFactory implements Factory {

    @Override
    public Animal createAnimal() {

        return new Cat();
    }

}

//猫类
public class Cat extends Animal {

    @Override
    public void eat() {
        System.out.println(&quot;猫吃鱼&quot;);
    }

}

//狗工厂类
public class DogFactory implements Factory {

    @Override
    public Animal createAnimal() {

        return new Dog();
    }

}

//狗类
public class Dog extends Animal {

    @Override
    public void eat() {
        System.out.println(&quot;狗吃肉&quot;);
    }

}

//测试类
public class Test {

    /**
     * @param args
     */
    public static void main(String[] args) {
        DogFactory df = new DogFactory();
        Dog d = (Dog) df.createAnimal();
        d.eat();
    }

}
</code></pre><p>##4.抽象工厂设计模式</p>
<ul>
<li>定义：提供一个创建一系列相关或者相互依赖产品的接口， 而无需制定他们的具体类，一对多的关系。抽象工厂模式是 工厂方法模式的升级版。</li>
<li>例子： 我们接着前边土豪的故事继续讲。话说这个土豪还有一个爱好，就是打猎。但是土豪打猎是有要求的（毕竟土豪嘛，要就就得高一点），他如果坐Audi车去打猎，那么他就一定要使用AK47这把枪（这是去打猎吗？）；如果他坐Benz车去打猎那么他就一定要用M4A1这把枪，如果按照我们前边讲的工厂方法模式来编程，那么应该是建立一个Car的抽象工厂类CarFactory，然后Benz车的工厂继承自这个抽象的父类并实现生产Benz车的方法，Audi车的工厂继承自这个抽象的父类并实现生产Audi车的方法。并且还要有一个生产Gun的抽象工厂类，由它的具体子类工厂来实现生产AK47和M4A1。这样做是非常麻烦的，我们已经知道了如果土豪做Audi的话那他一定是使用AK47，所以我们可以使用一个工厂来同时生产Audi车和AK47，注意我说的前提是我们已经知道了土豪一定是Audi车和AK47一起使用的，如果不满足这个条件的话是不能使用抽象工厂模式来解决这个问题的。</li>
<li><p>优点：即符合面向对象设计的“开闭原则”和“单一职责原 则”。又减少了系统中的类的数量，不用像工厂方法一样每生 产一个产品都要有一个具体的工厂类。</p>
<pre><code>/**
 * 仅仅定义生产同一族产品的两个不同等级结构的产品接口，具体的实现由子类工厂来实现
 * @Mr.Wu
 *
 */
public abstract class AbstractFactory {
    public abstract Car getCar();
    public abstract Gun getGun();   
}
</code></pre></li>
</ul>
<pre><code>/**
 * Audi车的工厂同时生产Audi车和配套的AK47
 * @Mr.Wu
 *
 */
public class AudiFactory extends AbstractFactory{

    public Car getCar() {       
        return new Audi();      
    }

    public Gun getGun() {
        return new AK47();
    }
}


/**
 * Benz车的工厂同时生产Benz车和配套的M4A1
 * @Mr.Wu
 *
 */
public class BenzFactory extends AbstractFactory{

    public Car getCar() {        
        return new Benz();        
    }

    public Gun getGun() {
        return new M4A1();
    }
}

//gun的抽象类
public abstract class Gun {
    abstract void fire();
}

//M4A1的具体类
public class M4A1 extends Gun{

    public M4A1(){
        System.out.println(&quot;Create an M4A1&quot;);
    }

    public void fire(){
        System.out.println(&quot;M4A1 start fire&quot;);
    }
}

//AK47的类
public class AK47 extends Gun{

    public AK47(){
        System.out.println(&quot;Create an AK47&quot;);
    }

    public void fire(){
        System.out.println(&quot;AK47 start fire&quot;);
    }
}

//车的抽象类
public abstract class Car {
    abstract void drive();
}

//奥迪车的类
public class Audi extends Car{

    public Audi(){
        System.out.println(&quot;Create a Audi&quot;);
    }

    public void drive(){
        System.out.println(&quot;Audi start engine&quot;);
    }
}

//奔驰车的类
public class Benz extends Car{

    public Benz(){
        System.out.println(&quot;Create a Benz&quot;);
    }

    public void drive(){
        System.out.println(&quot;Benz start engine&quot;);
    }
}

//测试类
public class Main {

    public static void main(String[] args) throws Exception {
        //奔驰车司机
        AbstractFactory factory = new BenzFactory();
        //今天想做奥迪车
        Car car = factory.getCar();
        //开车
        car.drive();
        //获得开Benz时要用的枪
        Gun gun = factory.getGun();
        //开火
        gun.fire();
    }
}
</code></pre><blockquote>
<p>说明：当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
</blockquote>
<h2 id="5-享元设计模式"><a href="#5-享元设计模式" class="headerlink" title="5.享元设计模式"></a>5.享元设计模式</h2><ul>
<li><p>解释一下概念：也就是说在一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。比如说一个文本系统，每个字母定一个对象，那么大小写字母一共就是52个，那么就要定义52个对象。如果有一个1M的文本，那么字母是何其的多，如果每个字母都定义一个对象那么内存早就爆了。那么如果要是每个字母都共享一个对象，那么就大大节约了资源。</p>
</li>
<li><p>在Flyweight模式中，由于要产生各种各样的对象，所以在Flyweight(享元)模式中常出现Factory模式。Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个对象存储池（Flyweight Pool）来存放内部状态的对象。Flyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多，下面举个例子：</p>
<pre><code>      　　先定义一个抽象的Flyweight类：
package Flyweight;  
public abstract class Flyweight{  
　public abstract void operation();  
}  
实现一个具体类：
</code></pre></li>
</ul>
<pre><code>    package Flyweight;  
    public class ConcreteFlyweight extends Flyweight{  
    　private String string;  
    　public ConcreteFlyweight(String str){  
    　　string = str;  
    　}  
    　public void operation()  
    　{  
    　　System.out.println(&quot;Concrete---Flyweight : &quot; + string);  
    　}  
    }  

实现一个工厂方法类：

    package Flyweight;  
    import java.util.Hashtable;  
    public class FlyweightFactory{  
    　private Hashtable flyweights = new Hashtable();//----------------------------1  
    　public FlyweightFactory(){}  
    　public Flyweight getFlyWeight(Object obj){  
    　　Flyweight flyweight = (Flyweight) flyweights.get(obj);//----------------2  
    　　if(flyweight == null){//---------------------------------------------------3  
    　　　//产生新的ConcreteFlyweight  
    　　　flyweight = new ConcreteFlyweight((String)obj);  
    　　　flyweights.put(obj, flyweight);//--------------------------------------5  
    　　}  
    　　return flyweight;//---------------------------------------------------------6  
    　}  
    　public int getFlyweightSize(){  
    　　return flyweights.size();  
    　}  
    }  

这个工厂方法类非常关键，这里详细解释一下：
　　在1处定义了一个Hashtable用来存储各个对象；在2处选出要实例化的对象，在6处将该对象返回，如果在Hashtable中没有要选择的对象，此时变量flyweight为null，产生一个新的flyweight存储在Hashtable中，并将该对象返回。
　　最后看看Flyweight的调用：

    package Flyweight;  
    import java.util.Hashtable;  
    public class FlyweightPattern{  
    　FlyweightFactory factory = new FlyweightFactory();   
    　Flyweight fly1;  
    　Flyweight fly2;  
    　Flyweight fly3;  
    　Flyweight fly4;  
    　Flyweight fly5;  
    　Flyweight fly6;  
    　/** *//** Creates a new instance of FlyweightPattern */  
    　public FlyweightPattern(){  
    　　fly1 = factory.getFlyWeight(&quot;Google&quot;);  
    　　fly2 = factory.getFlyWeight(&quot;Qutr&quot;);  
    　　fly3 = factory.getFlyWeight(&quot;Google&quot;);  
    　　fly4 = factory.getFlyWeight(&quot;Google&quot;);  
    　　fly5 = factory.getFlyWeight(&quot;Google&quot;);  
    　　fly6 = factory.getFlyWeight(&quot;Google&quot;);  
    　}  
    　public void showFlyweight(){  
    　　fly1.operation();  
    　　fly2.operation();  
    　　fly3.operation();  
    　　fly4.operation();  
    　　fly5.operation();  
    　　fly6.operation();  
    　　int objSize = factory.getFlyweightSize();  
    　　System.out.println(&quot;objSize = &quot; + objSize);  
    　}  
    　public static void main(String[] args){  
    　　System.out.println(&quot;The FlyWeight Pattern!&quot;);  
    　　FlyweightPattern fp = new FlyweightPattern();  
    　　fp.showFlyweight();  
    　}  
    }  


下面是运行结果：

    Concrete---Flyweight : Google  
    Concrete---Flyweight : Qutr  
    Concrete---Flyweight : Google  
    Concrete---Flyweight : Google  
    Concrete---Flyweight : Google  
    Concrete---Flyweight : Google  
    objSize = 2  


　我们定义了6个对象，其中有5个是相同的，按照Flyweight模式的定义“Google”应该共享一个对象，在实际的对象数中我们可以看出实际的对象却是只有2个。

总结：
　　Flyweight(享元)模式是如此的重要，因为它能帮你在一个复杂的系统中大量的节省内存空间。在Java语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。String a=&quot;abc&quot;，其中&quot;abc&quot;就是一个字符串常量。

熟悉java的应该知道下面这个例子：
    String a = &quot;hello&quot;;  
    String b = &quot;hello&quot;;  
    if(a == b)  
    　System.out.println(&quot;OK&quot;);  
    else  
    　System.out.println(&quot;Error&quot;);  

输出结果是：OK。可以看出if条件比较的是两a和b的地址，也可以说是内存空间
核心总结，可以共享的对象，也就是说返回的同一类型的对象其实是同一实例，当客户端要求生成一个对象时，工厂会检测是否存在此对象的实例，如果存在那么直接返回此对象实例，如果不存在就创建一个并保存起来，这点有些单例模式的意思。通常工厂类会有一个集合类型的成员变量来用以保存对象，如hashtable,vector等。在java中，数据库连接池，线程池等即是用享元模式的应用。
</code></pre><p>##6.适配器设计模式</p>
<pre><code>public class Demo_Adapter {

    /**
     * @param args
     * 适配器设计模式
     * 鲁智深
     */
    public static void main(String[] args) {
        鲁智深 鲁智深 = new 鲁智深();
        鲁智深.习武();
    }

}

interface 和尚 {
    public void 打坐();
    public void 念经();
    public void 撞钟();
    public void 习武();
}

abstract class 天罡星 implements 和尚 {        //声明成抽象的原因是,不想让其他类创建本类对象,因为创建也没有意义,方法都是空的

    @Override
    public void 打坐() {
    }

    @Override
    public void 念经() {
    }

    @Override
    public void 撞钟() {
    }

    @Override
    public void 习武() {
    }

}

class 鲁智深 extends 天罡星 {
    public void 习武() {
        System.out.println(&quot;倒拔垂杨柳&quot;);
        System.out.println(&quot;拳打镇关西&quot;);
        System.out.println(&quot;大闹野猪林&quot;);
        System.out.println(&quot;......&quot;);
    }
}
</code></pre><p>##7.模板方法设计模式</p>
<ul>
<li>模版设计模式概述<br>模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</li>
<li>优点和缺点<ul>
<li>优点:使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</li>
<li>缺点:如果算法骨架有修改的话，则需要修改抽象类</li>
</ul>
</li>
</ul>
<pre><code>public class Demo1_Template {

    /**
     * @param args
     */
    public static void main(String[] args) {
        /*long start = System.currentTimeMillis();
        for(int i = 0; i &lt; 1000000; i++) {
            System.out.println(&quot;x&quot;);
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);*/
        Demo d = new Demo();
        System.out.println(d.getTime());
    }

}

abstract class GetTime {
    public final long getTime() {
        long start = System.currentTimeMillis();
        code();
        long end = System.currentTimeMillis();
        return end - start;
    }  //final修饰，目的是不让被重写

    public abstract void code(); //由子类取实现想测试的代码
}

class Demo extends GetTime {

    @Override
    public void code() {
        int i = 0;
        while(i &lt; 100000) {
            System.out.println(&quot;x&quot;);
            i++;
        }
    }
}
</code></pre><p>##8.观察者设计模式</p>
<ul>
<li>定义：又名发布—订阅模式，对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li><p>组成部分：</p>
<ul>
<li><p>抽象目标(被观察者)角色(Subject)：目标角色知道它的观察者，可以 有任意多个观察者观察同一个目标。并且提供注册和删除观 察者对象、通知观察者的方法。目标角色往往由抽象类或者 接口来实现。</p>
</li>
<li><p>抽象观察者角色(Observer)：为那些在目标发生改变时需<br>要获得通知的对象定义一个更新接口，里面有一个更新数据 的方法。抽象观察者角色主要由抽象类或者接口来实现。</p>
</li>
<li>具体目标(被观察者)角色(Concrete Subject)：实现Subject，实现添 加、删除观察者、通知观察者的方法，当它的状态发生改变 时, 向它的各个观察者发出通知。</li>
<li>具体观察者角色(Concrete Observer)：实现Observer的更 新接口以使自身状态与目标的状态保持一致，获取通知进行 更新。</li>
</ul>
</li>
<li><p>观察者模式中，一个被观察者管理所有相依于它的观察者物件，并且在本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p>
</li>
<li>举例：珠宝商运送一批钻石，有黄金强盗准备抢劫，珠宝商雇佣了私人保镖，警察局也派人护送，于是当运输车上路的时候，强盗保镖警察都要观察运输车一举一动，</li>
</ul>
<pre><code>抽象的观察者
    public interface Watcher  
    {  
         public void update();  
    }  


抽象的被观察者，在其中声明方法（添加、移除观察者，通知观察者）：
    public interface Watched  
    {  
         public void addWatcher(Watcher watcher);  

         public void removeWatcher(Watcher watcher);  

         public void notifyWatchers();  
    }  



具体的观察者
保镖
    public class Security implements Watcher  
    {  
         @Override  
         public void update()  
         {  
              System.out.println(“运输车有行动，保安贴身保护&quot;);  
         }  
    }  

强盗
    public class Thief implements Watcher  
    {  
         @Override  
         public void update()  
         {  
              System.out.println(“运输车有行动，强盗准备动手&quot;);  
         }  
    }  

警察
    public class Police implements Watcher  
    {  
         @Override  
         public void update()  
         {  
              System.out.println(“运输车有行动，警察护航&quot;);  
         }  
    }  

具体的被观察者
    public class Transporter implements Watched  
    {  
         private List&lt;Watcher&gt; list = new ArrayList&lt;Watcher&gt;();  

         @Override  
         public void addWatcher(Watcher watcher)  
         {  
              list.add(watcher);  
         }  

         @Override  
         public void removeWatcher(Watcher watcher)  
         {  
              list.remove(watcher);  
         }  

         @Override  
         public void notifyWatchers(String str)  
         {  
              for (Watcher watcher : list)  
              {  
                   watcher.update();  
              }  
         }  

    }  

测试类


    public class Test  
    {  
         public static void main(String[] args)  
         {  
              Transporter transporter = new Transporter();  

              Police police = new Police();  
              Security security = new Security();  
              Thief thief = new Thief();  

              transporter.addWatcher(police);  
              transporter.addWatcher(security);  
              transporter.addWatcher(security);  

              transporter.notifyWatchers();  
         }  
    }  
</code></pre><ul>
<li>我推你拉例子中没有关于数据和状态的变化通知，只是简单通知到各个观察者，告诉他们被观察者有行动。<br>观察者模式在关于目标角色、观察者角色通信的具体实现中，有两个版本。<ul>
<li>一种情况便是目标角色在发生变化后，仅仅告诉观察者角色“我变化了”，观察者角色如果想要知道具体的变化细节，则就要自己从目标角色的接口中得到。这种模式被很形象的称为：拉模式——就是说变化的信息是观察者角色主动从目标角色中“拉”出来的。</li>
<li>还有一种方法，那就是我目标角色“服务一条龙”，通知你发生变化的同时，通过一个参数将变化的细节传递到观察者角色中去。这就是“推模式”——管你要不要，先给你啦。</li>
</ul>
</li>
<li>这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。如果目标角色比较简单，则“拉模式”就很合适啦。<br>##9.代理设计模式</li>
<li>什么是代理模式：代理模式的作用是，为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>好处：在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</li>
<li>代理模式一般涉及到的角色有：<ul>
<li>抽象角色：声明真实对象和代理对象的共同接口；</li>
<li>代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</li>
<li>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</li>
</ul>
</li>
<li><p>应用场景举例：比如西门庆找潘金莲，那潘金莲不好意思答复呀，咋办，找那个王婆做代理，表现在程序上时是这样的体现的先说说这个场景中的要素：一种类型的女人，潘金莲，王婆，西门庆，后来扩展的贾氏也和西门庆勾上了，我们是假设的，然后西门庆找潘金莲happy,但潘金莲不好意思直接，就找个王婆代理呗。我们看看具体代码。</p>
<pre><code>先定义一种女人
/** 
 *  
 * @author Mr.Wu
 *定义一种类型的女人，王婆和潘金莲都属于这个类型的女人 
 */  
public interface KindWoman {  

    //这种女人能做什么事情呢？  
    public void makeEyesWithMan();//抛媚眼  

    public void happyWithMan();//和男人那个....  

}  
</code></pre></li>
</ul>
<pre><code>一种类型嘛，那肯定是接口，定义个潘金莲 
    /** 
     *  
     * @author Mr.Wu
     *定义一个潘金莲是什么样的人 
     */  
    public class PanJinLian  implements KindWoman{  

        @Override  
        public void happyWithMan() {  
            System.out.println(&quot;潘金莲和男人在做那个...&quot;);  

        }  

        @Override  
        public void makeEyesWithMan() {  
            System.out.println(&quot;潘金莲抛媚眼...&quot;);  

        }  

    }  



再定义个丑陋的王婆 
    /** 
     *  
     * @author Mr.Wu
     *王婆这个人老聪明了，她太老了，是个男人都看不上她， 
     *但是她有智慧经验呀，他作为一类女人的代理！ 
     */  
    public class WangPo implements KindWoman {  

        private KindWoman kindWoman;  

        public WangPo(){  
            //默认的话是潘金莲的代理  
            this.kindWoman = new PanJinLian();  
        }  
        //她可以是KindWomam的任何一个女人的代理，只要你是这一类型  
        public WangPo(KindWoman kindWoman){  
            this.kindWoman = kindWoman;  
        }  

        @Override  
        public void happyWithMan() {  
            //自己老了，干不了了，但可以叫年轻的代替。  
            this.kindWoman.happyWithMan();  

        }  

        @Override  
        public void makeEyesWithMan() {  
            //王婆年纪大了，谁看她抛媚眼啊  
            this.kindWoman.makeEyesWithMan();  

        }  

    }  



两个女主角都上场了，该男主角了，定义个西门庆
    /** 
     *  
     * @author Mr.Wu
     *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下，西门庆看痴迷了，被王婆看到了，就开始撮合两人好事，王婆作为潘金莲的代理人收了不少好处费，那我们假设一下： 
     *如果没有王婆在中间牵线，这两个不要脸的能成事吗？难说得很！ 
     */  
    public class XiMenQing {  

        /** 
         * @param args 
         */  
        public static void main(String[] args) {  
            WangPo wangPo;  
            //把王婆叫出来  
             wangPo = new WangPo();  
            //然后西门庆说，我要和潘金莲Happy,然后王婆就安排了西门庆丢筷子哪出戏：  
            wangPo.makeEyesWithMan();  
            //看到没有表面是王婆在做，其实爽的是潘金莲  
            wangPo.happyWithMan();  



        }  

    }  



那这就是活生生的一个例子，通过代理人实现了某种目的，如果真去了王婆这个中间环节，直接西门庆和潘金莲勾搭，估计很难成就武松杀嫂事件。

     那我们再考虑一下，水浒里面还有没有这类型的女人？有，卢俊义的老婆贾氏（就是和那个管家苟合的那个），这个名字起的：“贾氏”，那我们也让王婆做她的代理：
    /** 
     *  
     * @author Mr.Wu
     *定义一个贾氏是什么样的人 
     */  
    public class JiaShi implements KindWoman {  

        @Override  
        public void happyWithMan() {  
            System.out.println(&quot;贾氏和男人在做那个...&quot;);  

        }  

        @Override  
        public void makeEyesWithMan() {  
            System.out.println(&quot;贾氏抛媚眼...&quot;);  

        }  


    }  



西门庆勾潘金莲又勾引贾氏
    /** 
     *  
     * @author Mr.Wu
     *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下，西门庆看痴迷了，被王婆看到了，就开始撮合两人好事，王婆作为潘金莲的代理人收了不少好处费，那我们假设一下： 
     *如果没有王婆在中间牵线，这两个不要脸的能成事吗？难说得很！ 
     */  
    public class XiMenQing {  

        /** 
         * @param args 
         */  
        public static void main(String[] args) {  
            WangPo wangPo;  
            //把王婆叫出来  
             wangPo = new WangPo();  
            //然后西门庆说，我要和潘金莲Happy,然后王婆就安排了西门庆丢筷子哪出戏：  
            wangPo.makeEyesWithMan();  
            //看到没有表面是王婆在做，其实爽的是潘金莲  
            wangPo.happyWithMan();  



            //西门庆勾引贾氏  
            JiaShi jiaShi = new JiaShi();  
            wangPo = new WangPo(jiaShi);  
            wangPo.makeEyesWithMan();  
            wangPo.happyWithMan();  

        }  

    }  
</code></pre><blockquote>
<p>说完这个故事，那我总结一下，代理模式主要使用了java的多态，干活的是被代理类，代理类主要是接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能干呢？同根就成，大家知根知底，你能做啥，我能做啥都清楚得很，同样一个接口呗。好了不多说了，慢慢体会吧。</p>
<p>##10.策略设计模式</p>
</blockquote>
<ul>
<li><p>背景</p>
<p>  在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。<br>  这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p>
</li>
</ul>
<ul>
<li><p>问题</p>
<p>  如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？</p>
</li>
<li><p>方案</p>
<p>  把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。<br>  比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。</p>
</li>
<li><p>适用情况</p>
<p>  许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。<br>  ，而且该程序有多种实现方式时使用。<br>  一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</p>
</li>
<li><p>优点</p>
<pre><code>1、可以动态的改变对象的行为
缺点
1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2、策略模式将造成产生很多策略类
</code></pre></li>
<li><p>组成</p>
<p>  环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。<br>  抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。<br>  具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。</p>
</li>
<li><p>应用</p>
<p>  场景如下，刘备要到江东娶老婆了，走之前诸葛亮给赵云三个锦囊妙计，说是按天机拆开能解决棘手问题。场景中出现三个要素：三个妙计（具体策略类）、一个锦囊（环境类）、赵云（调用者）。</p>
<pre><code>抽象策略类（Strategy）
</code></pre></li>
</ul>
<pre><code>    public interface Strategy {  
         public void operate();  
    }  


三个实现类（ConcreteStrategy）：
妙计一：初到吴国


    public class BackDoor implements IStrategy {  
         @Override  
         public void operate() {  
              System.out.println(&quot;找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备&quot;);  
         }  
    }  

妙计二：求吴国太开绿灯放行


    public class GivenGreenLight implements IStrategy {  
         @Override  
         public void operate() {  
              System.out.println(&quot;求吴国太开个绿灯，放行&quot;);  
         }  
    }  

妙计三：孙夫人断后，挡住追兵


    public class BlackEnemy implements IStrategy {  
         @Override  
         public void operate() {  
              System.out.println(&quot;孙夫人断后，挡住追兵&quot;);  
         }  
    }  


环境类（Context)


    public class Context {  
         private Strategy strategy;  
         //构造函数，要你使用哪个妙计  
         public Context(Strategy strategy){  
              this.strategy = strategy;  
         }  
         public void setStrategy(Strategy strategy){  
              this.strategy = strategy;  
         }  
         public void operate(){  
              this.strategy.operate();  
         }  
    }  


下面就是使用的情况了


    public class Zhaoyun {  

    public static void main(String[] args) {  
         Context context;  

         System.out.println(&quot;----------刚到吴国使用第一个锦囊---------------&quot;);  
         context = new Context(new BackDoor());  
         context.operate();  
         System.out.println(&quot;\n&quot;);  

         System.out.println(&quot;----------刘备乐不思蜀使用第二个锦囊---------------&quot;);  
         context.setStrategy(new GivenGreenLight());  
         context.operate();  
         System.out.println(&quot;\n&quot;);  

         System.out.println(&quot;----------孙权的追兵来了，使用第三个锦囊---------------&quot;);  
         context.setStrategy(new BlackEnemy());  
         context.operate();  
         System.out.println(&quot;\n&quot;);  
         }  
    }  


三招下来，搞得的周郎是“赔了夫人又折兵”。

以上就是策略模式，多种不同解决方案动态切换，起到改变对象行为的效果。
</code></pre><p>##11.建造者设计模式</p>
<ul>
<li><p>概念</p>
<pre><code>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 [构建与表示分离，同构建不同表示]
与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。
</code></pre><p>  　　建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。<br>  　　举个简单的例子，如汽车，有很多部件，车轮，方向盘，发动机还有各种小零件等等，部件很多，但远不止这些，如何将这些部件装配成一部汽车，这个装配过程也很复杂（需要很好的组装技术）， builder模式就是为了将部件和组装分开。</p>
</li>
<li><p>代码</p>
<pre><code> public interface Builder { 
  　　　　void buildPartA(); 
  　　　　void buildPartB(); 
  　　　　void buildPartC(); 
  　　
  　　　　Product getResult(); 
  　　} 

//具体建造工具
  　　public class ConcreteBuilder implements Builder { 
  　　　　Part partA, partB, partC; 

  　　　　public void buildPartA() {
  　　　　　　//这里是具体如何构建partA的代码
  　　　　}; 
  　　　　public void buildPartB() { 
  　　　　　　//这里是具体如何构建partB的代码
  　　　　}; 
  　　　　 public void buildPartC() { 
  　　　　　　//这里是具体如何构建partB的代码
  　　　　}; 
  　　　　 public Product getResult() { 
  　　　　　　//返回最后组装成品结果
  　　　　}; 
  　　}

//指导者
  　　public class Director {
  　　　　private Builder builder; 
  　　
  　　　　public Director( Builder builder ) { 
  　　　　　　this.builder = builder; 
  　　　　} 
  　　　　public void construct() { 
  　　　　　　builder.buildPartA();
  　　　　　　builder.buildPartB();
  　　　　　　builder.buildPartC(); 
  　　　　} 
  　　} 
</code></pre></li>
</ul>
<pre><code>    　　public interface Product { }
    　　public interface Part { }
    　　

下面是调用builder的方法：
    　　ConcreteBuilder builder = new ConcreteBuilder();
    　　Director director = new Director( builder ); 
    　　
    　　director.construct(); 
    　　Product product = builder.getResult();
</code></pre><ul>
<li>应用场景<ul>
<li>在Java的应用中JavaMail使用到了该模式，android中的Dialog使用到该模式</li>
</ul>
</li>
</ul>
<h2 id="12-原型模式"><a href="#12-原型模式" class="headerlink" title="12.原型模式"></a>12.原型模式</h2><h2 id="13-中介者模式"><a href="#13-中介者模式" class="headerlink" title="13.中介者模式"></a>13.中介者模式</h2><h2 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14.命令模式"></a>14.命令模式</h2><h2 id="15-责任链模式"><a href="#15-责任链模式" class="headerlink" title="15.责任链模式"></a>15.责任链模式</h2><h2 id="16-迭代器模式"><a href="#16-迭代器模式" class="headerlink" title="16.迭代器模式"></a>16.迭代器模式</h2><h2 id="17-组合模式"><a href="#17-组合模式" class="headerlink" title="17.组合模式"></a>17.组合模式</h2><h2 id="18-门面模式"><a href="#18-门面模式" class="headerlink" title="18.门面模式"></a>18.门面模式</h2><h2 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19.备忘录模式"></a>19.备忘录模式</h2><h2 id="20-访问者模式"><a href="#20-访问者模式" class="headerlink" title="20.访问者模式"></a>20.访问者模式</h2><h2 id="21-状态模式"><a href="#21-状态模式" class="headerlink" title="21.状态模式"></a>21.状态模式</h2><h2 id="22-解释器模式"><a href="#22-解释器模式" class="headerlink" title="22.解释器模式"></a>22.解释器模式</h2><h2 id="23-桥梁模式"><a href="#23-桥梁模式" class="headerlink" title="23.桥梁模式"></a>23.桥梁模式</h2>]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述设计模式的文章
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GetLuckyMoneyPluginByMr.Wu_微信自动抢红包插件</title>
    <link href="http://yoursite.com/2017/01/25/GetLuckyMoneyPlugin_%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/01/25/GetLuckyMoneyPlugin_微信自动抢红包插件/</id>
    <published>2017-01-25T08:05:00.000Z</published>
    <updated>2017-01-25T09:45:22.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ul>
<li>使用AccessibilityService对程序进行模拟点击</li>
<li>使用系统服务监听应用UI变化</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul>
<li>打开『GetLuckyMoneyPluginByMr.Wu』的应用，开启插件。</li>
<li><p>等待微信红包进账。    </p>
<ul>
<li>注意:最好设置屏幕常亮<h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1></li>
</ul>
</li>
<li><p>第一步打开软件</p>
</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/ee5da0b30b69187a.png" alt="step1"></p>
<ul>
<li>第二步查看服务的开启状态</li>
</ul>
<p><img src="http://i1.piimg.com/567571/4110ed8a2711aab7.png" alt="step2"></p>
<ul>
<li>第三步开启服务</li>
</ul>
<p><img src="http://i1.piimg.com/567571/a613fe8e11b60c26.png" alt="step3"></p>
<ul>
<li>第四步检查服务是否开启</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/2121008ddd2564a8.png" alt="step4"></p>
<h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h1><ul>
<li><a href="https://www.pgyer.com/zrCk" target="_blank" rel="external">最新版下载链接</a></li>
<li>下载密码：4321</li>
<li>由于不可描述的原因，应用的链接可能会失效，若发现失效请<a href="http://pan.baidu.com/s/1qYRN6zi" target="_blank" rel="external">点击该处通过百度云</a>获取应用最新安装包。</li>
</ul>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><ul>
<li>插件使用者自行承担随之而来的各种风险，包括但不限于“禁用红包功能”、“微信封号”，不过该插件用户群体较少，所以该风险较小。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一款微信抢红包的插件，适用于自动发现红包和自动点击打开红包，让你抢红包总是快人一步（注意：该插件无法控制抢到的金额，只是能在速度上取胜）。
    
    </summary>
    
      <category term="生活相关" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="微信红包，插件，自动点击打开" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%EF%BC%8C%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%87%AA%E5%8A%A8%E7%82%B9%E5%87%BB%E6%89%93%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>HappyNewYear</title>
    <link href="http://yoursite.com/2016/12/31/HappyNewYear_2017/"/>
    <id>http://yoursite.com/2016/12/31/HappyNewYear_2017/</id>
    <published>2016-12-31T13:05:00.000Z</published>
    <updated>2017-01-12T13:58:18.372Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=30394763&auto=1&height=66"></iframe>

<h4 id="故事的小黄花"><a href="#故事的小黄花" class="headerlink" title="故事的小黄花"></a>故事的小黄花</h4><h4 id="从出生那年就飘着"><a href="#从出生那年就飘着" class="headerlink" title="从出生那年就飘着"></a>从出生那年就飘着</h4><h4 id="童年的荡秋千"><a href="#童年的荡秋千" class="headerlink" title="童年的荡秋千"></a>童年的荡秋千</h4><h4 id="随记忆一直晃到现在"><a href="#随记忆一直晃到现在" class="headerlink" title="随记忆一直晃到现在"></a>随记忆一直晃到现在</h4><h4 id="rui-sou-sou-xi-dou-xi-la"><a href="#rui-sou-sou-xi-dou-xi-la" class="headerlink" title="rui sou sou xi dou xi la"></a>rui sou sou xi dou xi la</h4><h4 id="sou-la-xi-xi-xi-xi-la-xi-la-sou"><a href="#sou-la-xi-xi-xi-xi-la-xi-la-sou" class="headerlink" title="sou la xi xi xi xi la xi la sou"></a>sou la xi xi xi xi la xi la sou</h4><h4 id="吹着前奏望着天空"><a href="#吹着前奏望着天空" class="headerlink" title="吹着前奏望着天空"></a>吹着前奏望着天空</h4><h4 id="我想起花瓣试着掉落"><a href="#我想起花瓣试着掉落" class="headerlink" title="我想起花瓣试着掉落"></a>我想起花瓣试着掉落</h4><h4 id="为你翘课的那一天"><a href="#为你翘课的那一天" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天"><a href="#花落的那一天" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间"><a href="#教室的那一间" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="我怎么看不见"><a href="#我怎么看不见" class="headerlink" title="我怎么看不见"></a>我怎么看不见</h4><h4 id="消失的下雨天"><a href="#消失的下雨天" class="headerlink" title="消失的下雨天"></a>消失的下雨天</h4><h4 id="我好想再淋一遍"><a href="#我好想再淋一遍" class="headerlink" title="我好想再淋一遍"></a>我好想再淋一遍</h4><h4 id="没想到失去的勇气我还留着"><a href="#没想到失去的勇气我还留着" class="headerlink" title="没想到失去的勇气我还留着"></a>没想到失去的勇气我还留着</h4><h4 id="好想再问一遍"><a href="#好想再问一遍" class="headerlink" title="好想再问一遍"></a>好想再问一遍</h4><h4 id="你会等待还是离开"><a href="#你会等待还是离开" class="headerlink" title="你会等待还是离开"></a>你会等待还是离开</h4><h4 id="刮风这天我试过握着你手"><a href="#刮风这天我试过握着你手" class="headerlink" title="刮风这天我试过握着你手"></a>刮风这天我试过握着你手</h4><h4 id="但偏偏雨渐渐大到我看你不见"><a href="#但偏偏雨渐渐大到我看你不见" class="headerlink" title="但偏偏雨渐渐大到我看你不见"></a>但偏偏雨渐渐大到我看你不见</h4><h4 id="还要多久我才能在你身边"><a href="#还要多久我才能在你身边" class="headerlink" title="还要多久我才能在你身边"></a>还要多久我才能在你身边</h4><h4 id="等到放晴的那天也许我会比较好一点"><a href="#等到放晴的那天也许我会比较好一点" class="headerlink" title="等到放晴的那天也许我会比较好一点"></a>等到放晴的那天也许我会比较好一点</h4><h4 id="从前从前有个人爱你很久"><a href="#从前从前有个人爱你很久" class="headerlink" title="从前从前有个人爱你很久"></a>从前从前有个人爱你很久</h4><h4 id="但偏偏风渐渐把距离吹得好远"><a href="#但偏偏风渐渐把距离吹得好远" class="headerlink" title="但偏偏风渐渐把距离吹得好远"></a>但偏偏风渐渐把距离吹得好远</h4><h4 id="好不容易又能再多爱一天"><a href="#好不容易又能再多爱一天" class="headerlink" title="好不容易又能再多爱一天"></a>好不容易又能再多爱一天</h4><h4 id="但故事的最后你好像还是说了拜拜"><a href="#但故事的最后你好像还是说了拜拜" class="headerlink" title="但故事的最后你好像还是说了拜拜"></a>但故事的最后你好像还是说了拜拜</h4><h4 id="为你翘课的那一天-1"><a href="#为你翘课的那一天-1" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-1"><a href="#花落的那一天-1" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-1"><a href="#教室的那一间-1" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="我怎么看不见-1"><a href="#我怎么看不见-1" class="headerlink" title="我怎么看不见"></a>我怎么看不见</h4><h4 id="消失的下雨天-1"><a href="#消失的下雨天-1" class="headerlink" title="消失的下雨天"></a>消失的下雨天</h4><h4 id="我好想再淋一遍-1"><a href="#我好想再淋一遍-1" class="headerlink" title="我好想再淋一遍"></a>我好想再淋一遍</h4><h4 id="没想到失去的勇气我还留着-1"><a href="#没想到失去的勇气我还留着-1" class="headerlink" title="没想到失去的勇气我还留着"></a>没想到失去的勇气我还留着</h4><h4 id="好想再问一遍-1"><a href="#好想再问一遍-1" class="headerlink" title="好想再问一遍"></a>好想再问一遍</h4><h4 id="你会等待还是离开-1"><a href="#你会等待还是离开-1" class="headerlink" title="你会等待还是离开"></a>你会等待还是离开</h4><h4 id="刮风这天我试过握着你手-1"><a href="#刮风这天我试过握着你手-1" class="headerlink" title="刮风这天我试过握着你手"></a>刮风这天我试过握着你手</h4><h4 id="但偏偏雨渐渐大到我看你不见-1"><a href="#但偏偏雨渐渐大到我看你不见-1" class="headerlink" title="但偏偏雨渐渐大到我看你不见"></a>但偏偏雨渐渐大到我看你不见</h4><h4 id="还要多久我才能在你身边-1"><a href="#还要多久我才能在你身边-1" class="headerlink" title="还要多久我才能在你身边"></a>还要多久我才能在你身边</h4><h4 id="等到放晴的那天也许我会比较好一点-1"><a href="#等到放晴的那天也许我会比较好一点-1" class="headerlink" title="等到放晴的那天也许我会比较好一点"></a>等到放晴的那天也许我会比较好一点</h4><h4 id="从前从前有个人爱你很久-1"><a href="#从前从前有个人爱你很久-1" class="headerlink" title="从前从前有个人爱你很久"></a>从前从前有个人爱你很久</h4><h4 id="偏偏风渐渐把距离吹得好远"><a href="#偏偏风渐渐把距离吹得好远" class="headerlink" title="偏偏风渐渐把距离吹得好远"></a>偏偏风渐渐把距离吹得好远</h4><h4 id="好不容易又能再多爱一天-1"><a href="#好不容易又能再多爱一天-1" class="headerlink" title="好不容易又能再多爱一天"></a>好不容易又能再多爱一天</h4><h4 id="但故事的最后你好像还是说了拜拜-1"><a href="#但故事的最后你好像还是说了拜拜-1" class="headerlink" title="但故事的最后你好像还是说了拜拜"></a>但故事的最后你好像还是说了拜拜</h4><h4 id="为你翘课的那一天-2"><a href="#为你翘课的那一天-2" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="为你翘课的那一天-3"><a href="#为你翘课的那一天-3" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="为你翘课的那一天-4"><a href="#为你翘课的那一天-4" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-2"><a href="#花落的那一天-2" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-2"><a href="#教室的那一间-2" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="为你翘课的那一天-5"><a href="#为你翘课的那一天-5" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-3"><a href="#花落的那一天-3" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-3"><a href="#教室的那一间-3" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="为你翘课的那一天-6"><a href="#为你翘课的那一天-6" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-4"><a href="#花落的那一天-4" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-4"><a href="#教室的那一间-4" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><hr>
<h4 id="对今年的总结："><a href="#对今年的总结：" class="headerlink" title="对今年的总结："></a>对今年的总结：</h4><ul>
<li>今年是特殊的一年，鬼知道我到底经历了什么。</li>
</ul>
<h4 id="对来年的展望："><a href="#对来年的展望：" class="headerlink" title="对来年的展望："></a>对来年的展望：</h4><ul>
<li>愿新的一年，我们都能被这个世界温柔相待。</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/e8b8b80752ba1ecd.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      对今年的总结和对未来的展望
    
    </summary>
    
      <category term="生活相关" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="新年快乐，HappyNewYear" scheme="http://yoursite.com/tags/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%8CHappyNewYear/"/>
    
  </entry>
  
  <entry>
    <title>android里handler线程间的通信详解</title>
    <link href="http://yoursite.com/2016/09/07/Android%E4%B8%8B%E7%9A%84handler%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/09/07/Android下的handler线程间通信全解析/</id>
    <published>2016-09-06T16:00:00.000Z</published>
    <updated>2017-05-07T12:28:34.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android里handler线程间的通信详解"><a href="#android里handler线程间的通信详解" class="headerlink" title="android里handler线程间的通信详解"></a>android里handler线程间的通信详解</h1><p>本文基于Android 的源代码，来分析Java层的handler消息处理机制</p>
<ul>
<li><p>相关源码</p>
<pre><code>framework/base/core/java/andorid/os/Handler.java
framework/base/core/java/andorid/os/Looper.java
framework/base/core/java/andorid/os/Message.java
framework/base/core/java/andorid/os/MessageQueue.java
libcore/luni/src/main/java/java/lang/ThreadLocal.java
</code></pre><h1 id="一-概述："><a href="#一-概述：" class="headerlink" title="一.概述："></a>一.概述：</h1></li>
</ul>
<p>在整个Android的源码世界里，有两大利剑，其一是Binder IPC机制，，另一个便是消息机制(由Handler/Looper/MessageQueue等构成的)。<br>Android有大量的消息驱动方式来进行交互，比如Android的四剑客Activity, Service, Broadcast, ContentProvider的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。消息机制涉及MessageQueue/Message/Looper/Handler这4个类。</p>
<p>##1.1模型：<br>消息机制包含：</p>
<ul>
<li>Message:消息分为硬件产生的消息（如按钮、触摸）和软件生成的消息；</li>
<li>MessageQueue：消息队列的主要功能向消息池投递消息（MessageQueue.enqueueMessage）和取走消息池的消息（MessageQueue.next）</li>
<li>Handler:消息辅助类，主要的功能是向消息池发送各种消息事件（Handler.sendMessage）和处理响应的消息事件（Handler.handleMessage）</li>
<li>Looper:不断循环执行（Looper.loop）,按照分发机制将消息分发给目标处理者</li>
</ul>
<p>##1.2 构架图</p>
<p><img src="/img/Main.jpg" alt=""> </p>
<ul>
<li>Looper有一个MessageQueue消息队列；</li>
<li>MessageQueue有一组待处理的Message；</li>
<li>Message中有一个用于处理消息的Handler；</li>
<li>Handler中有Looper和MessageQueue。</li>
</ul>
<p>##1.3典型事例</p>
<ul>
<li>在android的实际开发中，一般我们都是在主线程里new出Handler的对象，然后在子线程里用该对象向主线程发送消息，然后我们在主线程里处理该消息；</li>
<li>那我们怎么实现主线程向子线程里传递数据呢？要实现这个目的我们必须在子线程里new一个Handler的对象，然后用该Handler对象在主线程发送消息到主线程。但是在子线程new Handler是会报错：没有Looper，不能new Handler。那么我们就必须先调用Looper.prepare方法准备一个Looper对象，然后调用Looper.loop方法开始轮询。</li>
<li><p>Android 系统的消息队列和消息循环都是针对具体线程的，一个线程可以存在（当然也可以不存在）一个消息队列和一个消息循环（Looper），特定线程的消息只能分发给本线程，不能进行跨线程，跨进程通讯。但是创建的工作线程默认是没有消息循环和消息队列的，如果想让该线程具有消息队列和消息循环，需要在线程中首先调用Looper.prepare()来创建消息队列，然后调用Looper.loop()进入消息循环。 如下例所示：</p>
<pre><code>class LooperThread extends Thread {
public Handler mHandler;

public void run() {
  Looper.prepare();//给线程创建一个消息循环  //【见 2.1】
  mHandler = new Handler() {  //【见 3.1】
    public void handleMessage(Message msg) {
     // process incoming messages here  定义消息处理逻辑. 【见 3.2】
    }
  };
  Looper.loop();//使消息循环起作用，从消息队列里取消息，处理消息【见 2.2】
  }
}
</code></pre></li>
</ul>
<blockquote>
<p>注：写在Looper.loop()之后的代码不会被立即执行，当调用后 mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。Looper对象通过MessageQueue 来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。这样你的线程就具有了消息处理机制了，在Handler中进行消息处理。</p>
</blockquote>
<h1 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h1><p>##2.1 prepare()</p>
<p>对于无参的情况，默认调用prepare(true)，表示的是这个Looper运行退出，而对于false的情况则表示当前Looper不运行退出。</p>
<pre><code>private static void prepare(boolean quitAllowed) {
    //每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    //创建Looper对象，并保存到当前线程的TLS区域
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre><p>这里的sThreadLocal是ThreadLocal类型，下面，先说说ThreadLocal。</p>
<p>ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法：</p>
<pre><code>ThreadLocal.set(T value)：将value存储到当前线程的TLS区域，源码如下：

  public void set(T value) {
      Thread currentThread = Thread.currentThread(); //获取当前线程
      Values values = values(currentThread); //查找当前线程的本地储存区
      if (values == null) {
          //当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象
          values = initializeValues(currentThread);
      }
      //保存数据value到当前线程this
      values.put(this, value);
  }

ThreadLocal.get()：获取当前线程TLS区域的数据，源码如下：

  public T get() {
      Thread currentThread = Thread.currentThread(); //获取当前线程
      Values values = values(currentThread); //查找当前线程的本地储存区
      if (values != null) {
          Object[] table = values.table;
          int index = hash &amp; values.mask;
          if (this.reference == table[index]) {
              return (T) table[index + 1]; //返回当前线程储存区中的数据
          }
      } else {
          //创建Values对象
          values = initializeValues(currentThread);
      }
      return (T) values.getAfterMiss(this); //从目标线程存储区没有查询是则返回null
  }
</code></pre><p>ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的sThreadLocal变量，其定义如下：</p>
<p>static final ThreadLocal<looper> sThreadLocal = new ThreadLocal<looper>()</looper></looper></p>
<p>可见sThreadLocal的get()和set()操作的类型都是Looper类型。</p>
<p>Looper.prepare()</p>
<p>Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。</p>
<p>对于Looper类型的构造方法如下：</p>
<pre><code>private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);  //创建MessageQueue对象. 【见4.1】
    mThread = Thread.currentThread();  //记录当前线程.
}
</code></pre><p>另外，与prepare()相近功能的，还有一个prepareMainLooper()方法，该方法主要在ActivityThread类中使用。</p>
<pre><code>public static void prepareMainLooper() {
    prepare(false); //设置不允许退出的Looper
    synchronized (Looper.class) {
        //将当前的Looper保存为主Looper，每个线程只允许执行一次。
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
</code></pre><p>##2.2loop()</p>
<pre><code>public static void loop() {
    final Looper me = myLooper();  //获取TLS存储的Looper对象 【见2.4】
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;  //获取Looper对象中的消息队列

    Binder.clearCallingIdentity();
    //确保在权限检查时基于本地进程，而不是基于最初调用进程。
    final long ident = Binder.clearCallingIdentity();

    for (;;) { //进入loop的主循环方法
        Message msg = queue.next(); //可能会阻塞 【见4.2】
        if (msg == null) { //没有消息，则退出循环
            return;
        }

        Printer logging = me.mLogging;  //默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }
        msg.target.dispatchMessage(msg); //用于分发Message 【见3.2】
        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        final long newIdent = Binder.clearCallingIdentity(); //确保分发过程中identity不会损坏
        if (ident != newIdent) {
             //打印identity改变的log，在分发消息过程中是不希望身份被改变的。
        }
        msg.recycleUnchecked();  //将Message放入消息池 【见5.2】
    }
}
</code></pre><p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p>
<pre><code>读取MessageQueue的下一条Message；
把Message分发给相应的target；
再把分发后的Message回收到消息池，以便重复利用。
</code></pre><p>这是这个消息处理的核心部分。另外，上面代码中可以看到有logging方法，这是用于debug的，默认情况下logging == null，通过设置setMessageLogging()用来开启debug工作。</p>
<p>##2.3 quit()</p>
<pre><code>public void quit() {
    mQueue.quit(false); //消息移除
}

public void quitSafely() {
    mQueue.quit(true); //安全地消息移除
}

Looper.quit()方法的实现最终调用的是MessageQueue.quit()方法

MessageQueue.quit()

void quit(boolean safe) {
        // 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常
        if (!mQuitAllowed) {
            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);
        }
        synchronized (this) {
            if (mQuitting) { //防止多次执行退出操作
                return;
            }
            mQuitting = true;
            if (safe) {
                removeAllFutureMessagesLocked(); //移除尚未触发的所有消息
            } else {
                removeAllMessagesLocked(); //移除所有的消息
            }
            //mQuitting=false，那么认定为 mPtr != 0
            nativeWake(mPtr);
        }
    }
</code></pre><p>消息退出的方式：</p>
<pre><code>当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；
当safe =flase时，移除所有的消息
</code></pre><p>##2.4 常用方法</p>
<ul>
<li>2.4.1 myLooper</li>
</ul>
<p>用于获取TLS存储的Looper对象</p>
<pre><code>public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
</code></pre><ul>
<li>2.4.2 post</li>
</ul>
<p>发送消息，并设置消息的callback，用于处理消息。</p>
<pre><code>public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}

private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
</code></pre><h1 id="三、Handler"><a href="#三、Handler" class="headerlink" title="三、Handler"></a>三、Handler</h1><p>##3.1 创建Handler</p>
<ul>
<li><p>3.1.1 无参构造</p>
<pre><code>public Handler() {
    this(null, false);
}

public Handler(Callback callback, boolean async) {
    //匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露
    if (FIND_POTENTIAL_LEAKS) {
        final Class&lt;? extends Handler&gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }
    //必须先执行Looper.prepare()，才能获取Looper对象，否则为null.
    mLooper = Looper.myLooper();  //从当前线程的TLS中获取Looper对象【见2.1】
    if (mLooper == null) {
        throw new RuntimeException(&quot;&quot;);
    }
    mQueue = mLooper.mQueue; //消息队列，来自Looper对象
    mCallback = callback;  //回调方法
    mAsynchronous = async; //设置消息是否为异步处理方式
}
</code></pre></li>
</ul>
<p>对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。</p>
<ul>
<li><p>3.1.2 有参构造</p>
<pre><code>public Handler(Looper looper) {
    this(looper, null, false);
}

public Handler(Looper looper, Callback callback, boolean async) {
    mLooper = looper;
    mQueue = looper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre></li>
</ul>
<p>Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。</p>
<p>##3.2 消息分发机制</p>
<p>在Looper.loop()中，当发现有消息时，调用消息的目标handler，执行dispatchMessage()方法来分发消息。</p>
<pre><code>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        //当Message存在回调方法，回调msg.callback.run()方法；
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            //当Handler存在Callback成员变量时，回调方法handleMessage()；
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        //Handler自身的回调方法handleMessage()
        handleMessage(msg);
    }
}
</code></pre><p>分发消息流程：</p>
<pre><code>当Message的回调方法不为空时，则回调方法msg.callback.run()，其中callBack数据类型为Runnable,否则进入步骤2；
当Handler的mCallback成员变量不为空时，则回调方法mCallback.handleMessage(msg),否则进入步骤3；
调用Handler自身的回调方法handleMessage()，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。
</code></pre><p>对于很多情况下，消息分发后的处理方法是第3种情况，即Handler.handleMessage()，一般地往往通过覆写该方法从而实现自己的业务逻辑。</p>
<p>##3.3 消息发送</p>
<p>发送消息调用链：<br><img src="/img/java_sendmessage.png" alt=""></p>
<p>从上图，可以发现所有的发消息方式，最终都是调用MessageQueue.enqueueMessage();</p>
<ul>
<li><p>3.3.1 sendEmptyMessage</p>
<pre><code>public final boolean sendEmptyMessage(int what)
{
    return sendEmptyMessageDelayed(what, 0);
}
</code></pre></li>
<li><p>3.3.2 sendEmptyMessageDelayed</p>
<pre><code>public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
    Message msg = Message.obtain();
    msg.what = what;
    return sendMessageDelayed(msg, delayMillis);
}
</code></pre></li>
<li><p>3.3.3 sendMessageDelayed</p>
<pre><code>public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis &lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
</code></pre></li>
<li><p>3.3.4 sendMessageAtTime</p>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre></li>
<li><p>3.3.5 sendMessageAtFrontOfQueue</p>
<pre><code>public final boolean sendMessageAtFrontOfQueue(Message msg) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        return false;
    }
    return enqueueMessage(queue, msg, 0);
}
</code></pre></li>
</ul>
<p>该方法通过设置消息的触发时间为0，从而使Message加入到消息队列的队头。</p>
<ul>
<li><p>3.3.6 post</p>
<pre><code>public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}

private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
</code></pre></li>
<li><p>3.3.7 postAtFrontOfQueue</p>
<pre><code>public final boolean postAtFrontOfQueue(Runnable r)
{
    return sendMessageAtFrontOfQueue(getPostMessage(r));
}
</code></pre></li>
<li><p>3.3.8 enqueueMessage</p>
<pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis); 【见4.3】
}
</code></pre></li>
<li><p>3.3.8 小节</p>
</li>
</ul>
<p>Handler.sendEmptyMessage()等系列方法最终调用MessageQueue.enqueueMessage(msg, uptimeMillis)，将消息添加到消息队列中，其中uptimeMillis为系统当前的运行时间，不包括休眠时间。</p>
<p>##3.4 其他方法</p>
<ul>
<li>3.4.1 obtainMessage</li>
</ul>
<p>获取消息</p>
<pre><code>public final Message obtainMessage()
{
    return Message.obtain(this); 【见5.2】
}
</code></pre><p>Handler.obtainMessage()方法，最终调用Message.obtainMessage(this)，其中this为当前的Handler对象。</p>
<ul>
<li><p>3.4.2 removeMessages</p>
<pre><code>public final void removeMessages(int what) {
    mQueue.removeMessages(this, what, null); 【见 4.5】
}
</code></pre></li>
</ul>
<p>Handler是消息机制中非常重要的辅助类，更多的实现都是MessageQueue, Message中的方法，Handler的目的是为了更加方便的使用消息机制。</p>
<h1 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h1><p>MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，其中MessageQueue类中涉及的native方法如下：</p>
<pre><code>private native static long nativeInit();
private native static void nativeDestroy(long ptr);
private native void nativePollOnce(long ptr, int timeoutMillis);
private native static void nativeWake(long ptr);
private native static boolean nativeIsPolling(long ptr);
private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);
</code></pre><p>关于这些native方法的介绍，可以查阅相关资料</p>
<p>##4.1 创建MessageQueue</p>
<pre><code>MessageQueue(boolean quitAllowed) {
    mQuitAllowed = quitAllowed;
    //通过native方法初始化消息队列，其中mPtr是供native代码使用
    mPtr = nativeInit();
}
</code></pre><p>##4.2 next()</p>
<p>提取下一条message</p>
<pre><code>Message next() {
    final long ptr = mPtr;
    if (ptr == 0) { //当消息循环已经退出，则直接返回
        return null;
    }
    int pendingIdleHandlerCount = -1; // 循环迭代的首次为-1
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        //阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回
        nativePollOnce(ptr, nextPollTimeoutMillis);
        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                //当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，则退出循环。
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    //当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // 获取一条消息，并返回
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    //设置消息的使用状态，即flags |= FLAG_IN_USE
                    msg.markInUse();
                    return msg;   //成功地获取MessageQueue中的下一条即将要执行的消息
                }
            } else {
                //没有消息
                nextPollTimeoutMillis = -1;
            }
            //消息正在退出，返回null
            if (mQuitting) {
                dispose();
                return null;
            }
            //当消息队列为空，或者是消息队列的第一个消息时
            if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                //没有idle handlers 需要运行，则循环并等待。
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        //只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; //去掉handler的引用
            boolean keep = false;
            try {
                keep = idler.queueIdle();  //idle时执行的方法
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        //重置idle handler个数为0，以保证不会再次重复运行
        pendingIdleHandlerCount = 0;
        //当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre><p>nativePollOnce是阻塞操作，其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</p>
<p>当处于空闲时，往往会执行IdleHandler中的方法。当nativePollOnce()返回后，next()从mMessages中提取一个消息。</p>
<p>nativePollOnce()在native做了大量的工作，想进一步了解可查看 Android消息机制2-Handler(native篇)。</p>
<p>##4.3 enqueueMessage</p>
<p>添加一条消息到消息队列</p>
<pre><code>boolean enqueueMessage(Message msg, long when) {
    // 每一个Message必须有一个target
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
    }
    synchronized (this) {
        if (mQuitting) {  //正在退出时，回收msg，加入到消息池
            msg.recycle();
            return false;
        }
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
            //p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked; //当阻塞时需要唤醒
        } else {
            //将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非
            //消息队头存在barrier，并且同时Message是队列中最早的异步消息。
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p;
            prev.next = msg;
        }
        //消息没有退出，我们认为此时mPtr != 0
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
</code></pre><p>MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<p>##4.4 removeMessages</p>
<pre><code>void removeMessages(Handler h, int what, Object object) {
    if (h == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        //从消息队列的头部开始，移除所有符合条件的消息
        while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what
               &amp;&amp; (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycleUnchecked();
            p = n;
        }
        //移除剩余的符合要求的消息
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h &amp;&amp; n.what == what
                    &amp;&amp; (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycleUnchecked();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}
</code></pre><p>这个移除消息的方法，采用了两个while循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p>
<h1 id="五、-Message"><a href="#五、-Message" class="headerlink" title="五、 Message"></a>五、 Message</h1><h2 id="5-1-创建消息"><a href="#5-1-创建消息" class="headerlink" title="5.1 创建消息"></a>5.1 创建消息</h2><p>每个消息用Message表示，Message主要包含以下内容：<br>        数据类型     成员变量     解释<br>        int     what     消息类别<br>        long     when     消息触发时间<br>        int     arg1     参数1<br>        int     arg2     参数2<br>        Object     obj     消息内容<br>        Handler     target     消息响应方<br>        Runnable     callback     回调方法</p>
<p>创建消息的过程，就是填充消息的上述内容的一项或多项。</p>
<p>##5.2 消息池</p>
<p>在代码中，可能经常看到recycle()方法，咋一看，可能是在做虚拟机的gc()相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p>
<p>静态变量sPool的数据类型为Message，通过next成员变量，维护一个消息池；静态变量MAX_POOL_SIZE代表消息池的可用大小；消息池的默认大小为50。</p>
<p>消息池常用的操作方法是obtain()和recycle()。</p>
<ul>
<li>5.2.1 obtain</li>
</ul>
<p>从消息池中获取消息</p>
<pre><code>public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null; //从sPool中取出一个Message对象，并消息链表断开
            m.flags = 0; // 清除in-use flag
            sPoolSize--; //消息池的可用大小进行减1操作
            return m;
        }
    }
    return new Message(); // 当消息池为空时，直接创建Message对象
}
</code></pre><p>obtain()，从消息池取Message，都是把消息池表头的Message取走，再把表头指向next;</p>
<ul>
<li>5.2.2 recycle</li>
</ul>
<p>把不再使用的消息加入消息池</p>
<pre><code>public void recycle() {
    if (isInUse()) { //判断消息是否正在使用
        if (gCheckRecycle) { //Android 5.0以后的版本默认为true,之前的版本默认为false.
            throw new IllegalStateException(&quot;This message cannot be recycled because it is still in use.&quot;);
        }
        return;
    }
    recycleUnchecked();
}
</code></pre><p>//对于不再使用的消息，加入到消息池</p>
<pre><code>void recycleUnchecked() {
    //将消息标示位置为IN_USE，并清空消息所有的参数。
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = -1;
    when = 0;
    target = null;
    callback = null;
    data = null;
    synchronized (sPoolSync) {
        if (sPoolSize &lt; MAX_POOL_SIZE) { //当消息池没有满时，将Message对象加入消息池
            next = sPool;
            sPool = this;
            sPoolSize++; //消息池的可用大小进行加1操作
        }
    }
}
</code></pre><p>recycle()，将Message加入到消息池的过程，都是把Message加到链表的表头；</p>
<p>#六、总结</p>
<p>最后用一张图，来表示整个消息机制</p>
<p>图解：<br><img src="/img/handler_java.jpg" alt=""> </p>
<pre><code>Handler通过sendMessage()发送Message到MessageQueue队列；
Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；
经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。
将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。
</code></pre><p>消息分发的优先级：</p>
<pre><code>Message的回调方法：message.callback.run()，优先级最高；
Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于1；
Handler的默认方法：Handler.handleMessage(msg)，优先级最低。
</code></pre>]]></content>
    
    <summary type="html">
    
      这是一篇很好的Android的线程间通信的文章
    
    </summary>
    
      <category term="Android的线程间通信" scheme="http://yoursite.com/categories/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="Android的线程间通信" scheme="http://yoursite.com/tags/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android下的性能优化</title>
    <link href="http://yoursite.com/2016/05/31/android%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/05/31/android下的性能优化全解析/</id>
    <published>2016-05-31T13:16:33.000Z</published>
    <updated>2016-12-19T13:24:52.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下的性能优化"><a href="#Android下的性能优化" class="headerlink" title="Android下的性能优化"></a>Android下的性能优化</h1><h4 id="android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM-而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR-由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。"><a href="#android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM-而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR-由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。" class="headerlink" title="android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM,而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR,由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。"></a>android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM,而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR,由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。</h4><blockquote>
<p>1.布局优化</p>
</blockquote>
<ul>
<li>删除无用的控件和层级。可以使用HierarchyViewer来查看布局层级。</li>
<li>在布局层级相同的情况下，使用LinearLayout的效率比使用RelativeLayout的性能要高，因为RelativeLayout的性能要高，因为RelativeLayout的功能比较复杂，它的CPU渲染时间比较长，而LinearLayout和FragmentLayout都是简单高效的ViewGroup。</li>
<li>include标签配合merge标签使用来重用布局、减少布局层数。</li>
<li>使用ViewStub。它是一个非常轻量级的View，宽高都是0，因此它本身不参与任何布局和绘制的过程，它的意义在于按需加载所需要的布局，使用的时候再加载，不需要的时候不加载进来，提高程序初始化的性能，注意：ViewStub与设置visibility之间的差异；设置visibility只是可见，就算设置inVisible或者GONE，布局还是会加载的。</li>
</ul>
<blockquote>
<p>2.绘制优化</p>
</blockquote>
<ul>
<li>onDraw方法里不要做初始化对象的操作，因为onDraw方法会被频繁的调用。</li>
<li>onDraw方法不要做耗时的操作，这样会造成View的绘制过程不流畅。</li>
</ul>
<blockquote>
<p>3.内存泄漏优化</p>
</blockquote>
<ul>
<li>资源未关闭。使用了broadCastReceiver，ContentObserver,file,Cursor,Stream,Bitmap等资源的使用，应该在Avtivity销毁时及时的关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</li>
<li>静态成员变量持有类的引用。</li>
<li>非静态内部类持有外部类的引用，使用非静态内部类创建的静态变量。</li>
<li>单例引起的内存泄漏。</li>
<li>Handler造成的内存泄漏。</li>
<li>线程的生命周期不可控。</li>
<li>无限循环的属性动画引起的内存泄漏。</li>
</ul>
<blockquote>
<p>4.响应速度和ANR日志分析</p>
</blockquote>
<ul>
<li>响应速度优化的核心思想就是避免在主线程中做耗时操作，但是有的时候确实有很多耗时的操作，那就必须将这些耗时的操作放在线程中去执行，即采用异步的方式执行耗时的操作。</li>
<li>在实际开发中，ANR是很难从代码上发现的，如果在开发的过程中遇到了ANR,那么怎么定位问题呢？其实在一个进程发生ANR后，系统会在/data/anr目录下创建一个文件traces.txt,通过分析这个文件就能定位出ANR的原因。</li>
</ul>
<blockquote>
<p>5.Bitmap优化</p>
</blockquote>
<ul>
<li>目前比较常用的缓存策略是LruChache和DiskLruCache,其中LruCache常被用做内存缓存，而DiskLruCache常用做存储缓存。Lru是least Tecently Used的缩写，即最近最少使用算法，这种算法的核心思想为：当缓存快满的时候，会淘汰近期最少使用的缓存目标。</li>
<li>高效加载Bitmap的核心思想，其实很简单，那就是采用BitmapFactory.Options来加载所需的图片尺寸。主要用到了它的inSampleSize参数即采样率。</li>
</ul>
<blockquote>
<p>6.ListView优化</p>
</blockquote>
<ul>
<li>在adapter的getVIew（）方法里尽量少使用逻辑；</li>
<li>滑动的时候不要加载图片；</li>
<li>图片的加载使用异步方式；</li>
<li>将listView的scrollingCache和animateCache设置为false. scrollingCache本质上是drawing cache，你可以让一个View将他自己的drawing保存在cache中（保存为一个bitmap），这样下次再显示View的时候就不用重画了，而是从cache中取出。默认情况下drawing cahce是禁用的，因为它太耗内存了，但是它确实比重画来的更加平滑。而在ListView中，scrollingCache是默认开启的，我们可以手动将它关闭。ListView默认开启了animateCache，这会消耗大量的内存，因此会频繁调用GC，我们可以手动将它关闭掉。</li>
<li>listview 被多层嵌套，多次的onMessure导致卡顿，如果多层嵌套无法避免，建议把listview的高和宽设置为fill_parent. 如果是代码继承的listview，那么也请你别忘记为你的继承类添加上LayoutPrams，注意高和宽都是fill_parent的;  以往我一般都是将listview的高度设置成fill_parent，而这次我是设为wrap_content，这样做的问题在于，ListView没有取到实际的高度，他还要根据计算才能确定，而每一次计算应该会触发listview的渲染，所以就会出现getview的调用次数跟正常情况相比多了好几倍。所以在一般情况下，我建议把listiview在布局文件中的高度总是设置为：fill_parent（或者match_parent），这不仅仅是getview的调用次数问题，还涉及到布局的效率。</li>
<li>使用静态的viewHolder。</li>
</ul>
<blockquote>
<p>7.线程优化</p>
</blockquote>
<ul>
<li>线程优化的思想是采用线程池，避免程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了线程的创建和销毁带来的性能开销，同时线程池还能还能有效地控制线程池的最大并发数，避免大量的线程相互抢占系统资源从而导致阻塞现象的发生。因此在实际的开发中，我们应该尽量的采用线程池，而不是每次都创建一个Thread对象。</li>
</ul>
<blockquote>
<p>8.数据库优化</p>
</blockquote>
<ul>
<li>使用事务。大量的数据的增删如果不使用事务，而是循环调用Insert和Delete的话，会因为每一笔操作都需要打开、写入最后关闭Journal文件（这个文件是临时用来保存数据操作的中间结果）而使得开销非常大。<br>  使用的方法：<br>  db.beginTransaction();<br>  db.setTransactionSuccessful();<br>  db.endTransaction();</li>
<li>使用索引。索引维护这一个表某一列或者某几列的顺序，这样就可以快速的定位到某一组值，而不是扫描全表。所有的索引信息会被保存到一个独立的索引表中，所以会产生额外的空间占用，不过绝对物超所值，特别是你会在数据库中进行大量的读及搜索操作的时候。</li>
<li>sql语句拼接的时候用StringBuffer代替String</li>
<li>在写表的时候调用sqliteOpenHelper&amp;getWritableDatabase()，在读表的时候调用SqliteOpenHelper&amp;getReadableDatabase()</li>
<li>开启子线程进行数据库的读写</li>
</ul>
<blockquote>
<p>9.一些性能优化建议</p>
</blockquote>
<ul>
<li>避免创建过多的对象</li>
<li>不要过多的使用枚举，枚举占用的内存空间要比整形大</li>
<li>常量请使用static final来修饰</li>
<li>使用一些android特有的数据结构，比如SparseArray和Pair等，他们都具有更好的性能</li>
<li>适当的使用软引用和弱引用</li>
<li>采用内存缓存和磁盘缓存</li>
<li>尽量采用静态内部类。这样可以避免潜在的内部类而导致的内存泄漏</li>
<li>尽量使用google推荐的处理方式。比如序列化采用parcelable,而不用Serializable</li>
</ul>
<blockquote>
<p>10.内存优化可能会用到的工具（</p>
</blockquote>
<ul>
<li>HierarchyViewer（检查布局层级）</li>
<li>TraceView（对应用中方法耗时进行统计）</li>
<li>APT(对进程的CPU和内存进行监视和分析)</li>
<li>MAT(对内存泄漏分析的主要工具)</li>
</ul>
<blockquote>
<p>11.提高程序的可维护性</p>
</blockquote>
<ul>
<li>提高代码的可读性</li>
<li>灵活应用面向对象语言的三大特性和六大原则从而达成对修改关闭，对扩展开放的终极目标。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下的性能优化的文章
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android,性能优化" scheme="http://yoursite.com/tags/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MVC,MVP和MVVM开发模式解析</title>
    <link href="http://yoursite.com/2016/03/21/MVC,MVP%E5%92%8CMVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20-%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <id>http://yoursite.com/2016/03/21/MVC,MVP和MVVM开发模式解析 -升级版/</id>
    <published>2016-03-21T07:13:48.000Z</published>
    <updated>2016-12-19T14:00:45.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC应用于Ruby on Rails, Spring Framework, iOS开发和 ASP.NET等。</p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>Controller: 操作Model层获取数据传递给UI</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/1f0f053ee41dd60f.png" alt=""></p>
<h3 id="服务器端的MVC"><a href="#服务器端的MVC" class="headerlink" title="服务器端的MVC"></a>服务器端的MVC</h3><p><img src="http://p1.bpimg.com/567571/32dbc1b0db151baa.png" alt=""></p>
<h3 id="Android中MVC"><a href="#Android中MVC" class="headerlink" title="Android中MVC"></a>Android中MVC</h3><p>Android中并没有清晰的MVC框架，如果把Activity当做Controller,根据我们实际开发经验，里面会有大量的UI操作，所以V和C就傻傻分不清了。</p>
<ul>
<li>Model:Java Bean, NetworkManager, DataBaseHelper</li>
<li>View: xml res</li>
<li>Controller: Activity Fragment</li>
<li>ArrayList-ListView-Adapter(MVC)</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP主要应用于ASP.NET等。<strong>MVP与MVC主要区别是View和Model不再耦合。</strong></p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>Presenter: 操作Model层获取数据传递给UI<br><img src="http://p1.bpimg.com/567571/55fb6e5522f46de2.png" alt=""></li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM主要应用于WPF, Silverlight, Caliburn, nRoute等。</p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>ViewModel: 将View和Model绑定</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/1e2bf8b8c8d87d7c.png" alt=""></p>
<h3 id="Android中MVVM"><a href="#Android中MVVM" class="headerlink" title="Android中MVVM"></a>Android中MVVM</h3><p><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">Data Binding Library</a><br><a href="http://www.jianshu.com/p/b1df61a4df77" target="_blank" rel="external">中文翻译</a></p>
<h2 id="软件架构的核心思想"><a href="#软件架构的核心思想" class="headerlink" title="软件架构的核心思想"></a>软件架构的核心思想</h2><blockquote>
<p>分层分模块</p>
</blockquote>
<p><img src="http://p1.bpimg.com/567571/7297425199586e4e.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android architecture</a></p>
<p><a href="http://www.jianshu.com/p/6a86f7fdc0cb" target="_blank" rel="external">MVC,MVP和MVVM模式如何选择</a></p>
<p><a href="http://www.dotnettricks.com/learn/designpatterns/understanding-mvc-mvp-and-mvvm-design-patterns" target="_blank" rel="external">Understanding MVC, MVP and MVVM Design Patterns</a></p>
<p><a href="http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/" target="_blank" rel="external">教你认清MVC，MVP和MVVM</a></p>
<p><a href="https://github.com/LyndonChin/MasteringAndroidDataBinding" target="_blank" rel="external">Android Data Binding</a></p>
<p><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">Clean Architecture</a></p>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述MVC,MVP和MVVM开发模式解析的文章
    
    </summary>
    
      <category term="软件架构" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Android,软件构架,mvc,mvp,mvvm" scheme="http://yoursite.com/tags/Android-%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%9E%B6-mvc-mvp-mvvm/"/>
    
  </entry>
  
  <entry>
    <title>Android下数据库的解析</title>
    <link href="http://yoursite.com/2016/01/16/Android%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/16/Android下数据库的解析/</id>
    <published>2016-01-16T05:18:53.000Z</published>
    <updated>2016-12-19T13:24:09.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下数据库的解析"><a href="#Android下数据库的解析" class="headerlink" title="Android下数据库的解析"></a>Android下数据库的解析</h1><h2 id="建表的语句："><a href="#建表的语句：" class="headerlink" title="建表的语句："></a>建表的语句：</h2><ul>
<li><p>以下语句就可以在数据库文件里创建一个名为students的表名，他有id， name, age 三个字段。</p>
<pre><code>继承 SqlliteOpenHelper
在构造里写出数据库名，然后在onCreate里写出创建表的语句：
db.execSQL(&quot;create table students(_id interger primary key autoincrement,name varchar(20), age integer(20)&quot;);
</code></pre></li>
</ul>
<h2 id="数据库文件的赠删改查："><a href="#数据库文件的赠删改查：" class="headerlink" title="数据库文件的赠删改查："></a>数据库文件的赠删改查：</h2><ul>
<li><p>以下语句可以实现数据库的增删改查：</p>
<pre><code>Sql语句：
add:
insert into  students(id,name,age) values(1,&apos;huge&apos;,38);

delete：
delete from students where name = &apos;lxr&apos;;

update:
update students set age = 34 where name = &apos;lxr&apos;;

query:
select name age from students where name = &apos;lxr&apos;;
</code></pre></li>
</ul>
<h2 id="数据库的模糊查询"><a href="#数据库的模糊查询" class="headerlink" title="数据库的模糊查询"></a>数据库的模糊查询</h2><ul>
<li>使用like可以实现数据库的模糊查询</li>
<li><pre><code>select name age from students where name LIKE&apos;Mc%&apos;; 
SQL模糊查询，使用like比较字，加上SQL里的通配符，请参考以下：
  　　1、LIKE&apos;Mc%&apos; 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
  　　2、LIKE&apos;%inger&apos; 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
  　　3、LIKE&apos;%en%&apos; 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
  　　4、LIKE&apos;_heryl&apos; 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
  　　5、LIKE&apos;[CK]ars[eo]n&apos; 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
  　　6、LIKE&apos;[M-Z]inger&apos; 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
  　　7、LIKE&apos;M[^c]%&apos; 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。
</code></pre></li>
</ul>
<h2 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h2><ul>
<li><p>使用事务。大量数据增加或删除时如果不使用事务，而是循环调用 INSERT 和 DELETE 的话，会因为每一笔操作都需要打开、写入最后关闭 journal  文件（这个文件是临时用来保存数据操作的中间结果）而使得开销非常大。<br>使用方法：</p>
<ul>
<li>db.beginTransaction()。</li>
<li>开始进行循环添加或者删除操作。    </li>
<li>db.setTransactionSuccessful()。</li>
<li>db.endTransaction()。</li>
</ul>
</li>
<li><p>使用索引。索引维护着一个表中某一列或某几列的顺序，这样就可 以快速定位到一组值，而不用扫遍全表。所有的索引信息会被保存在一个 独立的索引表中，所以会产生额外的空间占用，不过绝对物超所值，特别 是当你会在数据库中进行大量的读及搜索操作时。</p>
<ul>
<li>创建语句：CREATE INDEX name_index ON username(firstname, lastname)</li>
<li><p>索引分类：</p>
<ul>
<li>普通索引和唯一性索引。 </li>
<li>单个索引：索引建立语句中仅包含单个字段。复合索引：在索引建立语句中同时包含多个字段。</li>
<li><p>聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照 顺序排列。非聚簇索引。</p>
</li>
<li><p>使用场景：</p>
<ul>
<li>当某字段数据更新频率较低，查询频率较高，经常有范围 查询(&gt;, &lt;, =, &gt;=, &lt;=)或 order by、group by 发生时建议使用索引。</li>
<li>经常同时存取多列，且每列都含有重复值可考虑建立复合索引。</li>
<li>使用注意项（较难）：<ul>
<li>对于复合索引，把使用最频繁的列做为前导列 (索引中第一个字段)。<ul>
<li>避免对索引列进行计算，对 where 子句列的任何计算如果不能被编译 优化，都会导致查询时索引失效。</li>
</ul>
</li>
<li>比较值避免使用 NULL。 </li>
<li>多表查询时要注意是选择合适的表做为内表。内外表的选择可由公式： 外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳 方案。</li>
<li>把过滤记录数最多的条件放在最前面。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>sql 语句拼接时可以使用 StringBuffer 代替 String。 </p>
</li>
<li>在写表时调用 sqliteOpenHelper..getWritableDatabase()，<br>在读表时候调用 sqliteOpenHelper..getReadableDatabase()，getReadableDatabase 性能更优。</li>
<li>开启子线程进行数据库读写。</li>
</ul>
<h2 id="版本迭代中数据库的更新问题"><a href="#版本迭代中数据库的更新问题" class="headerlink" title="版本迭代中数据库的更新问题"></a>版本迭代中数据库的更新问题</h2><ul>
<li><p>应用程序如何知道数据库需要升级：SQLiteOpenHelper类的构造函数有 一个参数是int version，它的意思就是指数据库版本号。比如在应用1.0版本 中，我们使用SQLiteOpenHelper访问数据库时，该参数为1，那么数据库版本号 1就会写在我们的数据库中。到了1.1版本，我们的数据库需要发生变化，那么 我们1.1版本的程序中就要使用一个大于1的整数来构造SQLiteOpenHelper类， 用于访问新的数据库，比如2。当我们的1.1新程序读取1.0版本的老数据库时， 就发现老数据库里存储的数据库版本是1，而我们新程序访问它时填的版本号为 2，系统就知道数据库需要升级。<br>何时触发数据库升级：当系统在构造 SQLiteOpenHelper 类的对象时，如果 发现版本号不一样，就会自动调用   onUpgrade    函数，让你在这里对数据库进行升级。</p>
</li>
<li><p>升级时应该考虑的问题：数据库中的原数据不能丢失。</p>
<ul>
<li>如何升级：在 onUpgrade 方法中执行相应的更新数据库的 sql 语句就行了。下 面列举一些常见的更新的sql 语句。<ul>
<li>增加新表：CREATE TABLE table_name(_id integer primary key autoincrement, region varchar, code varchar)。 增加或者删除列：SQLite数库对ALTER TABLE命令支持非常有限，只能在表末尾 添加列，不能修改列定义，不能删除已有的列。那么如果要修改表呢？我们可 以采用临时表的办法。具体来说有四步：<ul>
<li>将表明改为临时表：ALTER TABLE table_name RENAME TO table_name_temp </li>
<li>创建新表。</li>
<li>将临时表的数据导入新表（不能出现values关键字）：insert into table_name (_id, region, code, country) select _id, region, code, \”CHINA\” from table_name_temp</li>
<li>删除临时表：DROP TABLE table_name _temp</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跨版本的数据库升级问题：应用程序发布了多个版本，以致出现了三个及 以上数据库版本。如何确保所有的用户升级应用后数据库都能用呢？</p>
<ul>
<li><p>方法一：确定相邻版本的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3这样依次下去。 优点：每次更新数据库的时候只需要在onUpgrade方法的末尾加一段从上个版 本升级到新版本的代码，易于理解和维护。 缺点：是当版本变多之后，多次迭代升级可能需要花费不少时间，增加用户等 待时间；</p>
</li>
<li><p>方式二：为每个版本确定与现在数据库的差别，为每个case撰写专门的升级代码。 优点：则是可以保证每个版本的用户都可以在消耗最少的时间升级到最新的数据库而无需做无用的数据多次转存。缺点：是强迫开发者记忆所有版本数据库的完整结构，且每次升级时 onUpgrade方法都必须全部重写。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下数据库的解析的文章
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Android,数据库" scheme="http://yoursite.com/tags/Android-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>静态代理和动态代理解析</title>
    <link href="http://yoursite.com/2015/09/11/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/09/11/静态代理和动态代理解析/</id>
    <published>2015-09-11T14:13:34.000Z</published>
    <updated>2016-12-19T13:35:18.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>1.相关概念</p>
</blockquote>
<ul>
<li>1.1 代理</li>
</ul>
<p>在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。<br>这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。<br>代理优点有：</p>
<pre><code>隐藏委托类的实现
解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作
</code></pre><p>根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。</p>
<ul>
<li>1.2 静态代理</li>
</ul>
<p>代理类在程序运行前已经存在的代理方式称为静态代理。<br>通过上面解释可以知道，由开发人员编写或是编译器生成代理类的方式都属于静态代理，如下是简单的静态代理实例：</p>
<pre><code>class ClassA {
    public void operateMethod1() {};

    public void operateMethod2() {};

    public void operateMethod3() {};
}

public class ClassB {
    private ClassA a;

    public ClassB(ClassA a) {
        this.a = a;
    }

    public void operateMethod1() {
        a.operateMethod1();
    };

    public void operateMethod2() {
        a.operateMethod2();
    };

    // not export operateMethod3()
}
</code></pre><p>上面ClassA是委托类，ClassB是代理类，ClassB中的函数都是直接调用ClassA相应函数，并且隐藏了Class的operateMethod3()函数。</p>
<p>静态代理中代理类和委托类也常常继承同一父类或实现同一接口。</p>
<p>*　1.3 动态代理</p>
<ul>
<li><p>代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。</p>
</li>
<li><p>Java 提供了动态代理的实现方式，可以在运行时刻动态生成代理类。这种代理方式的一大好处是可以方便对代理类的函数做统一或特殊处理，如记录所有函数执行时间、所有函数执行前添加验证判断、对某个特殊函数进行特殊操作，而不用像静态代理方式那样需要修改每个函数。</p>
</li>
<li><p>A:动态代理概述</p>
<ul>
<li>代理：本来应该自己做的事情，请了别人来做，被请的人就是代理对象。</li>
<li>举例：春节回家买票让人代买</li>
<li>动态代理：在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理</li>
<li>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象<blockquote>
<p>动态代理实例</p>
</blockquote>
</li>
</ul>
</li>
<li><p>实现动态代理包括三步：</p>
<ul>
<li>新建委托类；</li>
<li>实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；</li>
<li>通过Proxy类新建代理类对象。</li>
<li>proxy中的方法</li>
<li>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</li>
<li>最终会调用InvocationHandler的方法</li>
<li>InvocationHandler接口 </li>
<li>public Object invoke(Object proxy,Method method,Object[] args)；</li>
</ul>
</li>
<li><pre><code>//step1: 定义User接口

public interface User {
    public void add();

    public void delete();
}

//step2: 定义类实现User接口

public class UserImp implements User {
    @Override
    public void add() {
        //System.out.println(&quot;权限校验&quot;);
        System.out.println(&quot;添加功能&quot;);
        //System.out.println(&quot;日志记录&quot;);
    }

    @Override
    public void delete() {
        //System.out.println(&quot;权限校验&quot;);
        System.out.println(&quot;删除功能&quot;);
        //System.out.println(&quot;日志记录&quot;);
    }

}

//step3: InvocationHandler的实现类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyInvocationHandler implements InvocationHandler {

    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {
        System.out.println(&quot;权限校验&quot;);
        method.invoke(target, args);                    //执行被代理target对象的方法
        System.out.println(&quot;日志记录&quot;);
        return null;
    }

}

//定义测试类
import java.lang.reflect.Proxy;
public class Test {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*UserImp ui = new UserImp();
        ui.add();  //添加功能
        ui.delete(); //删除功能

        System.out.println(&quot;-------------------------------&quot;);*/
        /*
         * public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,
         * InvocationHandler h)
         */
        /*
        MyInvocationHandler m = new MyInvocationHandler(ui);
        User u = (User)Proxy.newProxyInstance(ui.getClass().getClassLoader(), ui.getClass().getInterfaces(), m);
        u.add();   //权限校验    添加功能    日志记录
        u.delete(); //权限校验 删除功能  日志记录
        */

        StudentImp si = new StudentImp();
        si.login();//登录
        si.submit();//提交

        System.out.println(&quot;-------------------------------&quot;);
        MyInvocationHandler m = new MyInvocationHandler(si);
        Student s = (Student)Proxy.newProxyInstance(si.getClass().getClassLoader(), si.getClass().getInterfaces(), m);

        s.login();  //权限校验    登录    日志记录
        s.submit(); //权限校验 提交  日志记录
    }

}

//类似step1: 定义Student接口
public interface Student {
    public void login();

    public void submit();
}

//类似step2: 定义类实现Student接口
public class StudentImp implements Student {
    @Override
    public void login() {
        System.out.println(&quot;登录&quot;);
    }

    @Override
    public void submit() {
        System.out.println(&quot;提交&quot;);
    }

}
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述静态代理和动态代理解析的文章
    
    </summary>
    
      <category term="代理" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="Android,静态代理,动态代理" scheme="http://yoursite.com/tags/Android-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入的解析</title>
    <link href="http://yoursite.com/2015/06/07/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/06/07/依赖注入的解析/</id>
    <published>2015-06-07T12:18:43.000Z</published>
    <updated>2016-12-19T13:36:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="依赖注入的解析"><a href="#依赖注入的解析" class="headerlink" title="依赖注入的解析"></a>依赖注入的解析</h1><blockquote>
<ol>
<li>依赖</li>
</ol>
</blockquote>
<p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human() {
        father = new Father();
    }
}
</code></pre><p>仔细看这段代码我们会发现存在一些问题：</p>
<ul>
<li>如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码；</li>
<li>如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；</li>
<li>如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。</li>
</ul>
<blockquote>
<p>2.依赖注入</p>
</blockquote>
<p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human(Father father) {
        this.father = father;
    }
}
</code></pre><p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。<br>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：</p>
<ul>
<li>解耦，将依赖之间解耦。</li>
<li>因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</li>
</ul>
<blockquote>
<p>3.Java 中的依赖注入</p>
</blockquote>
<p>依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。</p>
<pre><code>public class Human {
    ...
    @Inject Father father;
    ...
    public Human() {
    }
}
</code></pre><p>上面这段代码看起来很神奇：只是增加了一个注解，Father 对象就能自动注入了？这个注入过程是怎么完成的？实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。现在 Java 语言中较流行的依赖注入框架有 Google Guice、Spring 等，而在 Android 上比较流行的有 RoboGuice、Dagger 等。</p>
<blockquote>
<p>另外：mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。比如通过Butter Knife、Dagger依赖注入库实现，都是使用注解来实现依赖注入，但它利用 APT(Annotation Process Tool) 在编译时生成辅助类，这些类继承特定父类或实现特定接口，程序在运行时加载这些辅助类，调用相应接口完成依赖生成和注入。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android依赖注入的文章
    
    </summary>
    
      <category term="依赖注入" scheme="http://yoursite.com/categories/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="Android,依赖注入" scheme="http://yoursite.com/tags/Android-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>注解Annotation解析</title>
    <link href="http://yoursite.com/2015/05/01/%E6%B3%A8%E8%A7%A3Annotation%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/05/01/注解Annotation解析/</id>
    <published>2015-05-01T13:10:33.000Z</published>
    <updated>2016-12-19T13:41:13.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解Annotation解析"><a href="#注解Annotation解析" class="headerlink" title="注解Annotation解析"></a>注解Annotation解析</h1><p>不少开源库都用到了注解的方式来简化代码提高开发效率。本文简单介绍下 Annotation 示例、概念及作用、分类、自定义、解析，并对几个 Android 开源库 Annotation 原理进行简析。</p>
<blockquote>
<ol>
<li>Annotation 示例</li>
</ol>
</blockquote>
<pre><code>Override Annotation

@Override //重写的注解
public void onCreate(Bundle savedInstanceState);

Retrofit Annotation

@GET(&quot;/users/{username}&quot;)
User getUser(@Path(&quot;username&quot;) String username);

Butter Knife Annotation

@InjectView(R.id.user) EditText username;

ActiveAndroid Annotation

@Column(name = “Name&quot;) public String name;

Retrofit 为符合 RESTful 规范的网络请求框架
Butter Knife 为 View 及事件等依赖注入框架
Active Android 为 ORM 框架
</code></pre><blockquote>
<p>2.Annotation 概念及作用</p>
</blockquote>
<ul>
<li><p>2.1 概念</p>
<p>  An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate.</p>
</li>
</ul>
<p>能够添加到 Java 源代码的语法元数据。类、方法、变量、参数、包都可以被注解，可用来将信息元数据与程序元素进行关联。Annotation 中文常译为“注解”。</p>
<ul>
<li>2.2 作用</li>
</ul>
<p>a. 标记，用于告诉编译器一些信息<br>b. 编译时动态处理，如动态生成代码<br>c. 运行时动态处理，如得到注解信息<br>这里的三个作用实际对应着后面自定义 Annotation 时说的 @Retention 三种值分别表示的 Annotation</p>
<pre><code>public class Person {

    private int    id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public boolean equals(Person person) {
        return person.id == id;
    }

    public int hashCode() {
        return id;
    }

    public static void main(String[] args) {

        Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();
        for (int i = 0; i &lt; 10; i++) {
            set.add(new Person(i, &quot;Jim&quot;));
        }
        System.out.println(set.size());
    }
}
</code></pre><p>上面的运行结果是多少？</p>
<blockquote>
<p>3.Annotation 分类</p>
</blockquote>
<ul>
<li>3.1 标准 Annotation，Override, Deprecated, SuppressWarnings</li>
</ul>
<p>标准 Annotation 是指 Java 自带的几个 Annotation，上面三个分别表示重写函数，不鼓励使用(有更好方式、使用有风险或已不在维护)，忽略某项 Warning</p>
<ul>
<li>3.2 元 Annotation，@Retention, @Target, @Inherited, @Documented</li>
</ul>
<p>元 Annotation 是指用来定义 Annotation 的 Annotation，在后面 Annotation 自定义部分会详细介绍含义</p>
<ul>
<li>3.3 自定义 Annotation</li>
</ul>
<p>自定义 Annotation 表示自己根据需要定义的 Annotation，定义时需要用到上面的元 Annotation<br>这里是一种分类而已，也可以根据作用域分为源码时、编译时、运行时 Annotation，后面在自定义 Annotation 时会具体介绍</p>
<blockquote>
<p>4.Annotation 自定义</p>
</blockquote>
<ul>
<li><p>4.1 调用</p>
<pre><code>public class App {
    @MethodInfo(
        author = “trinea.cn+android@gmail.com”,
        date = &quot;2014/02/14&quot;,
        version = 2)
    public String getAppName() {
        return &quot;trinea&quot;;
    }
}
</code></pre></li>
</ul>
<p>这里是调用自定义 Annotation——MethodInfo 的示例。<br>MethodInfo Annotation 作用为给方法添加相关信息，包括 author、date、version。</p>
<ul>
<li><p>4.2 定义</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Inherited
public @interface MethodInfo {

    String author() default &quot;trinea@gmail.com&quot;;

    String date();

    int version() default 1;
}

这里是 MethodInfo 的实现部分
(1). 通过 @interface 定义，注解名即为自定义注解名
(2). 注解配置参数名为注解类的方法名，且：
a. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public，不允许抛异常
b. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组
c. 若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation
(3). 可以加 default 表示默认值
</code></pre></li>
<li><p>4.3 元 Annotation</p>
<pre><code>@Documented 是否会保存到 Javadoc 文档中
@Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings
@Target 可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有
@Inherited 是否可以被继承，默认为 false
</code></pre></li>
</ul>
<blockquote>
<p>5.Annotation 解析</p>
</blockquote>
<ul>
<li><p>5.1 运行时 Annotation 解析</p>
<pre><code>(1) 运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析

method.getAnnotation(AnnotationName.class);
method.getAnnotations();
method.isAnnotationPresent(AnnotationName.class);

其他 @Target 如 Field，Class 方法类似
getAnnotation(AnnotationName.class) 表示得到该 Target 某个 Annotation 的信息，因为一个 Target 可以被多个 Annotation 修饰
getAnnotations() 则表示得到该 Target 所有 Annotation
isAnnotationPresent(AnnotationName.class) 表示该 Target 是否被某个 Annotation 修饰
(2) 解析示例如下：

public static void main(String[] args) {
    try {
        Class cls = Class.forName(&quot;cn.trinea.java.test.annotation.App&quot;);
        for (Method method : cls.getMethods()) {
            MethodInfo methodInfo = method.getAnnotation(
MethodInfo.class);
            if (methodInfo != null) {
                System.out.println(&quot;method name:&quot; + method.getName());
                System.out.println(&quot;method author:&quot; + methodInfo.author());
                System.out.println(&quot;method version:&quot; + methodInfo.version());
                System.out.println(&quot;method date:&quot; + methodInfo.date());
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}

以之前自定义的 MethodInfo 为例，利用 Target（这里是 Method）getAnnotation 函数得到 Annotation 信息，然后就可以调用 Annotation 的方法得到响应属性值
</code></pre></li>
<li><p>5.2 编译时 Annotation 解析</p>
<pre><code>(1) 编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，甴编译器自动解析。需要做的
a. 自定义类集成自 AbstractProcessor
b. 重写其中的 process 函数
这块很多同学不理解，实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理
(2) 假设 MethodInfo 的 @Retention 为 CLASS，解析示例如下：

@SupportedAnnotationTypes({ &quot;cn.trinea.java.test.annotation.MethodInfo&quot; })
public class MethodInfoProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {
        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        for (TypeElement te : annotations) {
            for (Element element : env.getElementsAnnotatedWith(te)) {
                MethodInfo methodInfo = element.getAnnotation(MethodInfo.class);
                map.put(element.getEnclosingElement().toString(), methodInfo.author());
            }
        }
        return false;
    }
}

SupportedAnnotationTypes 表示这个 Processor 要处理的 Annotation 名字。
process 函数中参数 annotations 表示待处理的 Annotations，参数 env 表示当前或是之前的运行环境
process 函数返回值表示这组 annotations 是否被这个 Processor 接受，如果接受后续子的 rocessor 不会再对这个 Annotations 进行处理
</code></pre></li>
</ul>
<blockquote>
<p>6.几个 Android 开源库 Annotation 原理简析</p>
<ul>
<li>6.1 Annotation — Retrofit<pre><code>(1) 调用
</code></pre></li>
</ul>
</blockquote>
<pre><code>@GET(&quot;/users/{username}&quot;)
User getUser(@Path(&quot;username&quot;) String username);
(2) 定义
@Documented
@Target(METHOD)
@Retention(RUNTIME)
@RestMethod(&quot;GET&quot;)
public @interface GET {
  String value();
}
从定义可看出 Retrofit 的 Get Annotation 是运行时 Annotation，并且只能用于修饰 Method
(3) 原理
private void parseMethodAnnotations() {
    for (Annotation methodAnnotation : method.getAnnotations()) {
    Class&lt;? extends Annotation&gt; annotationType = methodAnnotation.annotationType();
    RestMethod methodInfo = null;

    for (Annotation innerAnnotation : annotationType.getAnnotations()) {
        if (RestMethod.class == innerAnnotation.annotationType()) {
            methodInfo = (RestMethod) innerAnnotation;
            break;
        }
    }
    ……
    }
}   
RestMethodInfo.java 的 parseMethodAnnotations 方法如上，会检查每个方法的每个 Annotation， 看是否被 RestMethod 这个 Annotation 修饰的 Annotation 修饰，这个有点绕，就是是否被 GET、DELETE、POST、PUT、HEAD、PATCH 这些 Annotation 修饰，然后得到 Annotation 信息，在对接口进行动态代理时会掉用到这些 Annotation 信息从而完成调用。

Retrofit 原理涉及到动态代理，这里原理都只介绍 Annotation，具体原理分析请见 Android 开源项目实现原理解析
</code></pre><ul>
<li><p>6.2 Annotation — Butter Knife</p>
<pre><code>(1) 调用

@InjectView(R.id.user) 
EditText username;

(2) 定义

@Retention(CLASS) 
@Target(FIELD)
public @interface InjectView {
  int value();
}

可看出 Butter Knife 的 InjectView Annotation 是编译时 Annotation，并且只能用于修饰属性
(3) 原理

@Override 
public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {
    Map&lt;TypeElement, ViewInjector&gt; targetClassMap = findAndParseTargets(env);

    for (Map.Entry&lt;TypeElement, ViewInjector&gt; entry : targetClassMap.entrySet()) {
        TypeElement typeElement = entry.getKey();
        ViewInjector viewInjector = entry.getValue();

        try {
            JavaFileObject jfo = filer.createSourceFile(viewInjector.getFqcn(), typeElement);
            Writer writer = jfo.openWriter();
            writer.write(viewInjector.brewJava());
            writer.flush();
            writer.close();
        } catch (IOException e) {
            error(typeElement, &quot;Unable to write injector for type %s: %s&quot;, typeElement, e.getMessage());
        }
    }

    return true;
}

ButterKnifeProcessor.java 的 process 方法如上，编译时，在此方法中过滤 InjectView 这个 Annotation 到 targetClassMap 后，会根据 targetClassMap 中元素生成不同的 class 文件到最终的 APK 中，然后在运行时调用 ButterKnife.inject(x) 函数时会到之前编译时生成的类中去找。 这里原理都只介绍 Annotation，具体原理分析请见 Android 开源项目实现原理解析
</code></pre></li>
<li><p>6.3 Annotation — ActiveAndroid</p>
<pre><code>(1) 调用

@Column(name = “Name&quot;) 
public String name;

(2) 定义

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
  ……
}

可看出 ActiveAndroid 的 Column Annotation 是运行时 Annotation，并且只能用于修饰属性。
(3) 原理

Field idField = getIdField(type);
mColumnNames.put(idField, mIdName);

List&lt;Field&gt; fields = new LinkedList&lt;Field&gt;(ReflectionUtils.getDeclaredColumnFields(type));
Collections.reverse(fields);

for (Field field : fields) {
    if (field.isAnnotationPresent(Column.class)) {
        final Column columnAnnotation = field.getAnnotation(Column.class);
        String columnName = columnAnnotation.name();
        if (TextUtils.isEmpty(columnName)) {
            columnName = field.getName();
        }

        mColumnNames.put(field, columnName);
    }
}

TableInfo.java 的构造函数如上，运行时，得到所有行信息并存储起来用来构件表信息。
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android注解Annotation的文章
    
    </summary>
    
      <category term="注解" scheme="http://yoursite.com/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="Android,注解,Annotation" scheme="http://yoursite.com/tags/Android-%E6%B3%A8%E8%A7%A3-Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Android下屏幕适配全解析</title>
    <link href="http://yoursite.com/2014/05/16/android%E4%B8%8B%E7%9A%84%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2014/05/16/android下的屏幕适配全解析/</id>
    <published>2014-05-16T14:19:43.000Z</published>
    <updated>2016-12-19T13:24:09.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下屏幕适配全解析"><a href="#Android下屏幕适配全解析" class="headerlink" title="Android下屏幕适配全解析"></a>Android下屏幕适配全解析</h1><h2 id="屏幕适配分为两部分：图片适配和尺寸适配。"><a href="#屏幕适配分为两部分：图片适配和尺寸适配。" class="headerlink" title="屏幕适配分为两部分：图片适配和尺寸适配。"></a>屏幕适配分为两部分：图片适配和尺寸适配。</h2><h3 id="图片适配："><a href="#图片适配：" class="headerlink" title="图片适配："></a>图片适配：</h3><ul>
<li>目前流行的是切一套最大的图——1920*1080（1080P），在低分辨率的 手机上可以通过设置 imageView 的大小和 scaleType 来将图片压缩。（这 样做的目的是减小 APK 体积）针对那些常用的、比较重要的 icon 会切多套图。</li>
</ul>
<h3 id="尺寸适配："><a href="#尺寸适配：" class="headerlink" title="尺寸适配："></a>尺寸适配：</h3><ul>
<li>较为通俗的方法就是根据不同的手机分辨率在 res 文件夹下创建不同 的 values 文件夹，在每个都有一个 dimens 文件，dimens 文件里就写<br>着所有的尺寸。每种分辨率的手机就到不同的 values 文件夹里面的 dimens 文件去进行尺寸匹配。</li>
<li>使用谷歌官方推出的 percent library 来进行适配。但是谷歌只推出了PercentRelativeLayout、PercentFrameLayout供大家使用，那么其他就可以写自定义VIew来实现了</li>
<li>使用国内hongyang大神写的 AutoLayout 来进行适配。</li>
</ul>
<h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><ul>
<li>屏幕尺寸：屏幕对角线的长度。</li>
<li>屏幕分辨率：横纵向上的像素点数。</li>
<li>dpi:是 dot per inch 的缩写，表示每英寸上的像素点数。与屏幕尺寸和 屏幕分辨率有关。</li>
<li>dip/dp: 是 Density Independent Pixels 的缩写，即密度无关像素</li>
<li>px:像素。</li>
<li>sp: 即 scale-independent pixels，与 dp 类似，但是可以根据文字大小 首选项进行放缩，是设置字体大小的御用单位。 mdpi、hdpi、xdpi、xxdpi：用来修饰 Android 中的 drawable 文件 夹及 values 文件夹，用来区分不同像素密度下的图片和 dimen 值。</li>
<li>mdpi:480*320,</li>
<li>hdpi:800<em>480,854</em>480,960*540</li>
<li>xhdpi:1280*720</li>
<li>xxhdpi:1920*1080</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下屏幕适配全解析的文章
    
    </summary>
    
      <category term="屏幕适配" scheme="http://yoursite.com/categories/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android,屏幕适配" scheme="http://yoursite.com/tags/Android-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
</feed>
