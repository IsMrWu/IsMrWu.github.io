<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Wu&#39;s Blog</title>
  <subtitle>The closer you think you are,the less you will actually see.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-03T12:03:29.605Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Andorid下的webview缓存全解析</title>
    <link href="http://yoursite.com/2017/06/03/Android%E4%B8%8BwebView%E7%BC%93%E5%AD%98%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/06/03/Android下webView缓存全解析/</id>
    <published>2017-06-03T09:11:53.000Z</published>
    <updated>2017-06-03T12:03:29.605Z</updated>
    
    <content type="html"><![CDATA[<p>#Android下webview缓存详解</p>
<h2 id="HTML5缓存介绍"><a href="#HTML5缓存介绍" class="headerlink" title="HTML5缓存介绍"></a>HTML5缓存介绍</h2><ul>
<li>HTML 5 Web 存储<ul>
<li>在客户端存储数据（DOM Storage 分为 sessionStorage 和 localStorage。HTML5 中引入了 DOM Storage 机制用于存储键值对，它的设计目的是提供大规模、易用的存储功能， 并且程序员可以通过调用标准的接口，简单地访问存储的数据。目前，许多新版本的浏览器都支持 DOM Storage 功能。 当老版本的浏览器不支持 HTML5 提供的 DOM Storage 机制时，可以考虑用 Dojo 来实现相同的功能。）</li>
<li>HTML5 提供了两种在客户端存储数据的新方法：<ul>
<li>localStorage - 没有时间限制的数据存储</li>
<li>sessionStorage - 针对一个 session 的数据存储<ul>
<li>之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。HTML5 使用 JavaScript 来存储和访问数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HTML 5 应用程序缓存<ul>
<li>什么是应用程序缓存（Application Cache）？<ul>
<li>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。</li>
</ul>
</li>
<li>应用程序缓存为应用带来三个优势：<ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
<li>浏览器支持<ul>
<li>所有主流浏览器均支持应用程序缓存，除了 Internet Explorer。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Android中WebView的缓存可以分为页面缓存和数据缓存-以下分别对两者进行阐述"><a href="#Android中WebView的缓存可以分为页面缓存和数据缓存-以下分别对两者进行阐述" class="headerlink" title="Android中WebView的缓存可以分为页面缓存和数据缓存,以下分别对两者进行阐述:"></a>Android中WebView的缓存可以分为页面缓存和数据缓存,以下分别对两者进行阐述:</h2><ul>
<li>页面缓存是指加载一个网页时的html、JS、CSS等页面或者资源数据。这些缓存资源是由于浏览器的行为而产生，开发者只能通过配置HTTP响应头影响浏览器的行为才能间接地影响到这些缓存数据。他们的索引存放在/data/data/package_name/databases下。他们的文件存放在/data/data/package_name/cache/xxxwebviewcachexxx下。文件夹的名字在2.x和4.x上有所不同，但都文件夹名字中都包含webviewcache。<ul>
<li>1、缓存构成<ul>
<li>/data/data/package_name/cache/</li>
<li>/data/data/package_name/database/webview.db</li>
<li>/data/data/package_name/database/webviewCache.db</li>
</ul>
</li>
<li>2、缓存模式(5种)<ul>
<li>LOAD_CACHE_ONLY:  不使用网络，只读取本地缓存数据</li>
<li>LOAD_DEFAULT:  根据cache-control决定是否从网络上取数据。</li>
<li>LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式</li>
<li>LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</li>
<li>LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。<ul>
<li>如：www.taobao.com的cache-control为no-cache，在模式LOAD_DEFAULT下，无论如何都会从网络上取数据，如果没有网络，就会出现错误页面；在LOAD_CACHE_ELSE_NETWORK模式下，无论是否有网络，只要本地有缓存，都使用缓存。本地没有缓存时才从网络上获取。www.360.com.cn的cache-control为max-age=60，在两种模式下都使用本地缓存数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>数据缓存分为两种：AppCache和DOM Storage（Web Storage）。他们是因为页面开发者的直接行为而产生。所有的缓存数据都由开发者直接完全地掌控。<ul>
<li>AppCache使我们能够有选择的缓冲web浏览器中所有的东西，从页面、图片到脚本、css等等。尤其在涉及到应用于网站的多个页面上的CSS和JavaScript文件的时候非常有用。其大小目前通常是5M。<ul>
<li>在Android上需要手动开启（setAppCacheEnabled），并设置路径（setAppCachePath）和容量（setAppCacheMaxSize）</li>
<li>Android中Webkit使用一个db文件来保存AppCache数据（my_path/ApplicationCache.db）</li>
</ul>
</li>
<li>如果需要存储一些简单的用key/value对即可解决的数据，DOM Storage是非常完美的方案。根据作用范围的不同，有Session Storage和Local Storage两种，分别用于会话级别的存储（页面关闭即消失）和本地化存储（除非主动删除，否则数据永远不会过期）。<ul>
<li>在Android中可以手动开启DOM Storage（setDomStorageEnabled），设置存储路径（setDatabasePath）</li>
<li>Android中Webkit会为DOM Storage产生两个文件（my_path/localstorage/http_h5.m.taobao.com_0.localstorage和my_path/localstorage/Databases.db）</li>
</ul>
</li>
<li>另外，在Android中清除缓存时，如果需要清除Local Storage的话，仅仅删除Local Storage的本地存储文件是不够的，内存里面有缓存数据。如果再次进入页面，Local Storage中的缓存数据同样存在。需要杀死程序运行的当前进程再重新启动才可以。</li>
</ul>
</li>
</ul>
<h2 id="webSetting关于缓存相关的API"><a href="#webSetting关于缓存相关的API" class="headerlink" title="webSetting关于缓存相关的API"></a>webSetting关于缓存相关的API</h2><ul>
<li>setAppCacheEnabled (boolean flag)<ul>
<li>应用缓存API是否可用，默认值false, 结合setAppCachePath(String)使用。</li>
</ul>
</li>
<li>setAppCachePath(String)<ul>
<li>设置应用缓存文件的路径。为了让应用缓存API可用，此方法必须传入一个应用可写的路径。该方法只会执行一次，重复调用会被忽略。</li>
</ul>
</li>
<li>setAppCacheMaxSize (long appCacheMaxSize)<ul>
<li>已废弃。设置应用缓存内容的最大值。所传值会被近似为数据库支持的最近似值，因此这是一个指示值，而不是一个固定值。所传值若小于数据库大小不会让数据库调整大小。默认值是MAX_VALUE，建议将默认值设置为最大值。</li>
</ul>
</li>
<li>setCacheMode (int mode)<ul>
<li>重写使用缓存的方式，默认值LOAD_DEFAULT。缓存的使用方式基于导航类型，正常的页面加载，检测缓存，需要时缓存内容复现。导航返回时，内容不会复现，只有内容会从缓存盘中恢复。该方法允许客户端通过指定LOAD_DEFAULT, LOAD_CACHE_ELSE_NETWORK, LOAD_NO_CACHE or LOAD_CACHE_ONLY的其中一项来重写其行为。</li>
</ul>
</li>
<li>setDatabaseEnabled (boolean flag)<ul>
<li>数据库存储API是否可用，默认值false。如何正确设置数据存储API参见setDatabasePath(String)。该设置对同一进程中的所有WebView实例均有效。注意，只能在当前进程的任意WebView加载页面之前修改此项，因为此节点之后WebView的实现类可能会忽略该项设置的改变。</li>
</ul>
</li>
<li>setDatabasePath (String databasePath)<ul>
<li>已废弃，数据库路径由实现（implementation）管理，调用此方法无效。设置数据库的存储路径，为了保证数据库正确运行，该方法必须使用一个应用可写的路径。此方法只能执行一次，重复调用会被忽略。</li>
</ul>
</li>
<li>setDomStorageEnabled (boolean flag)<ul>
<li>DOM存储API是否可用，默认false。</li>
</ul>
</li>
</ul>
<h2 id="webSetting相关API总结："><a href="#webSetting相关API总结：" class="headerlink" title="webSetting相关API总结："></a>webSetting相关API总结：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line">setAllowContentAccess (boolean allow)</div><div class="line">是否允许在WebView中访问内容URL（Content Url），默认允许。内容Url访问允许WebView从安装在系统中的内容提供者载入内容。</div><div class="line"></div><div class="line">setAllowFileAccess (boolean allow)</div><div class="line">是否允许访问文件，默认允许。注意，这里只是允许或禁止对文件系统的访问，Assets 和 resources 文件使用file:///android_asset和file:///android_res仍是可访问的。</div><div class="line"></div><div class="line">setAllowFileAccessFromFileURLs (boolean flag)</div><div class="line">是否允许运行在一个URL环境（the context of a file scheme URL）中的JavaScript访问来自其他URL环境的内容，为了保证安全，应该不允许。也请注意，这项设置只影响对file schema 资源的JavaScript访问，其他形式的访问，例如来自图片HTML单元的访问不受影响。为了防止相同的域策略（same domain policy）对ICE_CREAM_SANDWICH以及更老机型的侵害，应该显式地设置此值为false。</div><div class="line"></div><div class="line">setAllowUniversalAccessFromFileURLs (boolean flag)</div><div class="line">是否允许运行在一个file schema URL环境下的JavaScript访问来自其他任何来源的内容，包括其他file schema URLs. 参见setAllowFileAccessFromFileURLs(boolean)，为了确保安全，应该设置为不允许，注意这项设置只影响对file schema 资源的JavaScript访问，其他形式的访问，例如来自图片HTML单元的访问不受影响。为了防止相同的域策略（same domain policy）对ICE_CREAM_SANDWICH以及更老机型的侵害，应该显式地设置此值为false。ICE_CREAM_SANDWICH_MR1 以及更老的版本此默认值为true，JELLY_BEAN以及更新版本此默认值为false</div><div class="line"></div><div class="line">setAppCacheEnabled (boolean flag)</div><div class="line">应用缓存API是否可用，默认值false, 结合setAppCachePath(String)使用。</div><div class="line"></div><div class="line">setAppCachePath(String)</div><div class="line">设置应用缓存文件的路径。为了让应用缓存API可用，此方法必须传入一个应用可写的路径。该方法只会执行一次，重复调用会被忽略。</div><div class="line"></div><div class="line">setAppCacheMaxSize (long appCacheMaxSize)</div><div class="line">已废弃。设置应用缓存内容的最大值。所传值会被近似为数据库支持的最近似值，因此这是一个指示值，而不是一个固定值。所传值若小于数据库大小不会让数据库调整大小。默认值是MAX_VALUE，建议将默认值设置为最大值。</div><div class="line"></div><div class="line">setBlockNetworkImage (boolean flag)</div><div class="line">是否禁止从网络（通过http和https URI schemes访问的资源）下载图片资源，默认值为false。注意，除非getLoadsImagesAutomatically()返回true,否则该方法无效。还请注意，即使此项设置为false，使用setBlockNetworkLoads(boolean)禁止所有网络加载也会阻止网络图片的加载。当此项设置的值从true变为false，WebView当前显示的内容所引用的网络图片资源会自动获取。</div><div class="line"></div><div class="line">setBlockNetworkLoads (boolean flag)</div><div class="line">是否禁止从网络下载数据，如果app有INTERNET权限，默认值为false，否则默认为true。使用setBlockNetworkImage(boolean) 只会禁止图片资源的加载。注意此值由true变为false，当前WebView展示的内容所引用的网络资源不会自动加载，直到调用了重载。如果APP没有INTERNET权限，设置此值为false会抛出SecurityException。</div><div class="line"></div><div class="line">setBuiltInZoomControls (boolean enabled)</div><div class="line">是否使用内置的缩放机制。内置的缩放机制包括屏幕上的缩放控件（浮于WebView内容之上）和缩放手势的运用。通过setDisplayZoomControls(boolean)可以控制是否显示这些控件，默认值为false。</div><div class="line"></div><div class="line">setCacheMode (int mode)</div><div class="line">重写使用缓存的方式，默认值LOAD_DEFAULT。缓存的使用方式基于导航类型，正常的页面加载，检测缓存，需要时缓存内容复现。导航返回时，内容不会复现，只有内容会从缓存盘中恢复。该方法允许客户端通过指定LOAD_DEFAULT, LOAD_CACHE_ELSE_NETWORK, LOAD_NO_CACHE or LOAD_CACHE_ONLY的其中一项来重写其行为。</div><div class="line"></div><div class="line">setCursiveFontFamily (String font)</div><div class="line">设置WebView字体库字体，默认“cursive”</div><div class="line"></div><div class="line">setDatabaseEnabled (boolean flag)</div><div class="line">数据库存储API是否可用，默认值false。如何正确设置数据存储API参见setDatabasePath(String)。该设置对同一进程中的所有WebView实例均有效。注意，只能在当前进程的任意WebView加载页面之前修改此项，因为此节点之后WebView的实现类可能会忽略该项设置的改变。</div><div class="line"></div><div class="line">setDatabasePath (String databasePath)</div><div class="line">已废弃，数据库路径由实现（implementation）管理，调用此方法无效。</div><div class="line">设置数据库的存储路径，为了保证数据库正确运行，该方法必须使用一个应用可写的路径。此方法只能执行一次，重复调用会被忽略。</div><div class="line"></div><div class="line">setDefaultFixedFontSize (int size)</div><div class="line">设置默认固定的字体大小，默认为16，可取值1到72</div><div class="line"></div><div class="line">setDefaultFontSize (int size)</div><div class="line">设置默认的字体大小，默认16，可取值1到72</div><div class="line"></div><div class="line">setDefaultTextEncodingName (String encoding)</div><div class="line">设置默认的字符编码集，默认”UTF-8”.</div><div class="line"></div><div class="line">setDefaultZoom (WebSettings.ZoomDensity zoom)</div><div class="line">已废弃。设置默认的缩放密度，必须在UI线程调用，默认值MEDIUM.该项设置在新应用中不推荐使用。如果WebView用于展示手机页面，可以通过调整页面的’meta viewport’ 标记中的’width’ 和 ‘initial-scale’属性实现预期效果，对于漏用标记的页面，可以使用setInitialScale(int)和setUseWideViewPort(boolean) .</div><div class="line"></div><div class="line">setDisplayZoomControls (boolean enabled)</div><div class="line">使用内置的缩放机制时是否展示缩放控件，默认值true。参见setBuiltInZoomControls(boolean).</div><div class="line"></div><div class="line">setDomStorageEnabled (boolean flag)</div><div class="line">DOM存储API是否可用，默认false。</div><div class="line"></div><div class="line">setEnableSmoothTransition (boolean enable)</div><div class="line">已废弃，将来会成为空操作（no-op），设置当panning或者缩放或者持有当前WebView的window没有焦点时是否允许其光滑过渡，若为true，WebView会选择一个性能最大化的解决方案。例如过渡时WebView的内容可能不更新。若为false，WebView会保持精度（fidelity），默认值false。</div><div class="line"></div><div class="line">setFantasyFontFamily (String font)</div><div class="line">设置fantasy字体集（font family）的名字默认为“fantasy”</div><div class="line"></div><div class="line">setFixedFontFamily (String font)</div><div class="line">设置固定的字体集的名字，默认为”monospace”。</div><div class="line"></div><div class="line">setGeolocationDatabasePath (String databasePath)</div><div class="line">定位数据库的保存路径，为了确保定位权限和缓存位置的持久化，该方法应该传入一个应用可写的路径。</div><div class="line"></div><div class="line">setGeolocationEnabled (boolean flag)</div><div class="line">定位是否可用，默认为true。请注意，为了确保定位API在WebView的页面中可用，必须遵守如下约定:</div><div class="line">(1) app必须有定位的权限，参见ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION；</div><div class="line">(2) app必须提供onGeolocationPermissionsShowPrompt(String, GeolocationPermissions.Callback)回调方法的实现，在页面通过JavaScript定位API请求定位时接收通知。</div><div class="line">作为可选项，可以在数据库中存储历史位置和Web初始权限，参见setGeolocationDatabasePath(String).</div><div class="line"></div><div class="line">setJavaScriptCanOpenWindowsAutomatically (boolean flag)</div><div class="line">让JavaScript自动打开窗口，默认false。适用于JavaScript方法window.open()。</div><div class="line"></div><div class="line">setJavaScriptEnabled (boolean flag)</div><div class="line">设置WebView是否允许执行JavaScript脚本，默认false，不允许。</div><div class="line"></div><div class="line">setLayoutAlgorithm (WebSettings.LayoutAlgorithm l)</div><div class="line">设置布局，会引起WebView的重新布局（relayout）,默认值NARROW_COLUMNS</div><div class="line"></div><div class="line">setLightTouchEnabled (boolean enabled)</div><div class="line">已废弃。从 JELLY_BEAN 开始，该设置无效。允许使用轻触摸做出选择和光标悬停。</div><div class="line"></div><div class="line">setLoadWithOverviewMode (boolean overview)</div><div class="line">是否允许WebView度超出以概览的方式载入页面，默认false。即缩小内容以适应屏幕宽度。该项设置在内容宽度超出WebView控件的宽度时生效，例如当getUseWideViewPort() 返回true时。</div><div class="line"></div><div class="line">setLoadsImagesAutomatically (boolean flag)</div><div class="line">WebView是否下载图片资源，默认为true。注意，该方法控制所有图片的下载，包括使用URI嵌入的图片（使用setBlockNetworkImage(boolean) 只控制使用网络URI的图片的下载）。如果该设置项的值由false变为true，WebView展示的内容所引用的所有的图片资源将自动下载。</div><div class="line"></div><div class="line">setMediaPlaybackRequiresUserGesture (boolean require)</div><div class="line">WebView是否需要用户的手势进行媒体播放，默认值为true。</div><div class="line"></div><div class="line">setMinimumFontSize (int size)</div><div class="line">设置最小的字号，默认为8</div><div class="line"></div><div class="line">setMinimumLogicalFontSize (int size)</div><div class="line">设置最小的本地字号，默认为8。</div><div class="line"></div><div class="line">setMixedContentMode (int mode)</div><div class="line">当一个安全的来源（origin）试图从一个不安全的来源加载资源时配置WebView的行为。默认情况下，KITKAT及更低版本默认值为MIXED_CONTENT_ALWAYS_ALLOW，LOLLIPOP版本默认值MIXED_CONTENT_NEVER_ALLOW，WebView首选的最安全的操作模式为MIXED_CONTENT_NEVER_ALLOW ，不鼓励使用MIXED_CONTENT_ALWAYS_ALLOW。</div><div class="line"></div><div class="line">setNeedInitialFocus (boolean flag)</div><div class="line">调用requestFocus(int, Android.graphics.Rect)时是否需要设置节点获取焦点，默认值为true。</div><div class="line"></div><div class="line">setOffscreenPreRaster (boolean enabled)</div><div class="line">当WebView切换到后台但仍然与窗口关联时是否raster tiles，打开它可以避免在WebView从后台切换到前台时重新绘制，默认值false。在这种模式下后台的WebView占用更多的内存。请按如下准则显示内存的使用：</div><div class="line">    WebView的尺寸不能比设备的屏幕尺寸更大；</div><div class="line">    限制在少数WebView上使用该模式；</div><div class="line">    在可见的WebView和即将显现的WebView上使用；</div><div class="line"></div><div class="line">setPluginState (WebSettings.PluginState state)</div><div class="line">在API18以上已废弃。未来将不支持插件，不要使用。告诉WebView启用、禁用或者有即用（on demand）的插件，即用模式是指如果存在一个可以处理嵌入内容的插件，会显示一个占位图标，点击时开启。默认值OFF。</div><div class="line"></div><div class="line">setRenderPriority (WebSettings.RenderPriority priority)</div><div class="line">在API18以上已废弃。不建议调整线程优先级，未来版本不会支持这样做。设置绘制（Render，很多书上翻译成渲染，貌似很专业，但是不易懂，不敢苟同）线程的优先级。不像其他设置，同一进程中只需调用一次，默认值NORMAL。</div><div class="line"></div><div class="line">setSansSerifFontFamily (String font)</div><div class="line">设置无衬线字体集（sans-serif font family）的名字。默认值”sans-serif”.</div><div class="line"></div><div class="line">setSaveFormData (boolean save)</div><div class="line">WebView是否保存表单数据，默认值true。</div><div class="line"></div><div class="line">setSavePassword (boolean save)</div><div class="line">API18以上版本已废弃。未来版本将不支持保存WebView中的密码。设置WebView是否保存密码，默认true。</div><div class="line"></div><div class="line">setSerifFontFamily (String font)</div><div class="line">设置衬线字体集（serif font family）的名字，默认“sans-serif”。</div><div class="line"></div><div class="line">setStandardFontFamily (String font)</div><div class="line">设置标准字体集的名字，默认值“sans-serif”。</div><div class="line"></div><div class="line">setSupportMultipleWindows (boolean support)</div><div class="line">设置WebView是否支持多窗口。如果设置为true，主程序要实现onCreateWindow(WebView, boolean, boolean, Message)，默认false。</div><div class="line"></div><div class="line">setSupportZoom (boolean support)</div><div class="line">WebView是否支持使用屏幕上的缩放控件和手势进行缩放，默认值true。设置setBuiltInZoomControls(boolean)可以使用特殊的缩放机制。该项设置不会影响zoomIn() and zoomOut()的缩放操作。</div><div class="line"></div><div class="line">setTextSize (WebSettings.TextSize t)</div><div class="line">API14版本以上已废弃。请取代使用setTextZoom(int)。设置页面文本的尺寸，默认NORMAL。</div><div class="line"></div><div class="line">setTextZoom (int textZoom)</div><div class="line">设置页面上的文本缩放百分比，默认100。</div><div class="line"></div><div class="line">setUseWideViewPort (boolean use)</div><div class="line">WebView是否支持HTML的“viewport”标签或者使用wide viewport。设置值为true时，布局的宽度总是与WebView控件上的设备无关像素（device-dependent pixels）宽度一致。当值为true且页面包含viewport标记，将使用标签指定的宽度。如果页面不包含标签或者标签没有提供宽度，那就使用wide viewport。</div><div class="line"></div><div class="line">setUserAgentString (String ua)</div><div class="line">设置WebView的用户代理字符串。如果字符串为null或者empty，将使用系统默认值。注意从KITKAT版本开始，加载网页时改变用户代理会让WebView再次初始化加载。</div><div class="line"></div><div class="line">supportMultipleWindows ()</div><div class="line">获取WebView是否支持多窗口的值。</div><div class="line"></div><div class="line">supportZoom ()</div><div class="line">获取WebView是否支持缩放的值。</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下webview缓存的文章
    
    </summary>
    
      <category term="webView缓存" scheme="http://yoursite.com/categories/webView%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="Android,webView,cache" scheme="http://yoursite.com/tags/Android-webView-cache/"/>
    
  </entry>
  
  <entry>
    <title>Andorid下的webview的CookieManager全解析</title>
    <link href="http://yoursite.com/2017/05/25/Android%E4%B8%8BwebView%E7%9A%84CookieManager%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/05/25/Android下webView的CookieManager全解析/</id>
    <published>2017-05-25T09:11:53.000Z</published>
    <updated>2017-06-03T12:03:47.572Z</updated>
    
    <content type="html"><![CDATA[<p>#Android下webview的CookieManager详解</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=340395&auto=1&height=66"></iframe>

<h2 id="CookieManager介绍"><a href="#CookieManager介绍" class="headerlink" title="CookieManager介绍"></a>CookieManager介绍</h2><ul>
<li>java.net.CookieManager<ul>
<li>java.net.CookieManager供java工程使用的（略）</li>
</ul>
</li>
<li>android.webkit.CookieManager<ul>
<li>android.webkit.CookieManager包下提供了供andorid系统使用的一个cookie管理的类<ul>
<li>Manages the cookies used by an application’s WebView instances.<ul>
<li>Cookies are manipulated according to RFC2109.<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Android APP应用的某些功能, 需要调用内嵌的WebView去加载某个URL使用.  但用户在手机APP已经成功登录过了. 这时, 如果在内置浏览器去打开网页还需要用户再输入登录一次, 似乎显得不够人性化.  又或者, 用户在内置浏览器(WebView) 访问过一些页面, 想把这些有用的 Cookies 信息保存在本地.  因此, 我们会想, 要是能管理APP上浏览器(WebView) 在该站点URL的 Cookies, 使后台识别为已登录, 棒棒哒~</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul>
<li><p>1、客户端通过以下代码设置cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CookieManager cookieManager = CookieManager.getInstance();   //获取单例对象</div><div class="line">cookieManager.setCookie(url, &quot;uid=test_value&quot;); 	    	//同步方法，给url设置cookie字段，key为uid,value为test_value</div></pre></td></tr></table></figure>
</li>
<li><p>2、CookieManager会将这个Cookie存入该应用程序/data/data/databases/目录下的webviewCookiesChromium.db数据库的cookies表中</p>
</li>
<li><p>3、打开网页，WebView从数据库中读取该cookie值，放到http请求的头部，传递到服务器</p>
</li>
<li><p>4、客户端可以在某些时刻清除该应用程序用到的所有cookies</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CookieManager cookieManager = CookieManager.getInstance(); //获取单例对象</div><div class="line">cookieManager.removeAllCookie();//清除所有的cookie</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="天坑所在"><a href="#天坑所在" class="headerlink" title="天坑所在"></a>天坑所在</h2><ul>
<li>removeAllCookie（）与removeSessionCookies（）竟然是异步的删除cookie的方法，但是却没有回调。所以会出现一种您觉得你删除成功了，其实并没有删除成功的情况，那你再次登录可能会存在cookie同步不合预期的情况产生。<h2 id="API解析"><a href="#API解析" class="headerlink" title="API解析"></a>API解析</h2></li>
<li>以下来解析源码，read the funk source code:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Gets the singleton CookieManager instance.</div><div class="line"> *</div><div class="line"> * @return the singleton CookieManager instance</div><div class="line"> */</div><div class="line">public static synchronized CookieManager getInstance() &#123;  //获取单例对象</div><div class="line">    return WebViewFactory.getProvider().getCookieManager();   </div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets whether the application&apos;s &#123;@link WebView&#125; instances should send and</div><div class="line"> * accept cookies.</div><div class="line"> * By default this is set to true and the WebView accepts cookies.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * When this is true</div><div class="line"> * &#123;@link CookieManager#setAcceptThirdPartyCookies setAcceptThirdPartyCookies&#125; and</div><div class="line"> * &#123;@link CookieManager#setAcceptFileSchemeCookies setAcceptFileSchemeCookies&#125;</div><div class="line"> * can be used to control the policy for those specific types of cookie.</div><div class="line"> *</div><div class="line"> * @param accept whether &#123;@link WebView&#125; instances should send and accept</div><div class="line"> *               cookies</div><div class="line"> */</div><div class="line">public abstract void setAcceptCookie(boolean accept);  //设置是否接受cookie,默认是true</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether the application&apos;s &#123;@link WebView&#125; instances send and accept</div><div class="line"> * cookies.</div><div class="line"> *</div><div class="line"> * @return true if &#123;@link WebView&#125; instances send and accept cookies</div><div class="line"> */</div><div class="line">public abstract boolean acceptCookie(); //获取webview是否接受cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets whether the &#123;@link WebView&#125; should allow third party cookies to be set.</div><div class="line"> * Allowing third party cookies is a per WebView policy and can be set</div><div class="line"> * differently on different WebView instances.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Apps that target &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125; or below</div><div class="line"> * default to allowing third party cookies. Apps targeting</div><div class="line"> * &#123;@link android.os.Build.VERSION_CODES#LOLLIPOP&#125; or later default to disallowing</div><div class="line"> * third party cookies.</div><div class="line"> *</div><div class="line"> * @param webview the &#123;@link WebView&#125; instance to set the cookie policy on</div><div class="line"> * @param accept whether the &#123;@link WebView&#125; instance should accept</div><div class="line"> *               third party cookies</div><div class="line"> */</div><div class="line">public abstract void setAcceptThirdPartyCookies(WebView webview, boolean accept);//  设置跨域cookie读取,当Build.Version小于kitkat时候，默认值是true,之后的为false</div><div class="line">     </div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether the &#123;@link WebView&#125; should allow third party cookies to be set.</div><div class="line"> *</div><div class="line"> * @param webview the &#123;@link WebView&#125; instance to get the cookie policy for</div><div class="line"> * @return true if the &#123;@link WebView&#125; accepts third party cookies</div><div class="line"> */</div><div class="line">public abstract boolean acceptThirdPartyCookies(WebView webview);  //获取是否设置了跨域cookie读取</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets a cookie for the given URL. Any existing cookie with the same host,</div><div class="line"> * path and name will be replaced with the new cookie. The cookie being set</div><div class="line"> * will be ignored if it is expired.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookie is to be set</div><div class="line"> * @param value the cookie as a string, using the format of the &apos;Set-Cookie&apos;</div><div class="line"> *              HTTP response header</div><div class="line"> */</div><div class="line">public abstract void setCookie(String url, String value); //根据URL设置cookie字段</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets a cookie for the given URL. Any existing cookie with the same host,</div><div class="line"> * path and name will be replaced with the new cookie. The cookie being set</div><div class="line"> * will be ignored if it is expired.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This method is asynchronous.</div><div class="line"> * If a &#123;@link ValueCallback&#125; is provided,</div><div class="line"> * &#123;@link ValueCallback#onReceiveValue(T) onReceiveValue()&#125; will be called on the current</div><div class="line"> * thread&apos;s &#123;@link android.os.Looper&#125; once the operation is complete.</div><div class="line"> * The value provided to the callback indicates whether the cookie was set successfully.</div><div class="line"> * You can pass &#123;@code null&#125; as the callback if you don&apos;t need to know when the operation</div><div class="line"> * completes or whether it succeeded, and in this case it is safe to call the method from a</div><div class="line"> * thread without a Looper.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookie is to be set</div><div class="line"> * @param value the cookie as a string, using the format of the &apos;Set-Cookie&apos;</div><div class="line"> *              HTTP response header</div><div class="line"> * @param callback a callback to be executed when the cookie has been set</div><div class="line"> */</div><div class="line">public abstract void setCookie(String url, String value, ValueCallback&lt;Boolean&gt; callback);//根据url覆盖cookie某字段的值</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets the cookies for the given URL.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookies are requested</div><div class="line"> * @return value the cookies as a string, using the format of the &apos;Cookie&apos;</div><div class="line"> *               HTTP request header</div><div class="line"> */</div><div class="line">public abstract String getCookie(String url);  //根据url获取cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * See &#123;@link #getCookie(String)&#125;.</div><div class="line"> *</div><div class="line"> * @param url the URL for which the cookies are requested</div><div class="line"> * @param privateBrowsing whether to use the private browsing cookie jar</div><div class="line"> * @return value the cookies as a string, using the format of the &apos;Cookie&apos;</div><div class="line"> *               HTTP request header</div><div class="line"> * @hide Used by Browser and by WebViewProvider implementations.</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">public abstract String getCookie(String url, boolean privateBrowsing);  //系统api</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets cookie(s) for a given uri so that it can be set to &quot;cookie:&quot; in http</div><div class="line"> * request header.</div><div class="line"> *</div><div class="line"> * @param uri the WebAddress for which the cookies are requested</div><div class="line"> * @return value the cookies as a string, using the format of the &apos;Cookie&apos;</div><div class="line"> *               HTTP request header</div><div class="line"> * @hide Used by RequestHandle and by WebViewProvider implementations.</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">public synchronized String getCookie(WebAddress uri) &#123; //系统api</div><div class="line">    return getCookie(uri.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all session cookies, which are cookies without an expiration</div><div class="line"> * date.</div><div class="line"> * @deprecated use &#123;@link #removeSessionCookies(ValueCallback)&#125; instead.</div><div class="line"> */</div><div class="line">public abstract void removeSessionCookie();  //清除未过期的cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all session cookies, which are cookies without an expiration</div><div class="line"> * date.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This method is asynchronous.</div><div class="line"> * If a &#123;@link ValueCallback&#125; is provided,</div><div class="line"> * &#123;@link ValueCallback#onReceiveValue(T) onReceiveValue()&#125; will be called on the current</div><div class="line"> * thread&apos;s &#123;@link android.os.Looper&#125; once the operation is complete.</div><div class="line"> * The value provided to the callback indicates whether any cookies were removed.</div><div class="line"> * You can pass &#123;@code null&#125; as the callback if you don&apos;t need to know when the operation</div><div class="line"> * completes or whether any cookie were removed, and in this case it is safe to call the</div><div class="line"> * method from a thread without a Looper.</div><div class="line"> * @param callback a callback which is executed when the session cookies have been removed</div><div class="line"> */</div><div class="line">public abstract void removeSessionCookies(ValueCallback&lt;Boolean&gt; callback);  //坑爹的异步方法</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all cookies.</div><div class="line"> * @deprecated Use &#123;@link #removeAllCookies(ValueCallback)&#125; instead.</div><div class="line"> */</div><div class="line">@Deprecated</div><div class="line">public abstract void removeAllCookie();</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all cookies.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This method is asynchronous.</div><div class="line"> * If a &#123;@link ValueCallback&#125; is provided,</div><div class="line"> * &#123;@link ValueCallback#onReceiveValue(T) onReceiveValue()&#125; will be called on the current</div><div class="line"> * thread&apos;s &#123;@link android.os.Looper&#125; once the operation is complete.</div><div class="line"> * The value provided to the callback indicates whether any cookies were removed.</div><div class="line"> * You can pass &#123;@code null&#125; as the callback if you don&apos;t need to know when the operation</div><div class="line"> * completes or whether any cookies were removed, and in this case it is safe to call the</div><div class="line"> * method from a thread without a Looper.</div><div class="line"> * @param callback a callback which is executed when the cookies have been removed</div><div class="line"> */</div><div class="line">public abstract void removeAllCookies(ValueCallback&lt;Boolean&gt; callback); //清除所有cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether there are stored cookies.</div><div class="line"> *</div><div class="line"> * @return true if there are stored cookies</div><div class="line"> */</div><div class="line">public abstract boolean hasCookies();  //获取是否有cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * See &#123;@link #hasCookies()&#125;.</div><div class="line"> *</div><div class="line"> * @param privateBrowsing whether to use the private browsing cookie jar</div><div class="line"> * @hide Used by Browser and WebViewProvider implementations.</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">public abstract boolean hasCookies(boolean privateBrowsing); //系统api</div><div class="line"></div><div class="line">/**</div><div class="line"> * Removes all expired cookies.</div><div class="line"> * @deprecated The WebView handles removing expired cookies automatically.</div><div class="line"> */</div><div class="line">@Deprecated</div><div class="line">public abstract void removeExpiredCookie();   //清除过期的cookie</div><div class="line"></div><div class="line">/**</div><div class="line"> * Ensures all cookies currently accessible through the getCookie API are</div><div class="line"> * written to persistent storage.</div><div class="line"> * This call will block the caller until it is done and may perform I/O.</div><div class="line"> */</div><div class="line">public abstract void flush(); //确保cookie都是写进本地了，会阻塞IO</div><div class="line"></div><div class="line">/**</div><div class="line"> * Gets whether the application&apos;s &#123;@link WebView&#125; instances send and accept</div><div class="line"> * cookies for file scheme URLs.</div><div class="line"> *</div><div class="line"> * @return true if &#123;@link WebView&#125; instances send and accept cookies for</div><div class="line"> *         file scheme URLs</div><div class="line"> */</div><div class="line">// Static for backward compatibility.</div><div class="line">public static boolean allowFileSchemeCookies() &#123;  </div><div class="line">    return getInstance().allowFileSchemeCookiesImpl();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Implements &#123;@link #allowFileSchemeCookies()&#125;.</div><div class="line"> *</div><div class="line"> * @hide Only for use by WebViewProvider implementations</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">protected abstract boolean allowFileSchemeCookiesImpl();</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets whether the application&apos;s &#123;@link WebView&#125; instances should send and</div><div class="line"> * accept cookies for file scheme URLs.</div><div class="line"> * Use of cookies with file scheme URLs is potentially insecure and turned</div><div class="line"> * off by default.</div><div class="line"> * Do not use this feature unless you can be sure that no unintentional</div><div class="line"> * sharing of cookie data can take place.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * Note that calls to this method will have no effect if made after a</div><div class="line"> * &#123;@link WebView&#125; or CookieManager instance has been created.</div><div class="line"> */</div><div class="line">// Static for backward compatibility.</div><div class="line">public static void setAcceptFileSchemeCookies(boolean accept) &#123;</div><div class="line">    getInstance().setAcceptFileSchemeCookiesImpl(accept);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Implements &#123;@link #setAcceptFileSchemeCookies(boolean)&#125;.</div><div class="line"> *</div><div class="line"> * @hide Only for use by WebViewProvider implementations</div><div class="line"> */</div><div class="line">@SystemApi</div><div class="line">protected abstract void setAcceptFileSchemeCookiesImpl(boolean accept);</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下webview的CookieManager的文章
    
    </summary>
    
      <category term="webView的CookieManager" scheme="http://yoursite.com/categories/webView%E7%9A%84CookieManager/"/>
    
    
      <category term="Android,webView,cookie,CookieManager" scheme="http://yoursite.com/tags/Android-webView-cookie-CookieManager/"/>
    
  </entry>
  
  <entry>
    <title>设计模式全解析</title>
    <link href="http://yoursite.com/2017/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/05/07/设计模式全解析/</id>
    <published>2017-05-07T09:49:51.000Z</published>
    <updated>2017-06-08T11:40:40.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>#设计模式全解析（持续更新中…）：</p>
</blockquote>
<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><ul>
<li><p>java 语言面向对象的三大特征：封装、继承、多态。</p>
<ul>
<li>封装性<ul>
<li>封装性就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义：<ul>
<li>把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位（即对象）。</li>
<li>信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界〔或者说形成一道屏障〕，只保留有限的对外接口使之与外部发生联系。</li>
</ul>
</li>
<li>封装的原则在软件上的反映是：要求使对象以外的部分不能随意存取对象的内部数据（属性），从而有效的避免了外部错误对它的”交叉感染”，使软件错误能够局部化，大大减少查错和排错的难度。</li>
</ul>
</li>
<li><p>继承性</p>
<ul>
<li>特殊类的对象拥有其一般类的全部属性与服务，称作特殊类对一般类的继承。一个类可以是多个一般类的特殊类，它从多个一般类中继承了属性与服务，这称为多继承。在java语言中，通常我们称一般类为父类（superclass,超类），特殊类为子类(subclass)。</li>
</ul>
</li>
<li><p>多态性</p>
<ul>
<li>对象的多态性是指在一般类中定义的属性或服务被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或服务在一般类及其各个特殊 类中具有不同的语义。例如：”几何图形”的”绘图”方法，”椭圆”和”多边形”都是”几何图”的子类，其”绘图”方法功能不同。</li>
</ul>
</li>
</ul>
</li>
<li><p>java 语言面向对象的六大原则</p>
<ul>
<li>开闭原则</li>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特原则</li>
</ul>
</li>
<li><p>23种传统设计模式：（已经完成23种）</p>
<ul>
<li>1.单例设计模式　（完成）</li>
<li>2.工厂方法模式　（完成）</li>
<li>3.抽象工厂模式　（完成）</li>
<li>4.模板方法模式　（完成）</li>
<li>5.建造者模式　（完成）</li>
<li>6.代理模式　（完成）</li>
<li>7.原型模式（完成）</li>
<li>8.中介者模式（完成）</li>
<li>9.命令模式(完成)</li>
<li>10.责任链模式(完成)</li>
<li>11.装饰模式　（完成）</li>
<li>12.策略模式　（完成）</li>
<li>13.适配器模式（完成）</li>
<li>14.迭代器模式（完成）</li>
<li>15.组合模式(完成)</li>
<li>16.观察者模式（完成）</li>
<li>17.门面模式（完成）</li>
<li>18.备忘录模式(完成)</li>
<li>19.访问者模式（完成）</li>
<li>20.状态模式（完成）</li>
<li>21.解释器模式（完成）</li>
<li>22.享元模式（完成）</li>
<li>23.桥梁模式（完成）</li>
</ul>
</li>
<li>23种传统设计模式PK<ul>
<li>创建类模式包含工厂方法模式、建造者模式，抽象工厂模式，单例模式和原型模式（5种），他们都能提供对象的创建和管理职责。其中单例模式和原型模式比较容易理解，单例模式是要在内存中只有一个对象，原型模式是要通过复制的方式产生一个新的对象，这两个不容易混淆，剩下的就是工厂方法模式、抽象工厂模式和建造者模式了。这三个之间有较多的相似性。</li>
<li>结构类模式包括适配器模式，桥梁模式，组合模式，装饰模式，门面模式，享元模式和代理模式（7种），为什么叫结构类模式呢，因为他们都是通过组合类或者对象产生更大结构以适应更高层次的逻辑需求的。</li>
<li>行为类模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式（11种）。</li>
</ul>
</li>
<li>23种传统设计模式混编<ul>
<li>比如说：<ul>
<li>命令模式 +　责任链模式</li>
<li>工厂方法模式 +　策略模式</li>
<li>观察者模式　＋　中介者模式</li>
</ul>
</li>
</ul>
</li>
<li>新的设计模式<ul>
<li>规格模式、对象池模式、雇工模式、黑板模式、空对象模式…</li>
</ul>
</li>
</ul>
<h1 id="设计模式各个击破"><a href="#设计模式各个击破" class="headerlink" title="设计模式各个击破"></a>设计模式各个击破</h1><h2 id="1-单例设计模式"><a href="#1-单例设计模式" class="headerlink" title="1.单例设计模式"></a>1.单例设计模式</h2><ul>
<li>保证类在内存中只有一个对象。</li>
<li>如何保证类在内存中只有一个对象呢？<ul>
<li>控制类的创建，不让其他类来创建本类的对象，也就是私有化构造；</li>
<li>在本类中定义本类的对象；</li>
<li>提供公共的访问方式；</li>
</ul>
</li>
<li>单例的几种写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">饿汉式：直接new出对象，这种就是以空间换时间</div><div class="line">	</div><div class="line">		//饿汉式</div><div class="line">		class Singleton &#123;</div><div class="line">			//1,私有构造函数</div><div class="line">			private Singleton()&#123;&#125;</div><div class="line">			//2,创建本类对象</div><div class="line">			private static Singleton s = new Singleton();</div><div class="line">			//3,对外提供公共的访问方法</div><div class="line">			public static Singleton getInstance() &#123;</div><div class="line">				return s;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			public static void print() &#123;</div><div class="line">				System.out.println(&quot;饿汉式的方法&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">(2)懒汉式 这种方式 多线程的问题？</div><div class="line"></div><div class="line">		//懒汉式,单例的延迟加载模式</div><div class="line">		class Singleton &#123;</div><div class="line">			//1,私有构造函数</div><div class="line">			private Singleton()&#123;&#125;</div><div class="line">			//2,声明一个本类的引用</div><div class="line">			private static Singleton s;</div><div class="line">			//3,对外提供公共的访问方法</div><div class="line">			public static Singleton getInstance() &#123;</div><div class="line">				if(s == null)</div><div class="line">					//线程1,线程2（可能某个对象在wait()）</div><div class="line">					s = new Singleton();</div><div class="line">				return s;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			public static void print() &#123;</div><div class="line">				System.out.println(&quot;懒汉式的方法&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		 * 饿汉式和懒汉式的区别</div><div class="line">		 * 1,饿汉式是空间换时间,懒汉式是时间换空间</div><div class="line">		 * 2,在多线程访问时,饿汉式不会创建多个对象,而懒汉式有可能会创建多个对象</div><div class="line">		 */</div><div class="line"></div><div class="line">		由于懒汉式存在线程安全的问题，所以我们可以这样做：</div><div class="line">		使用双重检测锁机制，先检测是否为空，如果为空再对该单例类加锁，再判断一次是否为空，这样既解决了线程的安全问题，也避免了每次使用单例都要加锁带来的系统资源的消耗。代码如下：</div><div class="line">		class Singleton &#123;</div><div class="line">			//1,私有构造函数</div><div class="line">			private Singleton()&#123;&#125;</div><div class="line">			//2,声明一个本类的引用</div><div class="line">			private static volatile Singleton s;</div><div class="line">			//3,对外提供公共的访问方法</div><div class="line">			public static Singleton getInstance() &#123;</div><div class="line">				if(s == null)</div><div class="line">					Synchronized(Singleton.class)&#123;</div><div class="line">						if(s == null) &#123;</div><div class="line">							s = new Singleton();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				return s;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			public static void print() &#123;</div><div class="line">				System.out.println(&quot;懒汉式的方法&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">(3)第三种格式</div><div class="line"> </div><div class="line">		class Singleton &#123;</div><div class="line">			private Singleton() &#123;&#125;</div><div class="line">		</div><div class="line">			public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h2 id="2-装饰设计模式"><a href="#2-装饰设计模式" class="headerlink" title="2.装饰设计模式"></a>2.装饰设计模式</h2><ul>
<li>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class Demo_Wrap &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * 装饰设计模式的好处是:</div><div class="line">	 * 耦合性不强,被装饰的类的变化与装饰类的变化无关</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AdvanceStudent as = new AdvanceStudent(new Student());</div><div class="line">		as.code();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Coder &#123;</div><div class="line">	public void code();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Student implements Coder &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void code() &#123;</div><div class="line">		System.out.println(&quot;javase&quot;);</div><div class="line">		System.out.println(&quot;javaweb&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class AdvanceStudent implements Coder &#123;</div><div class="line">	//1,获取被装饰类的引用</div><div class="line">	private Student s;						//获取学生引用</div><div class="line">	</div><div class="line">	//2,在构造方法中传入被装饰类的对象</div><div class="line">	public AdvanceStudent(Student s) &#123;</div><div class="line">		this.s = s;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//3,对原有的功能进行升级</div><div class="line">	@Override</div><div class="line">	public void code() &#123;</div><div class="line">		s.code();</div><div class="line">		System.out.println(&quot;ssh&quot;);</div><div class="line">		System.out.println(&quot;数据库&quot;);</div><div class="line">		System.out.println(&quot;大数据&quot;);</div><div class="line">		System.out.println(&quot;...&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-简单工厂设计模式"><a href="#3-简单工厂设计模式" class="headerlink" title="3.简单工厂设计模式"></a>3.简单工厂设计模式</h2><ul>
<li>简单工厂模式概述<ul>
<li>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例</li>
</ul>
</li>
<li>优点<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责</li>
</ul>
</li>
<li>缺点<ul>
<li>这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</li>
</ul>
</li>
<li>案例演示<ul>
<li>动物抽象类：public abstract Animal { public abstract void eat(); }</li>
<li>具体狗类：public class Dog extends Animal {}</li>
<li>具体猫类：public class Cat extends Animal {}</li>
<li>开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">//动物抽象类</div><div class="line">public abstract class Animal &#123;</div><div class="line">	public abstract void eat();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//猫类</div><div class="line">public class Cat extends Animal &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void eat() &#123;</div><div class="line">		System.out.println(&quot;猫吃鱼&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//狗类</div><div class="line">public class Dog extends Animal &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void eat() &#123;</div><div class="line">		System.out.println(&quot;狗吃肉&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//动物工厂类</div><div class="line">public class AnimalFactory &#123;</div><div class="line">	/*public static Dog createDog() &#123;</div><div class="line">		return new Dog();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static Cat createCat() &#123;</div><div class="line">		return new Cat();</div><div class="line">	&#125;*/</div><div class="line">	</div><div class="line">	//发现方法会定义很多,复用性太差</div><div class="line">	//改进</div><div class="line">	public static Animal createAnimal(String name) &#123;</div><div class="line">		if(&quot;dog&quot;.equals(name)) &#123;</div><div class="line">			return new Dog();</div><div class="line">		&#125;else if(&quot;cat&quot;.equals(name)) &#123;</div><div class="line">			return new Cat();</div><div class="line">		&#125;else &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试类</div><div class="line">public class Test &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//Dog d = AnimalFactory.createDog();</div><div class="line">		</div><div class="line">		Dog d = (Dog) AnimalFactory.createAnimal(&quot;dog&quot;);</div><div class="line">		d.eat();</div><div class="line">		</div><div class="line">		Cat c = (Cat) AnimalFactory.createAnimal(&quot;cat&quot;);</div><div class="line">		c.eat();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="3-工厂方法设计模式"><a href="#3-工厂方法设计模式" class="headerlink" title="3.工厂方法设计模式"></a>3.工厂方法设计模式</h2><ul>
<li>工厂方法模式概述<ul>
<li>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</li>
</ul>
</li>
<li>优点<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li>
</ul>
</li>
<li>缺点<ul>
<li>需要额外的编写代码，增加了工作量</li>
</ul>
</li>
<li>案例演示<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">* 动物抽象类：public abstract Animal &#123; public abstract void eat(); &#125;</div><div class="line">* 工厂接口：public interface Factory &#123;public abstract Animal createAnimal();&#125;</div><div class="line">* 具体狗类：public class Dog extends Animal &#123;&#125;</div><div class="line">* 具体猫类：public class Cat extends Animal &#123;&#125;</div><div class="line">开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。</div><div class="line">* 狗工厂：public class DogFactory implements Factory &#123;</div><div class="line">			public Animal createAnimal() &#123;…&#125;</div><div class="line">        &#125;</div><div class="line">* 猫工厂：public class CatFactory implements Factory &#123;</div><div class="line">			public Animal createAnimal() &#123;…&#125;</div><div class="line">        &#125;  </div><div class="line"></div><div class="line"></div><div class="line">		//动物抽象类</div><div class="line">	    public abstract class Animal &#123;</div><div class="line">			public abstract void eat();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//工厂接口</div><div class="line">		public interface Factory &#123;</div><div class="line">			public Animal createAnimal();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		//猫工厂类</div><div class="line">		public class CatFactory implements Factory &#123;</div><div class="line">		</div><div class="line">			@Override</div><div class="line">			public Animal createAnimal() &#123;</div><div class="line">		</div><div class="line">				return new Cat();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		//猫类</div><div class="line">		public class Cat extends Animal &#123;</div><div class="line">		</div><div class="line">			@Override</div><div class="line">			public void eat() &#123;</div><div class="line">				System.out.println(&quot;猫吃鱼&quot;);</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		//狗工厂类</div><div class="line">		public class DogFactory implements Factory &#123;</div><div class="line">		</div><div class="line">			@Override</div><div class="line">			public Animal createAnimal() &#123;</div><div class="line">		</div><div class="line">				return new Dog();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		//狗类</div><div class="line">		public class Dog extends Animal &#123;</div><div class="line">		</div><div class="line">			@Override</div><div class="line">			public void eat() &#123;</div><div class="line">				System.out.println(&quot;狗吃肉&quot;);</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//测试类</div><div class="line">		public class Test &#123;</div><div class="line">		</div><div class="line">			/**</div><div class="line">			 * @param args</div><div class="line">			 */</div><div class="line">			public static void main(String[] args) &#123;</div><div class="line">				DogFactory df = new DogFactory();</div><div class="line">				Dog d = (Dog) df.createAnimal();</div><div class="line">				d.eat();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-抽象工厂设计模式"><a href="#4-抽象工厂设计模式" class="headerlink" title="4.抽象工厂设计模式"></a>4.抽象工厂设计模式</h2><ul>
<li>定义：提供一个创建一系列相关或者相互依赖产品的接口， 而无需制定他们的具体类，一对多的关系。抽象工厂模式是 工厂方法模式的升级版。</li>
<li>例子： 我们接着前边土豪的故事继续讲。话说这个土豪还有一个爱好，就是打猎。但是土豪打猎是有要求的（毕竟土豪嘛，要就就得高一点），他如果坐Audi车去打猎，那么他就一定要使用AK47这把枪（这是去打猎吗？）；如果他坐Benz车去打猎那么他就一定要用M4A1这把枪，如果按照我们前边讲的工厂方法模式来编程，那么应该是建立一个Car的抽象工厂类CarFactory，然后Benz车的工厂继承自这个抽象的父类并实现生产Benz车的方法，Audi车的工厂继承自这个抽象的父类并实现生产Audi车的方法。并且还要有一个生产Gun的抽象工厂类，由它的具体子类工厂来实现生产AK47和M4A1。这样做是非常麻烦的，我们已经知道了如果土豪做Audi的话那他一定是使用AK47，所以我们可以使用一个工厂来同时生产Audi车和AK47，注意我说的前提是我们已经知道了土豪一定是Audi车和AK47一起使用的，如果不满足这个条件的话是不能使用抽象工厂模式来解决这个问题的。</li>
<li>优点：即符合面向对象设计的“开闭原则”和“单一职责原 则”。又减少了系统中的类的数量，不用像工厂方法一样每生 产一个产品都要有一个具体的工厂类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 仅仅定义生产同一族产品的两个不同等级结构的产品接口，具体的实现由子类工厂来实现</div><div class="line"> * @Mr.Wu</div><div class="line"> *</div><div class="line"> */</div><div class="line">public abstract class AbstractFactory &#123;</div><div class="line">    public abstract Car getCar();</div><div class="line">    public abstract Gun getGun();   </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Audi车的工厂同时生产Audi车和配套的AK47</div><div class="line"> * @Mr.Wu</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class AudiFactory extends AbstractFactory&#123;</div><div class="line"></div><div class="line">    public Car getCar() &#123;       </div><div class="line">        return new Audi();      </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Gun getGun() &#123;</div><div class="line">        return new AK47();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Benz车的工厂同时生产Benz车和配套的M4A1</div><div class="line"> * @Mr.Wu</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class BenzFactory extends AbstractFactory&#123;</div><div class="line"></div><div class="line">	public Car getCar() &#123;		</div><div class="line">		return new Benz();		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Gun getGun() &#123;</div><div class="line">		return new M4A1();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//gun的抽象类</div><div class="line">public abstract class Gun &#123;</div><div class="line">    abstract void fire();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//M4A1的具体类</div><div class="line">public class M4A1 extends Gun&#123;</div><div class="line"></div><div class="line">	public M4A1()&#123;</div><div class="line">		System.out.println(&quot;Create an M4A1&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void fire()&#123;</div><div class="line">		System.out.println(&quot;M4A1 start fire&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//AK47的类</div><div class="line">public class AK47 extends Gun&#123;</div><div class="line"></div><div class="line">	public AK47()&#123;</div><div class="line">		System.out.println(&quot;Create an AK47&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void fire()&#123;</div><div class="line">		System.out.println(&quot;AK47 start fire&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//车的抽象类</div><div class="line">public abstract class Car &#123;</div><div class="line">	abstract void drive();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//奥迪车的类</div><div class="line">public class Audi extends Car&#123;</div><div class="line"></div><div class="line">	public Audi()&#123;</div><div class="line">		System.out.println(&quot;Create a Audi&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void drive()&#123;</div><div class="line">		System.out.println(&quot;Audi start engine&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//奔驰车的类</div><div class="line">public class Benz extends Car&#123;</div><div class="line"></div><div class="line">	public Benz()&#123;</div><div class="line">		System.out.println(&quot;Create a Benz&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void drive()&#123;</div><div class="line">		System.out.println(&quot;Benz start engine&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试类</div><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line">		//奔驰车司机</div><div class="line">		AbstractFactory factory = new BenzFactory();</div><div class="line">		//今天想做奥迪车</div><div class="line">		Car car = factory.getCar();</div><div class="line">		//开车</div><div class="line">		car.drive();</div><div class="line">		//获得开Benz时要用的枪</div><div class="line">		Gun gun = factory.getGun();</div><div class="line">		//开火</div><div class="line">		gun.fire();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>说明：当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>
</blockquote>
<h2 id="5-享元设计模式"><a href="#5-享元设计模式" class="headerlink" title="5.享元设计模式"></a>5.享元设计模式</h2><ul>
<li><p>解释一下概念：也就是说在一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。比如说一个文本系统，每个字母定一个对象，那么大小写字母一共就是52个，那么就要定义52个对象。如果有一个1M的文本，那么字母是何其的多，如果每个字母都定义一个对象那么内存早就爆了。那么如果要是每个字母都共享一个对象，那么就大大节约了资源。</p>
</li>
<li><p>在Flyweight模式中，由于要产生各种各样的对象，所以在Flyweight(享元)模式中常出现Factory模式。Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个对象存储池（Flyweight Pool）来存放内部状态的对象。Flyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多，下面举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">　　先定义一个抽象的Flyweight类：</div><div class="line">    package Flyweight;  </div><div class="line">    public abstract class Flyweight&#123;  </div><div class="line">    　public abstract void operation();  </div><div class="line">    &#125;  </div><div class="line">	实现一个具体类：</div><div class="line"></div><div class="line"></div><div class="line">    package Flyweight;  </div><div class="line">    public class ConcreteFlyweight extends Flyweight&#123;  </div><div class="line">    　private String string;  </div><div class="line">    　public ConcreteFlyweight(String str)&#123;  </div><div class="line">    　　string = str;  </div><div class="line">    　&#125;  </div><div class="line">    　public void operation()  </div><div class="line">    　&#123;  </div><div class="line">    　　System.out.println(&quot;Concrete---Flyweight : &quot; + string);  </div><div class="line">    　&#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">实现一个工厂方法类：</div><div class="line"></div><div class="line">    package Flyweight;  </div><div class="line">    import java.util.Hashtable;  </div><div class="line">    public class FlyweightFactory&#123;  </div><div class="line">    　private Hashtable flyweights = new Hashtable();//----------------------------1  </div><div class="line">    　public FlyweightFactory()&#123;&#125;  </div><div class="line">    　public Flyweight getFlyWeight(Object obj)&#123;  </div><div class="line">    　　Flyweight flyweight = (Flyweight) flyweights.get(obj);//----------------2  </div><div class="line">    　　if(flyweight == null)&#123;//---------------------------------------------------3  </div><div class="line">    　　　//产生新的ConcreteFlyweight  </div><div class="line">    　　　flyweight = new ConcreteFlyweight((String)obj);  </div><div class="line">    　　　flyweights.put(obj, flyweight);//--------------------------------------5  </div><div class="line">    　　&#125;  </div><div class="line">    　　return flyweight;//---------------------------------------------------------6  </div><div class="line">    　&#125;  </div><div class="line">    　public int getFlyweightSize()&#123;  </div><div class="line">    　　return flyweights.size();  </div><div class="line">    　&#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">这个工厂方法类非常关键，这里详细解释一下：</div><div class="line">　　在1处定义了一个Hashtable用来存储各个对象；在2处选出要实例化的对象，在6处将该对象返回，如果在Hashtable中没有要选择的对象，此时变量flyweight为null，产生一个新的flyweight存储在Hashtable中，并将该对象返回。</div><div class="line">　　最后看看Flyweight的调用：</div><div class="line"></div><div class="line">    package Flyweight;  </div><div class="line">    import java.util.Hashtable;  </div><div class="line">    public class FlyweightPattern&#123;  </div><div class="line">    　FlyweightFactory factory = new FlyweightFactory();   </div><div class="line">    　Flyweight fly1;  </div><div class="line">    　Flyweight fly2;  </div><div class="line">    　Flyweight fly3;  </div><div class="line">    　Flyweight fly4;  </div><div class="line">    　Flyweight fly5;  </div><div class="line">    　Flyweight fly6;  </div><div class="line">    　/** *//** Creates a new instance of FlyweightPattern */  </div><div class="line">    　public FlyweightPattern()&#123;  </div><div class="line">    　　fly1 = factory.getFlyWeight(&quot;Google&quot;);  </div><div class="line">    　　fly2 = factory.getFlyWeight(&quot;Qutr&quot;);  </div><div class="line">    　　fly3 = factory.getFlyWeight(&quot;Google&quot;);  </div><div class="line">    　　fly4 = factory.getFlyWeight(&quot;Google&quot;);  </div><div class="line">    　　fly5 = factory.getFlyWeight(&quot;Google&quot;);  </div><div class="line">    　　fly6 = factory.getFlyWeight(&quot;Google&quot;);  </div><div class="line">    　&#125;  </div><div class="line">    　public void showFlyweight()&#123;  </div><div class="line">    　　fly1.operation();  </div><div class="line">    　　fly2.operation();  </div><div class="line">    　　fly3.operation();  </div><div class="line">    　　fly4.operation();  </div><div class="line">    　　fly5.operation();  </div><div class="line">    　　fly6.operation();  </div><div class="line">    　　int objSize = factory.getFlyweightSize();  </div><div class="line">    　　System.out.println(&quot;objSize = &quot; + objSize);  </div><div class="line">    　&#125;  </div><div class="line">    　public static void main(String[] args)&#123;  </div><div class="line">    　　System.out.println(&quot;The FlyWeight Pattern!&quot;);  </div><div class="line">    　　FlyweightPattern fp = new FlyweightPattern();  </div><div class="line">    　　fp.showFlyweight();  </div><div class="line">    　&#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"></div><div class="line">下面是运行结果：</div><div class="line"></div><div class="line">    Concrete---Flyweight : Google  </div><div class="line">    Concrete---Flyweight : Qutr  </div><div class="line">    Concrete---Flyweight : Google  </div><div class="line">    Concrete---Flyweight : Google  </div><div class="line">    Concrete---Flyweight : Google  </div><div class="line">    Concrete---Flyweight : Google  </div><div class="line">    objSize = 2  </div><div class="line"></div><div class="line"></div><div class="line">　我们定义了6个对象，其中有5个是相同的，按照Flyweight模式的定义“Google”应该共享一个对象，在实际的对象数中我们可以看出实际的对象却是只有2个。</div><div class="line"></div><div class="line">总结：</div><div class="line">　　Flyweight(享元)模式是如此的重要，因为它能帮你在一个复杂的系统中大量的节省内存空间。在Java语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。String a=&quot;abc&quot;，其中&quot;abc&quot;就是一个字符串常量。</div><div class="line"></div><div class="line">熟悉java的应该知道下面这个例子：</div><div class="line">    String a = &quot;hello&quot;;  </div><div class="line">    String b = &quot;hello&quot;;  </div><div class="line">    if(a == b)  </div><div class="line">    　System.out.println(&quot;OK&quot;);  </div><div class="line">    else  </div><div class="line">    　System.out.println(&quot;Error&quot;);  </div><div class="line"></div><div class="line">输出结果是：OK。可以看出if条件比较的是两a和b的地址，也可以说是内存空间</div><div class="line">核心总结，可以共享的对象，也就是说返回的同一类型的对象其实是同一实例，当客户端要求生成一个对象时，工厂会检测是否存在此对象的实例，如果存在那么直接返回此对象实例，如果不存在就创建一个并保存起来，这点有些单例模式的意思。通常工厂类会有一个集合类型的成员变量来用以保存对象，如hashtable,vector等。在java中，数据库连接池，线程池等即是用享元模式的应用。</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-适配器设计模式"><a href="#6-适配器设计模式" class="headerlink" title="6.适配器设计模式"></a>6.适配器设计模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class Demo_Adapter &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * 适配器设计模式</div><div class="line">	 * 鲁智深</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		鲁智深 鲁智深 = new 鲁智深();</div><div class="line">		鲁智深.习武();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">interface 和尚 &#123;</div><div class="line">	public void 打坐();</div><div class="line">	public void 念经();</div><div class="line">	public void 撞钟();</div><div class="line">	public void 习武();</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class 天罡星 implements 和尚 &#123;		//声明成抽象的原因是,不想让其他类创建本类对象,因为创建也没有意义,方法都是空的</div><div class="line">	@Override</div><div class="line">	public void 打坐() &#123;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void 念经() &#123;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void 撞钟() &#123;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void 习武() &#123;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">class 鲁智深 extends 天罡星 &#123;</div><div class="line">	public void 习武() &#123;</div><div class="line">		System.out.println(&quot;倒拔垂杨柳&quot;);</div><div class="line">		System.out.println(&quot;拳打镇关西&quot;);</div><div class="line">		System.out.println(&quot;大闹野猪林&quot;);</div><div class="line">		System.out.println(&quot;......&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7-模板方法设计模式"><a href="#7-模板方法设计模式" class="headerlink" title="7.模板方法设计模式"></a>7.模板方法设计模式</h2><ul>
<li>模版设计模式概述<ul>
<li>模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</li>
</ul>
</li>
<li>优点和缺点<ul>
<li>优点:使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求</li>
<li>缺点:如果算法骨架有修改的话，则需要修改抽象类<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">			</div><div class="line">public class Demo1_Template &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		/*long start = System.currentTimeMillis();</div><div class="line">		for(int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">			System.out.println(&quot;x&quot;);</div><div class="line">		&#125;</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		System.out.println(end - start);*/</div><div class="line">		Demo d = new Demo();</div><div class="line">		System.out.println(d.getTime());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class GetTime &#123;</div><div class="line">	public final long getTime() &#123;</div><div class="line">		long start = System.currentTimeMillis();</div><div class="line">		code();</div><div class="line">		long end = System.currentTimeMillis();</div><div class="line">		return end - start;</div><div class="line">	&#125;  //final修饰，目的是不让被重写</div><div class="line"></div><div class="line">	public abstract void code(); //由子类取实现想测试的代码</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Demo extends GetTime &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void code() &#123;</div><div class="line">		int i = 0;</div><div class="line">		while(i &lt; 100000) &#123;</div><div class="line">			System.out.println(&quot;x&quot;);</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">			&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="8-观察者设计模式（有时又被称为发布（publish-）-订阅（Subscribe）模式、模型-视图（View）模式、源-收听者-Listener-模式或从属者模式）"><a href="#8-观察者设计模式（有时又被称为发布（publish-）-订阅（Subscribe）模式、模型-视图（View）模式、源-收听者-Listener-模式或从属者模式）" class="headerlink" title="8.观察者设计模式（有时又被称为发布（publish ）-订阅（Subscribe）模式、模型-视图（View）模式、源-收听者(Listener)模式或从属者模式）"></a>8.观察者设计模式（有时又被称为发布（publish ）-订阅（Subscribe）模式、模型-视图（View）模式、源-收听者(Listener)模式或从属者模式）</h2><ul>
<li>定义：又名发布—订阅模式，对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li><p>组成部分：</p>
<ul>
<li><p>抽象目标(被观察者)角色(Subject)：目标角色知道它的观察者，可以 有任意多个观察者观察同一个目标。并且提供注册和删除观 察者对象、通知观察者的方法。目标角色往往由抽象类或者 接口来实现。</p>
</li>
<li><p>抽象观察者角色(Observer)：为那些在目标发生改变时需<br>要获得通知的对象定义一个更新接口，里面有一个更新数据 的方法。抽象观察者角色主要由抽象类或者接口来实现。</p>
</li>
<li>具体目标(被观察者)角色(Concrete Subject)：实现Subject，实现添 加、删除观察者、通知观察者的方法，当它的状态发生改变 时, 向它的各个观察者发出通知。</li>
<li>具体观察者角色(Concrete Observer)：实现Observer的更 新接口以使自身状态与目标的状态保持一致，获取通知进行 更新。</li>
</ul>
</li>
<li><p>观察者模式中，一个被观察者管理所有相依于它的观察者物件，并且在本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p>
</li>
<li>举例：珠宝商运送一批钻石，有黄金强盗准备抢劫，珠宝商雇佣了私人保镖，警察局也派人护送，于是当运输车上路的时候，强盗保镖警察都要观察运输车一举一动，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">抽象的观察者</div><div class="line">    public interface Watcher  </div><div class="line">    &#123;  </div><div class="line">         public void update();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"></div><div class="line">抽象的被观察者，在其中声明方法（添加、移除观察者，通知观察者）：</div><div class="line">    public interface Watched  </div><div class="line">    &#123;  </div><div class="line">         public void addWatcher(Watcher watcher);  </div><div class="line">         public void removeWatcher(Watcher watcher);  </div><div class="line">         public void notifyWatchers();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">具体的观察者</div><div class="line">保镖</div><div class="line">    public class Security implements Watcher  </div><div class="line">    &#123;  </div><div class="line">         @Override  </div><div class="line">         public void update()  </div><div class="line">         &#123;  </div><div class="line">              System.out.println(“运输车有行动，保安贴身保护&quot;);  </div><div class="line">         &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">强盗</div><div class="line">    public class Thief implements Watcher  </div><div class="line">    &#123;  </div><div class="line">         @Override  </div><div class="line">         public void update()  </div><div class="line">         &#123;  </div><div class="line">              System.out.println(“运输车有行动，强盗准备动手&quot;);  </div><div class="line">         &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">警察</div><div class="line">    public class Police implements Watcher  </div><div class="line">    &#123;  </div><div class="line">         @Override  </div><div class="line">         public void update()  </div><div class="line">         &#123;  </div><div class="line">              System.out.println(“运输车有行动，警察护航&quot;);  </div><div class="line">         &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">具体的被观察者</div><div class="line">    public class Transporter implements Watched  </div><div class="line">    &#123;  </div><div class="line">         private List&lt;Watcher&gt; list = new ArrayList&lt;Watcher&gt;();  </div><div class="line">      </div><div class="line">         @Override  </div><div class="line">         public void addWatcher(Watcher watcher)  </div><div class="line">         &#123;  </div><div class="line">              list.add(watcher);  </div><div class="line">         &#125;  </div><div class="line">      </div><div class="line">         @Override  </div><div class="line">         public void removeWatcher(Watcher watcher)  </div><div class="line">         &#123;  </div><div class="line">              list.remove(watcher);  </div><div class="line">         &#125;  </div><div class="line">      </div><div class="line">         @Override  </div><div class="line">         public void notifyWatchers(String str)  </div><div class="line">         &#123;  </div><div class="line">              for (Watcher watcher : list)  </div><div class="line">              &#123;  </div><div class="line">                   watcher.update();  </div><div class="line">              &#125;  </div><div class="line">         &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">测试类</div><div class="line"></div><div class="line"></div><div class="line">    public class Test  </div><div class="line">    &#123;  </div><div class="line">         public static void main(String[] args)  </div><div class="line">         &#123;  </div><div class="line">              Transporter transporter = new Transporter();  </div><div class="line">      </div><div class="line">              Police police = new Police();  </div><div class="line">              Security security = new Security();  </div><div class="line">              Thief thief = new Thief();  </div><div class="line">      </div><div class="line">              transporter.addWatcher(police);  </div><div class="line">              transporter.addWatcher(security);  </div><div class="line">              transporter.addWatcher(security);  </div><div class="line">      </div><div class="line">              transporter.notifyWatchers();  </div><div class="line">         &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>我推你拉例子中没有关于数据和状态的变化通知，只是简单通知到各个观察者，告诉他们被观察者有行动。<br>观察者模式在关于目标角色、观察者角色通信的具体实现中，有两个版本。<ul>
<li>一种情况便是目标角色在发生变化后，仅仅告诉观察者角色“我变化了”，观察者角色如果想要知道具体的变化细节，则就要自己从目标角色的接口中得到。这种模式被很形象的称为：拉模式——就是说变化的信息是观察者角色主动从目标角色中“拉”出来的。</li>
<li>还有一种方法，那就是我目标角色“服务一条龙”，通知你发生变化的同时，通过一个参数将变化的细节传递到观察者角色中去。这就是“推模式”——管你要不要，先给你啦。</li>
</ul>
</li>
<li>这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。如果目标角色比较简单，则“拉模式”就很合适啦。</li>
</ul>
<h2 id="9-代理设计模式"><a href="#9-代理设计模式" class="headerlink" title="9.代理设计模式"></a>9.代理设计模式</h2><ul>
<li>什么是代理模式：代理模式的作用是，为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>好处：在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</li>
<li>代理模式一般涉及到的角色有：<ul>
<li>抽象角色：声明真实对象和代理对象的共同接口；</li>
<li>代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</li>
<li>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</li>
</ul>
</li>
<li><p>应用场景举例：比如西门庆找潘金莲，那潘金莲不好意思答复呀，咋办，找那个王婆做代理，表现在程序上时是这样的体现的先说说这个场景中的要素：一种类型的女人，潘金莲，王婆，西门庆，后来扩展的贾氏也和西门庆勾上了，我们是假设的，然后西门庆找潘金莲happy,但潘金莲不好意思直接，就找个王婆代理呗。我们看看具体代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div></pre></td><td class="code"><pre><div class="line">	先定义一种女人</div><div class="line">    /** </div><div class="line">     *  </div><div class="line">     * @author Mr.Wu</div><div class="line">     *定义一种类型的女人，王婆和潘金莲都属于这个类型的女人 </div><div class="line">     */  </div><div class="line">    public interface KindWoman &#123;  </div><div class="line">          </div><div class="line">        //这种女人能做什么事情呢？  </div><div class="line">        public void makeEyesWithMan();//抛媚眼  </div><div class="line">          </div><div class="line">        public void happyWithMan();//和男人那个....  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">一种类型嘛，那肯定是接口，定义个潘金莲 </div><div class="line">    /** </div><div class="line">     *  </div><div class="line">     * @author Mr.Wu</div><div class="line">     *定义一个潘金莲是什么样的人 </div><div class="line">     */  </div><div class="line">    public class PanJinLian  implements KindWoman&#123;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void happyWithMan() &#123;  </div><div class="line">            System.out.println(&quot;潘金莲和男人在做那个...&quot;);  </div><div class="line">              </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void makeEyesWithMan() &#123;  </div><div class="line">            System.out.println(&quot;潘金莲抛媚眼...&quot;);  </div><div class="line">              </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">再定义个丑陋的王婆 </div><div class="line">    /** </div><div class="line">     *  </div><div class="line">     * @author Mr.Wu</div><div class="line">     *王婆这个人老聪明了，她太老了，是个男人都看不上她， </div><div class="line">     *但是她有智慧经验呀，他作为一类女人的代理！ </div><div class="line">     */  </div><div class="line">    public class WangPo implements KindWoman &#123;  </div><div class="line">          </div><div class="line">        private KindWoman kindWoman;  </div><div class="line">          </div><div class="line">        public WangPo()&#123;  </div><div class="line">            //默认的话是潘金莲的代理  </div><div class="line">            this.kindWoman = new PanJinLian();  </div><div class="line">        &#125;  </div><div class="line">        //她可以是KindWomam的任何一个女人的代理，只要你是这一类型  </div><div class="line">        public WangPo(KindWoman kindWoman)&#123;  </div><div class="line">            this.kindWoman = kindWoman;  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void happyWithMan() &#123;  </div><div class="line">            //自己老了，干不了了，但可以叫年轻的代替。  </div><div class="line">            this.kindWoman.happyWithMan();  </div><div class="line">              </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void makeEyesWithMan() &#123;  </div><div class="line">            //王婆年纪大了，谁看她抛媚眼啊  </div><div class="line">            this.kindWoman.makeEyesWithMan();  </div><div class="line">              </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">两个女主角都上场了，该男主角了，定义个西门庆</div><div class="line">    /** </div><div class="line">     *  </div><div class="line">     * @author Mr.Wu</div><div class="line">     *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下，西门庆看痴迷了，被王婆看到了，就开始撮合两人好事，王婆作为潘金莲的代理人收了不少好处费，那我们假设一下： </div><div class="line">     *如果没有王婆在中间牵线，这两个不要脸的能成事吗？难说得很！ </div><div class="line">     */  </div><div class="line">    public class XiMenQing &#123;  </div><div class="line">      </div><div class="line">        /** </div><div class="line">         * @param args </div><div class="line">         */  </div><div class="line">        public static void main(String[] args) &#123;  </div><div class="line">            WangPo wangPo;  </div><div class="line">            //把王婆叫出来  </div><div class="line">             wangPo = new WangPo();  </div><div class="line">            //然后西门庆说，我要和潘金莲Happy,然后王婆就安排了西门庆丢筷子哪出戏：  </div><div class="line">            wangPo.makeEyesWithMan();  </div><div class="line">            //看到没有表面是王婆在做，其实爽的是潘金莲  </div><div class="line">            wangPo.happyWithMan();  </div><div class="line">              </div><div class="line">              </div><div class="line">      </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">那这就是活生生的一个例子，通过代理人实现了某种目的，如果真去了王婆这个中间环节，直接西门庆和潘金莲勾搭，估计很难成就武松杀嫂事件。</div><div class="line"></div><div class="line">     那我们再考虑一下，水浒里面还有没有这类型的女人？有，卢俊义的老婆贾氏（就是和那个管家苟合的那个），这个名字起的：“贾氏”，那我们也让王婆做她的代理：</div><div class="line">    /** </div><div class="line">     *  </div><div class="line">     * @author Mr.Wu</div><div class="line">     *定义一个贾氏是什么样的人 </div><div class="line">     */  </div><div class="line">    public class JiaShi implements KindWoman &#123;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void happyWithMan() &#123;  </div><div class="line">            System.out.println(&quot;贾氏和男人在做那个...&quot;);  </div><div class="line">              </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        @Override  </div><div class="line">        public void makeEyesWithMan() &#123;  </div><div class="line">            System.out.println(&quot;贾氏抛媚眼...&quot;);  </div><div class="line">              </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">西门庆勾潘金莲又勾引贾氏</div><div class="line">    /** </div><div class="line">     *  </div><div class="line">     * @author Mr.Wu</div><div class="line">     *水浒传是这样写的：西门庆被潘金莲用竹竿敲了一下，西门庆看痴迷了，被王婆看到了，就开始撮合两人好事，王婆作为潘金莲的代理人收了不少好处费，那我们假设一下： </div><div class="line">     *如果没有王婆在中间牵线，这两个不要脸的能成事吗？难说得很！ </div><div class="line">     */  </div><div class="line">    public class XiMenQing &#123;  </div><div class="line">      </div><div class="line">        /** </div><div class="line">         * @param args </div><div class="line">         */  </div><div class="line">        public static void main(String[] args) &#123;  </div><div class="line">            WangPo wangPo;  </div><div class="line">            //把王婆叫出来  </div><div class="line">             wangPo = new WangPo();  </div><div class="line">            //然后西门庆说，我要和潘金莲Happy,然后王婆就安排了西门庆丢筷子哪出戏：  </div><div class="line">            wangPo.makeEyesWithMan();  </div><div class="line">            //看到没有表面是王婆在做，其实爽的是潘金莲  </div><div class="line">            wangPo.happyWithMan();  </div><div class="line">              </div><div class="line">              </div><div class="line">              </div><div class="line">            //西门庆勾引贾氏  </div><div class="line">            JiaShi jiaShi = new JiaShi();  </div><div class="line">            wangPo = new WangPo(jiaShi);  </div><div class="line">            wangPo.makeEyesWithMan();  </div><div class="line">            wangPo.happyWithMan();  </div><div class="line">      </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>说完这个故事，那我总结一下，代理模式主要使用了java的多态，干活的是被代理类，代理类主要是接活，你让我干活，好，我交给幕后的类去干，你满意就成，那怎么知道被代理类能不能干呢？同根就成，大家知根知底，你能做啥，我能做啥都清楚得很，同样一个接口呗。</p>
</blockquote>
</li>
</ul>
<h2 id="10-策略设计模式"><a href="#10-策略设计模式" class="headerlink" title="10.策略设计模式"></a>10.策略设计模式</h2><ul>
<li>背景<ul>
<li>在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。</li>
<li>这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</li>
</ul>
</li>
</ul>
<ul>
<li><p>问题</p>
<ul>
<li>如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？</li>
</ul>
</li>
<li><p>方案</p>
<ul>
<li>把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。</li>
<li>比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。</li>
</ul>
</li>
<li><p>适用情况</p>
<ul>
<li>许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。</li>
<li>当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。</li>
<li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li>
</ul>
</li>
<li>优点<ul>
<li>1、可以动态的改变对象的行为</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li>
<li>2、策略模式将造成产生很多策略类</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li>环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。</li>
<li>抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。</li>
<li>具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。</li>
</ul>
</li>
<li><p>应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">场景如下，刘备要到江东娶老婆了，走之前诸葛亮给赵云三个锦囊妙计，说是按天机拆开能解决棘手问题。场景中出现三个要素：三个妙计（具体策略类）、一个锦囊（环境类）、赵云（调用者）。</div><div class="line"></div><div class="line">	抽象策略类（Strategy）</div><div class="line">	</div><div class="line">	    public interface IStrategy &#123;  </div><div class="line">	         public void operate();  </div><div class="line">	    &#125;  </div><div class="line">	</div><div class="line">	</div><div class="line">	三个实现类（ConcreteStrategy）：</div><div class="line">	妙计一：初到吴国</div><div class="line">	    public class BackDoor implements IStrategy &#123;  </div><div class="line">	         @Override  </div><div class="line">	         public void operate() &#123;  </div><div class="line">	              System.out.println(&quot;找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备&quot;);  </div><div class="line">	         &#125;  </div><div class="line">	    &#125;  </div><div class="line">	</div><div class="line">	妙计二：求吴国太开绿灯放行</div><div class="line">	    public class GivenGreenLight implements IStrategy &#123;  </div><div class="line">	         @Override  </div><div class="line">	         public void operate() &#123;  </div><div class="line">	              System.out.println(&quot;求吴国太开个绿灯，放行&quot;);  </div><div class="line">	         &#125;  </div><div class="line">	    &#125;  </div><div class="line">	</div><div class="line">	妙计三：孙夫人断后，挡住追兵</div><div class="line">	    public class BlackEnemy implements IStrategy &#123;  </div><div class="line">	         @Override  </div><div class="line">	         public void operate() &#123;  </div><div class="line">	              System.out.println(&quot;孙夫人断后，挡住追兵&quot;);  </div><div class="line">	         &#125;  </div><div class="line">	    &#125;  </div><div class="line">	</div><div class="line">	</div><div class="line">	环境类（Context)</div><div class="line">	</div><div class="line">	    public class Context &#123;  </div><div class="line">	         private Strategy strategy;  </div><div class="line">	         //构造函数，要你使用哪个妙计  </div><div class="line">	         public Context(Strategy strategy)&#123;  </div><div class="line">	              this.strategy = strategy;  </div><div class="line">	         &#125;  </div><div class="line">	         public void setStrategy(Strategy strategy)&#123;  </div><div class="line">	              this.strategy = strategy;  </div><div class="line">	         &#125;  </div><div class="line">	         public void operate()&#123;  </div><div class="line">	              this.strategy.operate();  </div><div class="line">	         &#125;  </div><div class="line">	    &#125;  </div><div class="line">	</div><div class="line">	</div><div class="line">	下面就是使用的情况了</div><div class="line">	    public class Zhaoyun &#123;  </div><div class="line">		    public static void main(String[] args) &#123;  </div><div class="line">		         Context context;  </div><div class="line">		         System.out.println(&quot;----------刚到吴国使用第一个锦囊---------------&quot;);  </div><div class="line">		         context = new Context(new BackDoor());  </div><div class="line">		         context.operate();  </div><div class="line">		         System.out.println(&quot;\n&quot;);  </div><div class="line">		      </div><div class="line">		         System.out.println(&quot;----------刘备乐不思蜀使用第二个锦囊---------------&quot;);  </div><div class="line">		         context.setStrategy(new GivenGreenLight());  </div><div class="line">		         context.operate();  </div><div class="line">		         System.out.println(&quot;\n&quot;);  </div><div class="line">		      </div><div class="line">		         System.out.println(&quot;----------孙权的追兵来了，使用第三个锦囊---------------&quot;);  </div><div class="line">		         context.setStrategy(new BlackEnemy());  </div><div class="line">		         context.operate();  </div><div class="line">		         System.out.println(&quot;\n&quot;);  </div><div class="line">		         &#125;  </div><div class="line">		    &#125;  </div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	三招下来，搞得的周郎是“赔了夫人又折兵”。</div><div class="line">	以上就是策略模式，多种不同解决方案动态切换，起到改变对象行为的效果。</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="11-建造者设计模式"><a href="#11-建造者设计模式" class="headerlink" title="11.建造者设计模式"></a>11.建造者设计模式</h2><ul>
<li><p>概念</p>
<ul>
<li>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 [构建与表示分离，同构建不同表示]</li>
<li>与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。</li>
<li>建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。</li>
<li>举个简单的例子，如汽车，有很多部件，车轮，方向盘，发动机还有各种小零件等等，部件很多，但远不止这些，如何将这些部件装配成一部汽车，这个装配过程也很复杂（需要很好的组装技术）， builder模式就是为了将部件和组装分开。</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">public interface Builder &#123; </div><div class="line">　　　　void buildPartA(); </div><div class="line">　　　　void buildPartB(); </div><div class="line">　　　　void buildPartC(); </div><div class="line">　　</div><div class="line">　　　　Product getResult(); </div><div class="line">　　&#125; </div><div class="line"></div><div class="line">  //具体建造工具</div><div class="line">　　public class ConcreteBuilder implements Builder &#123; </div><div class="line">　　　　Part partA, partB, partC; </div><div class="line"></div><div class="line">　　　　public void buildPartA() &#123;</div><div class="line">　　　　　　//这里是具体如何构建partA的代码</div><div class="line">　　　　&#125;; </div><div class="line">　　　　public void buildPartB() &#123; </div><div class="line">　　　　　　//这里是具体如何构建partB的代码</div><div class="line">　　　　&#125;; </div><div class="line">　　　　 public void buildPartC() &#123; </div><div class="line">　　　　　　//这里是具体如何构建partB的代码</div><div class="line">　　　　&#125;; </div><div class="line">　　　　 public Product getResult() &#123; </div><div class="line">　　　　　　//返回最后组装成品结果</div><div class="line">　　　　&#125;; </div><div class="line">　　&#125;</div><div class="line"></div><div class="line">  //指导者</div><div class="line">　　public class Director &#123;</div><div class="line">　　　　private Builder builder; </div><div class="line">　　</div><div class="line">　　　　public Director( Builder builder ) &#123; </div><div class="line">　　　　　　this.builder = builder; </div><div class="line">　　　　&#125; </div><div class="line">　　　　public void construct() &#123; </div><div class="line">　　　　　　builder.buildPartA();</div><div class="line">　　　　　　builder.buildPartB();</div><div class="line">　　　　　　builder.buildPartC(); </div><div class="line">　　　　&#125; </div><div class="line">　　&#125; </div><div class="line"></div><div class="line"></div><div class="line">　　public interface Product &#123; &#125;</div><div class="line">　　public interface Part &#123; &#125;</div><div class="line">　　</div><div class="line"></div><div class="line">   下面是调用builder的方法：</div><div class="line">　　ConcreteBuilder builder = new ConcreteBuilder();</div><div class="line">　　Director director = new Director( builder ); </div><div class="line">　　</div><div class="line">　　director.construct(); </div><div class="line">　　Product product = builder.getResult();</div></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<ul>
<li>在Java的应用中JavaMail使用到了该模式，android中的Dialog使用到该模式</li>
</ul>
</li>
</ul>
<h2 id="12-原型模式"><a href="#12-原型模式" class="headerlink" title="12.原型模式"></a>12.原型模式</h2><ul>
<li>概念：原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：<ul>
<li>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</li>
<li>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。</li>
<li>原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。</li>
</ul>
</li>
</ul>
<p>-实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Prototype implements Cloneable &#123;    </div><div class="line">    public Prototype clone()&#123;    </div><div class="line">        Prototype prototype = null;    </div><div class="line">        try&#123;    </div><div class="line">            prototype = (Prototype)super.clone();    </div><div class="line">        &#125;catch(CloneNotSupportedException e)&#123;    </div><div class="line">            e.printStackTrace();    </div><div class="line">        &#125;    </div><div class="line">        return prototype;     </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">    </div><div class="line">class ConcretePrototype extends Prototype&#123;    </div><div class="line">    public void show()&#123;    </div><div class="line">        System.out.println(&quot;原型模式实现类&quot;);    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">    </div><div class="line">public class Client &#123;    </div><div class="line">    public static void main(String[] args)&#123;    </div><div class="line">        ConcretePrototype cp = new ConcretePrototype();    </div><div class="line">        for(int i=0; i&lt; 10; i++)&#123;    </div><div class="line">            ConcretePrototype clonecp = (ConcretePrototype)cp.clone();    </div><div class="line">            clonecp.show();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>优点：</p>
<ul>
<li>性能优良<ul>
<li>原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一</li>
<li>个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</li>
</ul>
</li>
<li>逃避构造函数的约束<ul>
<li>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>资源优化场景</li>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>性能和安全要求的场景</li>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景<ul>
<li>一个对象需要提供给其他对象访问，丽且各个调用者可能都需要修改其值时，可以考虑  使用原型模式拷贝多个对象供调用者使用。</li>
</ul>
</li>
<li>在实际项日中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式己经与Java融为一体，大家可以随手拿来使用。</li>
</ul>
</li>
<li>注意事项<ul>
<li>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。</li>
<li>深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean），对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Prototype implements Cloneable &#123;    </div><div class="line">    private ArrayList list = new ArrayList();    </div><div class="line">    public Prototype clone()&#123;    </div><div class="line">        Prototype prototype = null;    </div><div class="line">        try&#123;    </div><div class="line">            prototype = (Prototype)super.clone();    </div><div class="line">            prototype.list = (ArrayList) this.list.clone();    </div><div class="line">        &#125;catch(CloneNotSupportedException e)&#123;    </div><div class="line">            e.printStackTrace();    </div><div class="line">        &#125;    </div><div class="line">        return prototype;     </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>- 由于ArrayList不是基本类型，所以成员变量list，不会被拷贝，需要我们自己实现深拷贝，幸运的是Java提供的大部分的容器类都实现了Cloneable接口。所以实现深拷贝并不是特别困难。
- 关于深拷贝和浅拷贝，会发生深拷贝的是java 的 8种基本数据类型和他们的封装类，至于String这个类型需要注意，它是引用数据类型，所以是浅拷贝，
</code></pre><h2 id="13-中介者模式"><a href="#13-中介者模式" class="headerlink" title="13.中介者模式"></a>13.中介者模式</h2><ul>
<li><p>定义</p>
<ul>
<li>用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。</li>
</ul>
</li>
<li><p>角色</p>
<ul>
<li>抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。</li>
<li>中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。</li>
<li>同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。</li>
</ul>
</li>
<li><p>适用情况</p>
<ul>
<li>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如有六个同事类对象，假如对象1发生变化，会有4个对象受到影响。如果对象2发生变化，那么会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。如果引入中介者模式，那么同事类之间的关系将变为星型结构，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</li>
</ul>
</li>
</ul>
<ul>
<li><p>应用</p>
<ul>
<li>我们使用一个例子来说明一下什么是同事类：有两个类A和B，类中各有一个数字，并且要保证类B中的数字永远是类A中数字的100倍。也就是说，当修改类A的数时，将这个数字乘以100赋给类B，而修改类B时，要将数除以100赋给类A。类A类B互相影响，就称为同事类。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">---常规写法开始---</div><div class="line">abstract class AbstractColleague &#123;    </div><div class="line">    protected int number;    </div><div class="line">    </div><div class="line">    public int getNumber() &#123;    </div><div class="line">        return number;    </div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    public void setNumber(int number)&#123;    </div><div class="line">        this.number = number;    </div><div class="line">    &#125;    </div><div class="line">    //抽象方法，修改数字时同时修改关联对象    </div><div class="line">    public abstract void setNumber(int number, AbstractColleague coll);    </div><div class="line">&#125;    </div><div class="line"></div><div class="line">class ColleagueA extends AbstractColleague&#123;    </div><div class="line">    public void setNumber(int number, AbstractColleague coll) &#123;    </div><div class="line">        this.number = number;    </div><div class="line">        coll.setNumber(number*100);    </div><div class="line">    &#125;    </div><div class="line">&#125;   </div><div class="line"></div><div class="line">class ColleagueB extends AbstractColleague&#123;    </div><div class="line">        </div><div class="line">    public void setNumber(int number, AbstractColleague coll) &#123;    </div><div class="line">        this.number = number;    </div><div class="line">        coll.setNumber(number/100);    </div><div class="line">    &#125;    </div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class Client &#123;    </div><div class="line">    public static void main(String[] args)&#123;    </div><div class="line">    </div><div class="line">        AbstractColleague collA = new ColleagueA();    </div><div class="line">        AbstractColleague collB = new ColleagueB();    </div><div class="line">            </div><div class="line">        System.out.println(&quot;==========设置A影响B==========&quot;);    </div><div class="line">        collA.setNumber(1288, collB);    </div><div class="line">        System.out.println(&quot;collA的number值：&quot;+collA.getNumber());    </div><div class="line">        System.out.println(&quot;collB的number值：&quot;+collB.getNumber());    </div><div class="line">    </div><div class="line">        System.out.println(&quot;==========设置B影响A==========&quot;);    </div><div class="line">        collB.setNumber(87635, collA);    </div><div class="line">        System.out.println(&quot;collB的number值：&quot;+collB.getNumber());    </div><div class="line">        System.out.println(&quot;collA的number值：&quot;+collA.getNumber());    </div><div class="line">    &#125;    </div><div class="line">&#125;  </div><div class="line">---常规写法结束---</div><div class="line">上面的代码中，类A类B通过直接的关联发生关系，假如我们要使用中介者模式，类A类B之间则不可以直接关联，他们之间必须要通过一个中介者来达到关联的目的。</div><div class="line"></div><div class="line">---中介者模式开始---  </div><div class="line">同事类</div><div class="line">abstract class AbstractColleague &#123;    </div><div class="line">    protected int number;    </div><div class="line">    </div><div class="line">    public int getNumber() &#123;    </div><div class="line">        return number;    </div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    public void setNumber(int number)&#123;    </div><div class="line">        this.number = number;    </div><div class="line">    &#125;    </div><div class="line">    //注意这里的参数不再是同事类，而是一个中介者    </div><div class="line">    public abstract void setNumber(int number, AbstractMediator am);    </div><div class="line">&#125;   </div><div class="line"></div><div class="line">class ColleagueA extends AbstractColleague&#123;    </div><div class="line">    </div><div class="line">    public void setNumber(int number, AbstractMediator am) &#123;    </div><div class="line">        this.number = number;    </div><div class="line">        am.AaffectB();    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">        </div><div class="line">class ColleagueB extends AbstractColleague&#123;    </div><div class="line">    </div><div class="line">    @Override    </div><div class="line">    public void setNumber(int number, AbstractMediator am) &#123;    </div><div class="line">        this.number = number;    </div><div class="line">        am.BaffectA();    </div><div class="line">    &#125;    </div><div class="line">&#125;     </div><div class="line"></div><div class="line">抽象中介者类</div><div class="line">abstract class AbstractMediator &#123;    </div><div class="line">    protected AbstractColleague A;    </div><div class="line">    protected AbstractColleague B;    </div><div class="line">        </div><div class="line">    public AbstractMediator(AbstractColleague a, AbstractColleague b) &#123;    </div><div class="line">        A = a;    </div><div class="line">        B = b;    </div><div class="line">    &#125;    </div><div class="line">    public abstract void AaffectB();    </div><div class="line">    public abstract void BaffectA();    </div><div class="line">&#125; </div><div class="line"></div><div class="line">中介者类</div><div class="line">class Mediator extends AbstractMediator &#123;    </div><div class="line">    public Mediator(AbstractColleague a, AbstractColleague b) &#123;    </div><div class="line">        super(a, b);    </div><div class="line">    &#125;    </div><div class="line">    //处理A对B的影响    </div><div class="line">    public void AaffectB() &#123;    </div><div class="line">        int number = A.getNumber();    </div><div class="line">        B.setNumber(number*100);    </div><div class="line">    &#125;    </div><div class="line">    //处理B对A的影响    </div><div class="line">    public void BaffectA() &#123;    </div><div class="line">        int number = B.getNumber();    </div><div class="line">        A.setNumber(number/100);    </div><div class="line">    &#125;    </div><div class="line">&#125;  </div><div class="line"></div><div class="line">客户端</div><div class="line"></div><div class="line">public class Client &#123;    </div><div class="line">    public static void main(String[] args)&#123;    </div><div class="line">        AbstractColleague collA = new ColleagueA();    </div><div class="line">        AbstractColleague collB = new ColleagueB();    </div><div class="line">            </div><div class="line">        AbstractMediator am = new Mediator(collA, collB);    </div><div class="line">            </div><div class="line">        System.out.println(&quot;==========通过设置A影响B==========&quot;);    </div><div class="line">        collA.setNumber(1000, am);    </div><div class="line">        System.out.println(&quot;collA的number值为：&quot;+collA.getNumber());    </div><div class="line">        System.out.println(&quot;collB的number值为A的10倍：&quot;+collB.getNumber());    </div><div class="line">    </div><div class="line">        System.out.println(&quot;==========通过设置B影响A==========&quot;);    </div><div class="line">        collB.setNumber(1000, am);    </div><div class="line">        System.out.println(&quot;collB的number值为：&quot;+collB.getNumber());    </div><div class="line">        System.out.println(&quot;collA的number值为B的0.1倍：&quot;+collA.getNumber());    </div><div class="line">    &#125;    </div><div class="line">&#125;  </div><div class="line"></div><div class="line">---中介者模式结束---</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。</li>
<li>使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。</li>
<li>使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性，适当的使用中介者模式可以使原本凌乱的对象关系清晰，但是如果滥用，则可能会带来反的效果。一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。</li>
<li>中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数的情况，同事类之间的关系不会复杂到混乱不堪的网状结构，因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式。滥用中介者模式，只会让事情变的更复杂。 </li>
</ul>
</li>
</ul>
<h2 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14.命令模式"></a>14.命令模式</h2><ul>
<li><p>定义</p>
<ul>
<li>将来自客户端的请求传入一个对象，从而使你可用不同的请求对客户进行参数化。用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。分离变化与不变的因素。</li>
</ul>
</li>
<li><p>角色</p>
<ul>
<li>Command 定义命令的接口，声明执行的方法。</li>
<li>ConcreteCommand 命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>Receiver 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>Invoker 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>
<li>Client 创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>1.降低对象之间的耦合度。</li>
<li>2.新的命令可以很容易地加入到系统中。</li>
<li>3.可以比较容易地设计一个组合命令。</li>
<li>4.调用同一方法实现不同的功能</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li>
</ul>
</li>
<li><p>适用情况</p>
<ul>
<li>1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>2.系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
<li>4.系统需要将一组操作组合在一起，即支持宏命令。</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>模拟对电视机的操作有开机、关机、换台命令。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">//执行命令的接口  </div><div class="line">public interface Command &#123;  </div><div class="line">　　void execute();  </div><div class="line">&#125;  </div><div class="line">//命令接收者Receiver  </div><div class="line">public class Tv &#123;  </div><div class="line">　　public int currentChannel = 0;  </div><div class="line">  </div><div class="line">　　public void turnOn() &#123;  </div><div class="line">　　   System.out.println(&quot;The televisino is on.&quot;);  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void turnOff() &#123;  </div><div class="line">　　   System.out.println(&quot;The television is off.&quot;);  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void changeChannel(int channel) &#123;  </div><div class="line">　　   this.currentChannel = channel;  </div><div class="line">　　   System.out.println(&quot;Now TV channel is &quot; + channel);  </div><div class="line">　　&#125;  </div><div class="line">&#125;  </div><div class="line">//开机命令ConcreteCommand  </div><div class="line">public class CommandOn implements Command &#123;  </div><div class="line">　　private Tv myTv;  </div><div class="line">  </div><div class="line">　　public CommandOn(Tv tv) &#123;  </div><div class="line">　　   myTv = tv;  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void execute() &#123;  </div><div class="line">　　   myTv.turnOn();  </div><div class="line">　　&#125;  </div><div class="line">&#125;  </div><div class="line">//关机命令ConcreteCommand  </div><div class="line">public class CommandOff implements Command &#123;  </div><div class="line">　　private Tv myTv;  </div><div class="line">  </div><div class="line">　　public CommandOff(Tv tv) &#123;  </div><div class="line">　　   myTv = tv;  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void execute() &#123;  </div><div class="line">　　   myTv.turnOff();  </div><div class="line">　　&#125;  </div><div class="line">&#125;  </div><div class="line">//频道切换命令ConcreteCommand  </div><div class="line">public class CommandChange implements Command &#123;  </div><div class="line">　　private Tv myTv;  </div><div class="line">  </div><div class="line">　　private int channel;  </div><div class="line">  </div><div class="line">　　public CommandChange(Tv tv, int channel) &#123;  </div><div class="line">　　   myTv = tv;  </div><div class="line"> 　　  this.channel = channel;  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void execute() &#123;  </div><div class="line">　　   myTv.changeChannel(channel);  </div><div class="line">　　&#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">//可以看作是遥控器Invoker  </div><div class="line">public class Control &#123;  </div><div class="line">　　private Command onCommand, offCommand, changeChannel;  </div><div class="line">  </div><div class="line">　　public Control(Command on, Command off, Command channel) &#123;  </div><div class="line"> 　　  onCommand = on;  </div><div class="line"> 　　  offCommand = off;  </div><div class="line">　　   changeChannel = channel;  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void turnOn() &#123;  </div><div class="line">　　   onCommand.execute();  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void turnOff() &#123;  </div><div class="line">　　   offCommand.execute();  </div><div class="line">　　&#125;  </div><div class="line">  </div><div class="line">　　public void changeChannel() &#123;  </div><div class="line"> 　　  changeChannel.execute();  </div><div class="line">　　&#125;  </div><div class="line">&#125;</div><div class="line">//测试类Client  </div><div class="line">public class Client &#123;  </div><div class="line">　　public static void main(String[] args) &#123;  </div><div class="line">  　　 // 命令接收者Receiver  </div><div class="line"> 　　  Tv myTv = new Tv();  </div><div class="line"> 　　  // 开机命令ConcreteCommond  </div><div class="line">  　　 CommandOn on = new CommandOn(myTv);  </div><div class="line">  　　 // 关机命令ConcreteCommond  </div><div class="line">  　　 CommandOff off = new CommandOff(myTv);  </div><div class="line">  　　 // 频道切换命令ConcreteCommond  </div><div class="line"> 　　  CommandChange channel = new CommandChange(myTv, 2);  </div><div class="line"> 　　  // 命令控制对象Invoker  </div><div class="line">　　   Control control = new Control(on, off, channel);  </div><div class="line">  </div><div class="line">  　　 // 开机  </div><div class="line">  　　 control.turnOn();  </div><div class="line"> 　　  // 切换频道  </div><div class="line"> 　　  control.changeChannel();  </div><div class="line"> 　　  // 关机  </div><div class="line"> 　　  control.turnOff();  </div><div class="line">　　&#125;  </div><div class="line">&#125;    </div><div class="line">// 执行结果</div><div class="line">The televisino is on.  </div><div class="line">Now TV channel is 2  </div><div class="line">The television is off.</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>1.命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>2.每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li>
<li>3.命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
<li>4.命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>
<li>5.命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li>
</ul>
</li>
</ul>
<h2 id="15-责任链模式"><a href="#15-责任链模式" class="headerlink" title="15.责任链模式"></a>15.责任链模式</h2><ul>
<li><p>什么是链</p>
<ul>
<li>1、链是一系列节点的集合。</li>
<li>2.、链的各节点可灵活拆分再重组。</li>
</ul>
</li>
<li><p>职责链模式</p>
<ul>
<li>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，</li>
<li>将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</li>
</ul>
</li>
<li><p>角色</p>
<ul>
<li>抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。</li>
<li>具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</li>
</ul>
</li>
<li><p>代码演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">抽象处理者角色</div><div class="line">    public abstract class Handler &#123;  </div><div class="line">          </div><div class="line">        /** </div><div class="line">         * 持有后继的责任对象 </div><div class="line">         */  </div><div class="line">        protected Handler successor;  </div><div class="line">        /** </div><div class="line">         * 示意处理请求的方法，虽然这个示意方法是没有传入参数的 </div><div class="line">         * 但实际是可以传入参数的，根据具体需要来选择是否传递参数 </div><div class="line">         */  </div><div class="line">        public abstract void handleRequest();  </div><div class="line">        /** </div><div class="line">         * 取值方法 </div><div class="line">         */  </div><div class="line">        public Handler getSuccessor() &#123;  </div><div class="line">            return successor;  </div><div class="line">        &#125;  </div><div class="line">        /** </div><div class="line">         * 赋值方法，设置后继的责任对象 </div><div class="line">         */  </div><div class="line">        public void setSuccessor(Handler successor) &#123;  </div><div class="line">            this.successor = successor;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">具体处理者角色</div><div class="line">    public class ConcreteHandler extends Handler &#123;  </div><div class="line">        /** </div><div class="line">         * 处理方法，调用此方法处理请求 </div><div class="line">         */  </div><div class="line">        @Override  </div><div class="line">        public void handleRequest() &#123;  </div><div class="line">            /** </div><div class="line">             * 判断是否有后继的责任对象 </div><div class="line">             * 如果有，就转发请求给后继的责任对象 </div><div class="line">             * 如果没有，则处理请求 </div><div class="line">             */  </div><div class="line">            if(getSuccessor() != null)  </div><div class="line">            &#123;              </div><div class="line">                System.out.println(&quot;放过请求&quot;);  </div><div class="line">                getSuccessor().handleRequest();              </div><div class="line">            &#125;else  </div><div class="line">            &#123;              </div><div class="line">                System.out.println(&quot;处理请求&quot;);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">客户端类</div><div class="line">    public class Client &#123;  </div><div class="line">      </div><div class="line">        public static void main(String[] args) &#123;  </div><div class="line">            //组装责任链  </div><div class="line">            Handler handler1 = new ConcreteHandler();  </div><div class="line">            Handler handler2 = new ConcreteHandler();  </div><div class="line">            handler1.setSuccessor(handler2);  </div><div class="line">            //提交请求  </div><div class="line">            handler1.handleRequest();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">可以看出，客户端创建了两个处理者对象，并指定第一个处理者对象的下家是第二个处理者对象，而第二个处理者对象没有下家。然后客户端将请求传递给第一个处理者对象。</div><div class="line">由于本示例的传递逻辑非常简单：只要有下家，就传给下家处理；如果没有下家，就自行处理。</div><div class="line">因此，第一个处理者对象接到请求后，会将请求传递给第二个处理者对象。由于第二个处理者对象没有下家，于是自行处理请求。</div></pre></td></tr></table></figure>
</li>
<li><p>应用</p>
<ul>
<li>申请聚餐费用的管理，申请聚餐费用的大致流程一般是，由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。申请人只要直接与项目经理交互就可以，其余的工作在黑盒中，究竟流程是怎样的，最后是由谁审批通过的，申请人无需关心。代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line">抽象处理者角色类</div><div class="line">public abstract class Handler &#123;  </div><div class="line">    /** </div><div class="line">     * 持有下一个处理请求的对象 </div><div class="line">     */  </div><div class="line">    protected Handler successor = null;  </div><div class="line">    /** </div><div class="line">     * 取值方法 </div><div class="line">     */  </div><div class="line">    public Handler getSuccessor() &#123;  </div><div class="line">        return successor;  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 设置下一个处理请求的对象 </div><div class="line">     */  </div><div class="line">    public void setSuccessor(Handler successor) &#123;  </div><div class="line">        this.successor = successor;  </div><div class="line">    &#125;  </div><div class="line">    /** </div><div class="line">     * 处理聚餐费用的申请 </div><div class="line">     * @param user    申请人 </div><div class="line">     * @param fee    申请的钱数 </div><div class="line">     * @return        成功或失败的具体通知 </div><div class="line">     */  </div><div class="line">    public abstract String handleFeeRequest(String user , double fee);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">具体处理者角色</div><div class="line">public class ProjectManager extends Handler &#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public String handleFeeRequest(String user, double fee) &#123;  </div><div class="line">          </div><div class="line">        String str = &quot;&quot;;  </div><div class="line">        //项目经理权限比较小，只能在500以内  </div><div class="line">        if(fee &lt; 500)  </div><div class="line">        &#123;  </div><div class="line">            //为了测试，简单点，只同意张三的请求  </div><div class="line">            if(&quot;张三&quot;.equals(user))  </div><div class="line">            &#123;  </div><div class="line">                str = &quot;成功：项目经理同意【&quot; + user + &quot;】的聚餐费用，金额为&quot; + fee + &quot;元&quot;;      </div><div class="line">            &#125;else  </div><div class="line">            &#123;  </div><div class="line">                //其他人一律不同意  </div><div class="line">                str = &quot;失败：项目经理不同意【&quot; + user + &quot;】的聚餐费用，金额为&quot; + fee + &quot;元&quot;;  </div><div class="line">            &#125;  </div><div class="line">        &#125;else  </div><div class="line">        &#123;  </div><div class="line">            //超过500，继续传递给级别更高的人处理  </div><div class="line">            if(getSuccessor() != null)  </div><div class="line">            &#123;  </div><div class="line">                return getSuccessor().handleFeeRequest(user, fee);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return str;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class DeptManager extends Handler &#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public String handleFeeRequest(String user, double fee) &#123;  </div><div class="line">          </div><div class="line">        String str = &quot;&quot;;  </div><div class="line">        //部门经理的权限只能在1000以内  </div><div class="line">        if(fee &lt; 1000)  </div><div class="line">        &#123;  </div><div class="line">            //为了测试，简单点，只同意张三的请求  </div><div class="line">            if(&quot;张三&quot;.equals(user))  </div><div class="line">            &#123;  </div><div class="line">                str = &quot;成功：部门经理同意【&quot; + user + &quot;】的聚餐费用，金额为&quot; + fee + &quot;元&quot;;      </div><div class="line">            &#125;else  </div><div class="line">            &#123;  </div><div class="line">                //其他人一律不同意  </div><div class="line">                str = &quot;失败：部门经理不同意【&quot; + user + &quot;】的聚餐费用，金额为&quot; + fee + &quot;元&quot;;  </div><div class="line">            &#125;  </div><div class="line">        &#125;else  </div><div class="line">        &#123;  </div><div class="line">            //超过1000，继续传递给级别更高的人处理  </div><div class="line">            if(getSuccessor() != null)  </div><div class="line">            &#123;  </div><div class="line">                return getSuccessor().handleFeeRequest(user, fee);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return str;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class GeneralManager extends Handler &#123;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public String handleFeeRequest(String user, double fee) &#123;  </div><div class="line">          </div><div class="line">        String str = &quot;&quot;;  </div><div class="line">        //总经理的权限很大，只要请求到了这里，他都可以处理  </div><div class="line">        if(fee &gt;= 1000)  </div><div class="line">        &#123;  </div><div class="line">            //为了测试，简单点，只同意张三的请求  </div><div class="line">            if(&quot;张三&quot;.equals(user))  </div><div class="line">            &#123;  </div><div class="line">                str = &quot;成功：总经理同意【&quot; + user + &quot;】的聚餐费用，金额为&quot; + fee + &quot;元&quot;;      </div><div class="line">            &#125;else  </div><div class="line">            &#123;  </div><div class="line">                //其他人一律不同意  </div><div class="line">                str = &quot;失败：总经理不同意【&quot; + user + &quot;】的聚餐费用，金额为&quot; + fee + &quot;元&quot;;  </div><div class="line">            &#125;  </div><div class="line">        &#125;else  </div><div class="line">        &#123;  </div><div class="line">            //如果还有后继的处理对象，继续传递  </div><div class="line">            if(getSuccessor() != null)  </div><div class="line">            &#123;  </div><div class="line">                return getSuccessor().handleFeeRequest(user, fee);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return str;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">客户端类</div><div class="line">public class Client &#123;  </div><div class="line">  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        //先要组装责任链  </div><div class="line">        Handler h1 = new GeneralManager();  </div><div class="line">        Handler h2 = new DeptManager();  </div><div class="line">        Handler h3 = new ProjectManager();  </div><div class="line">        h3.setSuccessor(h2);  </div><div class="line">        h2.setSuccessor(h1);  </div><div class="line">          </div><div class="line">        //开始测试  </div><div class="line">        String test1 = h3.handleFeeRequest(&quot;张三&quot;, 300);  </div><div class="line">        System.out.println(&quot;test1 = &quot; + test1);  </div><div class="line">        String test2 = h3.handleFeeRequest(&quot;李四&quot;, 300);  </div><div class="line">        System.out.println(&quot;test2 = &quot; + test2);  </div><div class="line">        System.out.println(&quot;---------------------------------------&quot;);  </div><div class="line">          </div><div class="line">        String test3 = h3.handleFeeRequest(&quot;张三&quot;, 700);  </div><div class="line">        System.out.println(&quot;test3 = &quot; + test3);  </div><div class="line">        String test4 = h3.handleFeeRequest(&quot;李四&quot;, 700);  </div><div class="line">        System.out.println(&quot;test4 = &quot; + test4);  </div><div class="line">        System.out.println(&quot;---------------------------------------&quot;);  </div><div class="line">          </div><div class="line">        String test5 = h3.handleFeeRequest(&quot;张三&quot;, 1500);  </div><div class="line">        System.out.println(&quot;test5 = &quot; + test5);  </div><div class="line">        String test6 = h3.handleFeeRequest(&quot;李四&quot;, 1500);  </div><div class="line">        System.out.println(&quot;test6 = &quot; + test6);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>职责链灵活在哪</p>
<ul>
<li><ol>
<li>改变内部的传递规则<ul>
<li>在内部，项目经理完全可以跳过人事部到那一关直接找到总经理。</li>
<li>每个人都可以去动态地指定他的继任者。</li>
</ul>
</li>
</ol>
</li>
<li><ol>
<li>可以从职责链任何一关开始。<ul>
<li>如果项目经理不在，可以直接去找部门经理，责任链还会继续，没有影响。</li>
</ul>
</li>
</ol>
</li>
<li>3.用与不用的区别<ul>
<li>不用职责链的结构，我们需要和公司中的每一个层级都发生耦合关系。</li>
<li>如果反映在代码上即使我们需要在一个类中去写上很多丑陋的if….else语句。</li>
<li>如果用了职责链，相当于我们面对的是一个黑箱，我们只需要认识其中的一个部门，然后让黑箱内部去负责传递就好了</li>
</ul>
</li>
</ul>
</li>
<li><p>纯的与不纯的责任链模式</p>
<ul>
<li>一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。</li>
<li>在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</li>
<li>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。<h2 id="16-迭代器模式"><a href="#16-迭代器模式" class="headerlink" title="16.迭代器模式"></a>16.迭代器模式</h2></li>
</ul>
</li>
<li>定义：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。</li>
<li>类型：行为类模式</li>
<li>如果要问Java中使用最多的一种模式，答案不是单例模式，也不是工厂模式，更不是策略模式，而是迭代器模式，先来看一段代码吧：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    public static void print(Collection coll)&#123;  </div><div class="line">        Iterator it = coll.iterator();  </div><div class="line">        while(it.hasNext())&#123;  </div><div class="line">            String str = (String)it.next();  </div><div class="line">            System.out.println(str);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">这个方法的作用是循环打印一个字符串集合，里面就用到了迭代器模式，java语言已经完整地实现了迭代器模式，Iterator翻译成汉语就是迭代器的意思。提到迭代器，首先它是与集合相关的，集合也叫聚集、容器等，我们可以将集合看成是一个可以包容对象的容器，例如List，Set，Map，甚至数组都可以叫做集合，而迭代器的作用就是把容器中的对象一个一个地遍历出来。</div></pre></td></tr></table></figure>
<ul>
<li>迭代器模式的结构<ul>
<li>抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。</li>
<li>具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。</li>
<li>抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),</li>
<li>迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。</li>
</ul>
</li>
</ul>
<ul>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface Iterator &#123;  </div><div class="line">    public Object next();  </div><div class="line">    public boolean hasNext();  </div><div class="line">&#125;  </div><div class="line">class ConcreteIterator implements Iterator&#123;  </div><div class="line">    private List list = new ArrayList();  </div><div class="line">    private int cursor =0;  </div><div class="line">    public ConcreteIterator(List list)&#123;  </div><div class="line">        this.list = list;  </div><div class="line">    &#125;  </div><div class="line">    public boolean hasNext() &#123;  </div><div class="line">        if(cursor==list.size())&#123;  </div><div class="line">            return false;  </div><div class="line">        &#125;  </div><div class="line">        return true;  </div><div class="line">    &#125;  </div><div class="line">    public Object next() &#123;  </div><div class="line">        Object obj = null;  </div><div class="line">        if(this.hasNext())&#123;  </div><div class="line">            obj = this.list.get(cursor++);  </div><div class="line">        &#125;  </div><div class="line">        return obj;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">interface Aggregate &#123;  </div><div class="line">    public void add(Object obj);  </div><div class="line">    public void remove(Object obj);  </div><div class="line">    public Iterator iterator();  </div><div class="line">&#125;  </div><div class="line">class ConcreteAggregate implements Aggregate &#123;  </div><div class="line">    private List list = new ArrayList();  </div><div class="line">    public void add(Object obj) &#123;  </div><div class="line">        list.add(obj);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public Iterator iterator() &#123;  </div><div class="line">        return new ConcreteIterator(list);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public void remove(Object obj) &#123;  </div><div class="line">        list.remove(obj);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">public class Client &#123;  </div><div class="line">    public static void main(String[] args)&#123;  </div><div class="line">        Aggregate ag = new ConcreteAggregate();  </div><div class="line">        ag.add(&quot;小明&quot;);  </div><div class="line">        ag.add(&quot;小红&quot;);  </div><div class="line">        ag.add(&quot;小刚&quot;);  </div><div class="line">        Iterator it = ag.iterator();  </div><div class="line">        while(it.hasNext())&#123;  </div><div class="line">            String str = (String)it.next();  </div><div class="line">            System.out.println(str);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">上面的代码中，Aggregate是容器类接口，大家可以想象一下Collection，List，Set等，Aggregate就是他们的简化版，容器类接口中主要有三个方法：添加对象方法add、删除对象方法remove、取得迭代器方法iterator。Iterator是迭代器接口，主要有两个方法：取得迭代对象方法next，判断是否迭代完成方法hasNext，大家可以对比java.util.List和java.util.Iterator两个接口自行思考。</div></pre></td></tr></table></figure>
</li>
<li><p>迭代器模式的优缺点</p>
<ul>
<li>迭代器模式的优点有：<ul>
<li>简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。</li>
<li>可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。</li>
<li>封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</li>
</ul>
</li>
<li>迭代器模式的缺点：<ul>
<li>对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。</li>
</ul>
</li>
</ul>
</li>
<li><p>迭代器模式的适用场景</p>
<ul>
<li>迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。</li>
</ul>
</li>
</ul>
<h2 id="17-组合模式"><a href="#17-组合模式" class="headerlink" title="17.组合模式"></a>17.组合模式</h2><ul>
<li><p>组合模式的定义吧：“将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。”就拿剪发办卡的事情来分析一下吧。首先，一张卡可以在总部，分店，加盟店使用，那么总部可以刷卡，分店也可以刷卡，加盟店也可以刷卡，这个属性结构的店面层级关系就明确啦。那么，总店刷卡消费与分店刷卡消费是一样的道理，那么总店与分店对会员卡的使用也具有一致性。</p>
<ul>
<li>组合模式的一个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">    import java.util.ArrayList;  </div><div class="line">    import java.util.List;  </div><div class="line">      </div><div class="line">    public class ComponentDemo &#123;  </div><div class="line">        public abstract class Component &#123;  </div><div class="line">            String name;  </div><div class="line">      </div><div class="line">            public abstract void add(Component c);  </div><div class="line">      </div><div class="line">            public abstract void remove(Component c);  </div><div class="line">      </div><div class="line">            public abstract void eachChild();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        // 组合部件类  </div><div class="line">        public class Leaf extends Component &#123;  </div><div class="line">      </div><div class="line">            // 叶子节点不具备添加的能力，所以不实现  </div><div class="line">            @Override  </div><div class="line">            public void add(Component c) &#123;  </div><div class="line">                // TODO Auto-generated method stub  </div><div class="line">                System.out.println(&quot;&quot;);  </div><div class="line">            &#125;  </div><div class="line">      </div><div class="line">            // 叶子节点不具备添加的能力必然也不能删除  </div><div class="line">            @Override  </div><div class="line">            public void remove(Component c) &#123;  </div><div class="line">                // TODO Auto-generated method stub  </div><div class="line">                System.out.println(&quot;&quot;);  </div><div class="line">            &#125;  </div><div class="line">      </div><div class="line">            // 叶子节点没有子节点所以显示自己的执行结果  </div><div class="line">            @Override  </div><div class="line">            public void eachChild() &#123;  </div><div class="line">                // TODO Auto-generated method stub  </div><div class="line">                System.out.println(name + &quot;执行了&quot;);  </div><div class="line">            &#125;  </div><div class="line">      </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        // 组合类  </div><div class="line">        public class Composite extends Component &#123;  </div><div class="line">      </div><div class="line">            // 用来保存节点的子节点  </div><div class="line">            List&lt;Component&gt; list = new ArrayList&lt;Component&gt;();  </div><div class="line">      </div><div class="line">            // 添加节点 添加部件  </div><div class="line">            @Override  </div><div class="line">            public void add(Component c) &#123;  </div><div class="line">                // TODO Auto-generated method stub  </div><div class="line">                list.add(c);  </div><div class="line">            &#125;  </div><div class="line">      </div><div class="line">            // 删除节点 删除部件  </div><div class="line">            @Override  </div><div class="line">            public void remove(Component c) &#123;  </div><div class="line">                // TODO Auto-generated method stub  </div><div class="line">                list.remove(c);  </div><div class="line">            &#125;  </div><div class="line">      </div><div class="line">            // 遍历子节点  </div><div class="line">            @Override  </div><div class="line">            public void eachChild() &#123;  </div><div class="line">                // TODO Auto-generated method stub  </div><div class="line">                System.out.println(name + &quot;执行了&quot;);  </div><div class="line">                for (Component c : list) &#123;  </div><div class="line">                    c.eachChild();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">        public static void main(String[] args) &#123;  </div><div class="line">            ComponentDemo demo = new ComponentDemo();  </div><div class="line">            // 构造根节点  </div><div class="line">            Composite rootComposite = demo.new Composite();  </div><div class="line">            rootComposite.name = &quot;根节点&quot;;  </div><div class="line">      </div><div class="line">            // 左节点  </div><div class="line">            Composite compositeLeft = demo.new Composite();  </div><div class="line">            compositeLeft.name = &quot;左节点&quot;;  </div><div class="line">      </div><div class="line">            // 构建右节点，添加两个叶子几点，也就是子部件  </div><div class="line">            Composite compositeRight = demo.new Composite();  </div><div class="line">            compositeRight.name = &quot;右节点&quot;;  </div><div class="line">            Leaf leaf1 = demo.new Leaf();  </div><div class="line">            leaf1.name = &quot;右-子节点1&quot;;  </div><div class="line">            Leaf leaf2 = demo.new Leaf();  </div><div class="line">            leaf2.name = &quot;右-子节点2&quot;;  </div><div class="line">            compositeRight.add(leaf1);  </div><div class="line">            compositeRight.add(leaf2);  </div><div class="line">      </div><div class="line">            // 左右节点加入 根节点  </div><div class="line">            rootComposite.add(compositeRight);  </div><div class="line">            rootComposite.add(compositeLeft);  </div><div class="line">            // 遍历组合部件  </div><div class="line">            rootComposite.eachChild();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">//执行结果如下:</div><div class="line">根节点执行了</div><div class="line">右节点执行了</div><div class="line">右-子节点1执行了</div><div class="line">右-子节点2执行了</div><div class="line">左节点执行了</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2.应用组合模式的会员卡消费</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">那么我们就根据我们会员卡的消费，来模拟一下组合模式的实现吧！let&apos;s Go！</div><div class="line">首先：</div><div class="line">       1.我们的部件有，总店，分店，加盟店！</div><div class="line">       2.我们的部件共有的行为是：刷会员卡</div><div class="line">       3.部件之间的层次关系，也就是店面的层次关系是，总店下有分店、分店下可以拥有加盟店。</div><div class="line">有了我们这几个必要条件后，我的要求就是目前店面搞活动当我在总店刷卡后，就可以累积相当于在所有下级店面刷卡的积分总额，设计的代码如下：</div><div class="line">import java.util.ArrayList;  </div><div class="line">import java.util.List;  </div><div class="line">  </div><div class="line">public class PayDemo &#123;  </div><div class="line">    public abstract class Market &#123;  </div><div class="line">        String name;  </div><div class="line">        public abstract void add(Market m);  </div><div class="line">        public abstract void remove(Market m);  </div><div class="line">        public abstract void PayByCard();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    // 分店 下面可以有加盟店  </div><div class="line">    public class MarketBranch extends Market &#123;  </div><div class="line">        // 加盟店列表  </div><div class="line">        List&lt;Market&gt; list = new ArrayList&lt;PayDemo.Market&gt;();  </div><div class="line">  </div><div class="line">        public MarketBranch(String s) &#123;  </div><div class="line">            this.name = s;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        public void add(Market m) &#123;  </div><div class="line">            // TODO Auto-generated method stub  </div><div class="line">            list.add(m);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        public void remove(Market m) &#123;  </div><div class="line">            // TODO Auto-generated method stub  </div><div class="line">            list.remove(m);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        // 消费之后，该分店下的加盟店自动累加积分  </div><div class="line">        @Override  </div><div class="line">        public void PayByCard() &#123;  </div><div class="line">            // TODO Auto-generated method stub  </div><div class="line">            System.out.println(name + &quot;消费,积分已累加入该会员卡&quot;);  </div><div class="line">            for (Market m : list) &#123;  </div><div class="line">                m.PayByCard();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    // 加盟店 下面不在有分店和加盟店，最底层  </div><div class="line">    public class MarketJoin extends Market &#123;  </div><div class="line">        public MarketJoin(String s) &#123;  </div><div class="line">            this.name = s;  </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        public void add(Market m) &#123;  </div><div class="line">            // TODO Auto-generated method stub  </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        public void remove(Market m) &#123;  </div><div class="line">            // TODO Auto-generated method stub  </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        public void PayByCard() &#123;  </div><div class="line">            // TODO Auto-generated method stub  </div><div class="line">            System.out.println(name + &quot;消费,积分已累加入该会员卡&quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        PayDemo demo = new PayDemo();  </div><div class="line">          </div><div class="line">        MarketBranch rootBranch = demo.new MarketBranch(&quot;总店&quot;);  </div><div class="line">        MarketBranch qhdBranch = demo.new MarketBranch(&quot;秦皇岛分店&quot;);  </div><div class="line">        MarketJoin hgqJoin = demo.new MarketJoin(&quot;秦皇岛分店一海港区加盟店&quot;);  </div><div class="line">        MarketJoin btlJoin = demo.new MarketJoin(&quot;秦皇岛分店二白塔岭加盟店&quot;);  </div><div class="line">          </div><div class="line">        qhdBranch.add(hgqJoin);  </div><div class="line">        qhdBranch.add(btlJoin);  </div><div class="line">        rootBranch.add(qhdBranch);  </div><div class="line">        rootBranch.PayByCard();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">运行结果如下：</div><div class="line">总店消费，积分已累计加入该会员卡</div><div class="line">秦皇岛分店消费，积分已累加入该会员卡</div><div class="line">秦皇岛分店一海港区加盟店消费，积分已累加入该会员卡</div><div class="line">秦皇岛分店二白塔岭加盟店，积分已加入该会员卡</div><div class="line"></div><div class="line">这样在累积所有子店面积分的时候，就不需要去关心子店面的个数了，也不用关系是否是叶子节点还是组合节点了，也就是说不管是总店刷卡，还是加盟店刷卡，都可以正确有效的计算出活动积分。</div></pre></td></tr></table></figure>
</li>
<li><p>3.什么情况下使用组合模式</p>
<ul>
<li>引用大话设计模式的片段：“当发现需求中是体现部分与整体层次结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。”</li>
</ul>
</li>
</ul>
<h2 id="18-门面模式（外观模式）"><a href="#18-门面模式（外观模式）" class="headerlink" title="18.门面模式（外观模式）"></a>18.门面模式（外观模式）</h2><p>-引言：医院的例子</p>
<pre><code>- 现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。
- 解决这种不便的方法便是引进门面模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员与各个部门打交道。
</code></pre><ul>
<li><p>门面模式的结构</p>
<ul>
<li>门面模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。</li>
<li>由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，出现了两个角色：<ul>
<li>门面(Facade)角色 ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。</li>
<li>子系统(SubSystem)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。</li>
</ul>
</li>
<li>源代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">子系统角色中的类：</div><div class="line">    public class ModuleA &#123;  </div><div class="line">        //示意方法  </div><div class="line">        public void testA()&#123;  </div><div class="line">            System.out.println(&quot;调用ModuleA中的testA方法&quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public class ModuleB &#123;  </div><div class="line">        //示意方法  </div><div class="line">        public void testB()&#123;  </div><div class="line">            System.out.println(&quot;调用ModuleB中的testB方法&quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public class ModuleC &#123;  </div><div class="line">        //示意方法  </div><div class="line">        public void testC()&#123;  </div><div class="line">            System.out.println(&quot;调用ModuleC中的testC方法&quot;);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">门面角色类：</div><div class="line">    public class Facade &#123;  </div><div class="line">        //示意方法，满足客户端需要的功能  </div><div class="line">        public void test()&#123;  </div><div class="line">            ModuleA a = new ModuleA();  </div><div class="line">            a.testA();  </div><div class="line">            ModuleB b = new ModuleB();  </div><div class="line">            b.testB();  </div><div class="line">            ModuleC c = new ModuleC();  </div><div class="line">            c.testC();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">客户端角色类：</div><div class="line"></div><div class="line">    public class Client &#123;  </div><div class="line">      </div><div class="line">        public static void main(String[] args) &#123;  </div><div class="line">              </div><div class="line">            Facade facade = new Facade();  </div><div class="line">            facade.test();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">Facade类其实相当于A、B、C模块的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的A、B、C模块了，也不需要知道系统内部的实现细节，甚至都不需要知道A、B、C模块的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中A、B、C模块的解耦，让客户端更容易地使用系统。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>门面模式的实现</p>
<ul>
<li>使用门面模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。比如，定义如下A、B、C模块。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">   public class Module &#123;  </div><div class="line">       /** </div><div class="line">        * 提供给子系统外部使用的方法 </div><div class="line">        */  </div><div class="line">       public void a1()&#123;&#125;;  </div><div class="line">         </div><div class="line">       /** </div><div class="line">        * 子系统内部模块之间相互调用时使用的方法 </div><div class="line">        */  </div><div class="line">       private void a2()&#123;&#125;;  </div><div class="line">       private void a3()&#123;&#125;;  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line"></div><div class="line">   public class ModuleB &#123;  </div><div class="line">       /** </div><div class="line">        * 提供给子系统外部使用的方法 </div><div class="line">        */  </div><div class="line">       public void b1()&#123;&#125;;  </div><div class="line">         </div><div class="line">       /** </div><div class="line">        * 子系统内部模块之间相互调用时使用的方法 </div><div class="line">        */  </div><div class="line">       private void b2()&#123;&#125;;  </div><div class="line">       private void b3()&#123;&#125;;  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   public class ModuleC &#123;  </div><div class="line">       /** </div><div class="line">        * 提供给子系统外部使用的方法 </div><div class="line">        */  </div><div class="line">       public void c1()&#123;&#125;;  </div><div class="line">         </div><div class="line">       /** </div><div class="line">        * 子系统内部模块之间相互调用时使用的方法 </div><div class="line">        */  </div><div class="line">       private void c2()&#123;&#125;;  </div><div class="line">       private void c3()&#123;&#125;;  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   public class ModuleFacade &#123;  </div><div class="line">         </div><div class="line">       ModuleA a = new ModuleA();  </div><div class="line">       ModuleB b = new ModuleB();  </div><div class="line">       ModuleC c = new ModuleC();  </div><div class="line">       /** </div><div class="line">        * 下面这些是A、B、C模块对子系统外部提供的方法 </div><div class="line">        */  </div><div class="line">       public void a1()&#123;  </div><div class="line">           a.a1();  </div><div class="line">       &#125;  </div><div class="line">       public void b1()&#123;  </div><div class="line">           b.b1();  </div><div class="line">       &#125;  </div><div class="line">       public void c1()&#123;  </div><div class="line">           c.c1();  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。对客户端来说，他可能还要去思考a2()、a3()方法用来干什么呢？其实a2()和a3()方法是内部模块之间交互的，原本就不是对子系统外部的，所以干脆就不要让客户端知道。</div></pre></td></tr></table></figure>
<ul>
<li><p>一个系统可以有几个门面类<br>　　- 在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。为子系统增加新行为<br>　　- 初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。</p>
</li>
<li><p>门面模式的优点：</p>
<ul>
<li>松散耦合</li>
</ul>
</li>
</ul>
<p>　　        - 门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</p>
<p>　　- 简单易用</p>
<p>　　        - 门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。</p>
<p>　　- 更好的划分访问层次</p>
<p>　　        - 通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。</p>
<h2 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19.备忘录模式"></a>19.备忘录模式</h2><ul>
<li>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态<ul>
<li>我们在编程的时候，经常需要保存对象的中间状态，当需要的时候，可以恢复到这个状态。比如，我们使用Eclipse进行编程时，假如编写失误（例如不小心误删除了几行代码），我们希望返回删除前的状态，便可以使用Ctrl+Z来进行返回。这时我们便可以使用备忘录模式来实现。</li>
</ul>
</li>
<li>备忘录模式的结构<ul>
<li>发起人：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</li>
<li>备忘录：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</li>
<li>管理角色：对备忘录进行管理，保存和提供备忘录。</li>
</ul>
</li>
</ul>
<ul>
<li><p>通用代码实现<br>  -单状态单备份备忘录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line">   class Originator &#123;  </div><div class="line">       private String state = &quot;&quot;;  </div><div class="line">         </div><div class="line">       public String getState() &#123;  </div><div class="line">           return state;  </div><div class="line">       &#125;  </div><div class="line">       public void setState(String state) &#123;  </div><div class="line">           this.state = state;  </div><div class="line">       &#125;  </div><div class="line">       public Memento createMemento()&#123;  </div><div class="line">           return new Memento(this.state);  </div><div class="line">       &#125;  </div><div class="line">       public void restoreMemento(Memento memento)&#123;  </div><div class="line">           this.setState(memento.getState());  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">     </div><div class="line">   class Memento &#123;  </div><div class="line">       private String state = &quot;&quot;;  </div><div class="line">       public Memento(String state)&#123;  </div><div class="line">           this.state = state;  </div><div class="line">       &#125;  </div><div class="line">       public String getState() &#123;  </div><div class="line">           return state;  </div><div class="line">       &#125;  </div><div class="line">       public void setState(String state) &#123;  </div><div class="line">           this.state = state;  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">   class Caretaker &#123;  </div><div class="line">       private Memento memento;  </div><div class="line">       public Memento getMemento()&#123;  </div><div class="line">           return memento;  </div><div class="line">       &#125;  </div><div class="line">       public void setMemento(Memento memento)&#123;  </div><div class="line">           this.memento = memento;  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">   public class Client &#123;  </div><div class="line">       public static void main(String[] args)&#123;  </div><div class="line">           Originator originator = new Originator();  </div><div class="line">           originator.setState(&quot;状态1&quot;);  </div><div class="line">           System.out.println(&quot;初始状态:&quot;+originator.getState());  </div><div class="line">           Caretaker caretaker = new Caretaker();  </div><div class="line">           caretaker.setMemento(originator.createMemento());  </div><div class="line">           originator.setState(&quot;状态2&quot;);  </div><div class="line">           System.out.println(&quot;改变后状态:&quot;+originator.getState());  </div><div class="line">           originator.restoreMemento(caretaker.getMemento());  </div><div class="line">           System.out.println(&quot;恢复后状态:&quot;+originator.getState());  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">       代码演示了一个单状态单备份的例子，逻辑非常简单：Originator类中的state变量需要备份，以便在需要的时候恢复；Memento类中，也有一个state变量，用来存储Originator类中state变量的临时状态；而Caretaker类就是用来管理备忘录类的，用来向备忘录对象中写入状态或者取回状态。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   多状态多备份备忘录</div><div class="line">通用代码演示的例子中，Originator类只有一个state变量需要备份，而通常情况下，发起人角色通常是一个javaBean，对象中需要备份的变量不止一个，需要备份的状态也不止一个，这就是多状态多备份备忘录。实现备忘录的方法很多，备忘录模式有很多变形和处理方式，像通用代码那样的方式一般不会用到，多数情况下的备忘录模式，是多状态多备份的。其实实现多状态多备份也很简单，最常用的方法是，我们在Memento中增加一个Map容器来存储所有的状态，在Caretaker类中同样使用一个Map容器才存储所有的备份。下面我们给出一个多状态多备份的例子：</div><div class="line"></div><div class="line">   class Originator &#123;  </div><div class="line">       private String state1 = &quot;&quot;;  </div><div class="line">       private String state2 = &quot;&quot;;  </div><div class="line">       private String state3 = &quot;&quot;;  </div><div class="line">     </div><div class="line">       public String getState1() &#123;  </div><div class="line">           return state1;  </div><div class="line">       &#125;  </div><div class="line">       public void setState1(String state1) &#123;  </div><div class="line">           this.state1 = state1;  </div><div class="line">       &#125;  </div><div class="line">       public String getState2() &#123;  </div><div class="line">           return state2;  </div><div class="line">       &#125;  </div><div class="line">       public void setState2(String state2) &#123;  </div><div class="line">           this.state2 = state2;  </div><div class="line">       &#125;  </div><div class="line">       public String getState3() &#123;  </div><div class="line">           return state3;  </div><div class="line">       &#125;  </div><div class="line">       public void setState3(String state3) &#123;  </div><div class="line">           this.state3 = state3;  </div><div class="line">       &#125;  </div><div class="line">       public Memento createMemento()&#123;  </div><div class="line">           return new Memento(BeanUtils.backupProp(this));  </div><div class="line">       &#125;  </div><div class="line">         </div><div class="line">       public void restoreMemento(Memento memento)&#123;  </div><div class="line">           BeanUtils.restoreProp(this, memento.getStateMap());  </div><div class="line">       &#125;  </div><div class="line">       public String toString()&#123;  </div><div class="line">           return &quot;state1=&quot;+state1+&quot;state2=&quot;+state2+&quot;state3=&quot;+state3;  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">   class Memento &#123;  </div><div class="line">       private Map&lt;String, Object&gt; stateMap;  </div><div class="line">         </div><div class="line">       public Memento(Map&lt;String, Object&gt; map)&#123;  </div><div class="line">           this.stateMap = map;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       public Map&lt;String, Object&gt; getStateMap() &#123;  </div><div class="line">           return stateMap;  </div><div class="line">       &#125;  </div><div class="line">     </div><div class="line">       public void setStateMap(Map&lt;String, Object&gt; stateMap) &#123;  </div><div class="line">           this.stateMap = stateMap;  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">   class BeanUtils &#123;  </div><div class="line">       public static Map&lt;String, Object&gt; backupProp(Object bean)&#123;  </div><div class="line">           Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();  </div><div class="line">           try&#123;  </div><div class="line">               BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());  </div><div class="line">               PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();  </div><div class="line">               for(PropertyDescriptor des: descriptors)&#123;  </div><div class="line">                   String fieldName = des.getName();  </div><div class="line">                   Method getter = des.getReadMethod();  </div><div class="line">                   Object fieldValue = getter.invoke(bean, new Object[]&#123;&#125;);  </div><div class="line">                   if(!fieldName.equalsIgnoreCase(&quot;class&quot;))&#123;  </div><div class="line">                       result.put(fieldName, fieldValue);  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">                 </div><div class="line">           &#125;catch(Exception e)&#123;  </div><div class="line">               e.printStackTrace();  </div><div class="line">           &#125;  </div><div class="line">           return result;  </div><div class="line">       &#125;  </div><div class="line">         </div><div class="line">       public static void restoreProp(Object bean, Map&lt;String, Object&gt; propMap)&#123;  </div><div class="line">           try &#123;  </div><div class="line">               BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());  </div><div class="line">               PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();  </div><div class="line">               for(PropertyDescriptor des: descriptors)&#123;  </div><div class="line">                   String fieldName = des.getName();  </div><div class="line">                   if(propMap.containsKey(fieldName))&#123;  </div><div class="line">                       Method setter = des.getWriteMethod();  </div><div class="line">                       setter.invoke(bean, new Object[]&#123;propMap.get(fieldName)&#125;);  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">           &#125; catch (Exception e) &#123;  </div><div class="line">               e.printStackTrace();  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">   class Caretaker &#123;  </div><div class="line">       private Map&lt;String, Memento&gt; memMap = new HashMap&lt;String, Memento&gt;();  </div><div class="line">       public Memento getMemento(String index)&#123;  </div><div class="line">           return memMap.get(index);  </div><div class="line">       &#125;  </div><div class="line">         </div><div class="line">       public void setMemento(String index, Memento memento)&#123;  </div><div class="line">           this.memMap.put(index, memento);  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">   class Client &#123;  </div><div class="line">       public static void main(String[] args)&#123;  </div><div class="line">           Originator ori = new Originator();  </div><div class="line">           Caretaker caretaker = new Caretaker();  </div><div class="line">           ori.setState1(&quot;中国&quot;);  </div><div class="line">           ori.setState2(&quot;强盛&quot;);  </div><div class="line">           ori.setState3(&quot;繁荣&quot;);  </div><div class="line">           System.out.println(&quot;===初始化状态===\n&quot;+ori);  </div><div class="line">             </div><div class="line">           caretaker.setMemento(&quot;001&quot;,ori.createMemento());  </div><div class="line">           ori.setState1(&quot;软件&quot;);  </div><div class="line">           ori.setState2(&quot;架构&quot;);  </div><div class="line">           ori.setState3(&quot;优秀&quot;);  </div><div class="line">           System.out.println(&quot;===修改后状态===\n&quot;+ori);  </div><div class="line">             </div><div class="line">           ori.restoreMemento(caretaker.getMemento(&quot;001&quot;));  </div><div class="line">           System.out.println(&quot;===恢复后状态===\n&quot;+ori);  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>备忘录模式的优缺点和适用场景</p>
<ul>
<li>备忘录模式的优点有：<ul>
<li>当发起人角色中的状态改变时，有可能这是个错误的改变，我们使用备忘录模式就可以把这个错误的改变还原。备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。</li>
</ul>
</li>
<li>备忘录模式的缺点：<ul>
<li>在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的。<br>-如果有需要提供回滚操作的需求，使用备忘录模式非常适合，比如jdbc的事务操作，文本编辑器的Ctrl+Z恢复等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="20-访问者模式"><a href="#20-访问者模式" class="headerlink" title="20.访问者模式"></a>20.访问者模式</h2><ul>
<li><p>定义</p>
<ul>
<li>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class A &#123;    </div><div class="line">    public void method1()&#123;    </div><div class="line">        System.out.println(&quot;我是A&quot;);    </div><div class="line">    &#125;    </div><div class="line">        </div><div class="line">    public void method2(B b)&#123;    </div><div class="line">        b.showA(this);    </div><div class="line">    &#125;    </div><div class="line">&#125;    </div><div class="line">    </div><div class="line">class B &#123;    </div><div class="line">    public void showA(A a)&#123;    </div><div class="line">        a.method1();    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>看一下在类A中，方法method1和方法method2的区别在哪里，方法method1很简单，就是打印出一句“我是A”；方法method2稍微复杂一点，使用类B作为参数，并调用类B的showA方法。再来看一下类B的showA方法，showA方法使用类A作为参数，然后调用类A的method1方法，可以看到，method2方法绕来绕去，无非就是调用了一下自己的method1方法而已，它的运行结果应该也是“我是A”，分析完之后，我们来运行一下这两个方法，并看一下运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    public class Test &#123;    </div><div class="line">        public static void main(String[] args)&#123;    </div><div class="line">            A a = new A();    </div><div class="line">            a.method1();    </div><div class="line">            a.method2(new B());    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">运行结果为：</div><div class="line">我是A</div><div class="line">我是A</div></pre></td></tr></table></figure>
</li>
<li><p>角色</p>
<ul>
<li>在例子中，对于类A来说，类B就是一个访问者。</li>
<li>抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。</li>
<li>访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。</li>
<li>抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。</li>
<li>元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。</li>
<li>结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">抽象元素类</div><div class="line"></div><div class="line">    abstract class Element &#123;    </div><div class="line">        public abstract void accept(IVisitor visitor);    </div><div class="line">        public abstract void doSomething();    </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">元素类</div><div class="line"></div><div class="line"></div><div class="line">    class ConcreteElement1 extends Element &#123;    </div><div class="line">        public void doSomething()&#123;    </div><div class="line">            System.out.println(&quot;这是元素1&quot;);    </div><div class="line">        &#125;    </div><div class="line">            </div><div class="line">        public void accept(IVisitor visitor) &#123;    </div><div class="line">            visitor.visit(this);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">        </div><div class="line">    class ConcreteElement2 extends Element &#123;    </div><div class="line">        public void doSomething()&#123;    </div><div class="line">            System.out.println(&quot;这是元素2&quot;);    </div><div class="line">        &#125;    </div><div class="line">            </div><div class="line">        public void accept(IVisitor visitor) &#123;    </div><div class="line">            visitor.visit(this);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">抽象访问者</div><div class="line"></div><div class="line"></div><div class="line">    interface IVisitor &#123;    </div><div class="line">        public void visit(ConcreteElement1 el1);    </div><div class="line">        public void visit(ConcreteElement2 el2);    </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">访问者</div><div class="line"></div><div class="line"></div><div class="line">    class Visitor implements IVisitor &#123;    </div><div class="line">        </div><div class="line">        public void visit(ConcreteElement1 el1) &#123;    </div><div class="line">            el1.doSomething();    </div><div class="line">        &#125;    </div><div class="line">            </div><div class="line">        public void visit(ConcreteElement2 el2) &#123;    </div><div class="line">            el2.doSomething();    </div><div class="line">        &#125;    </div><div class="line">    &#125;   </div><div class="line"></div><div class="line">结构对象</div><div class="line"></div><div class="line">    class ObjectStruture &#123;    </div><div class="line">        public static List&lt;Element&gt; getList()&#123;    </div><div class="line">            List&lt;Element&gt; list = new ArrayList&lt;Element&gt;();    </div><div class="line">            Random ran = new Random();    </div><div class="line">            for(int i=0; i&lt;10; i++)&#123;    </div><div class="line">                int a = ran.nextInt(100);    </div><div class="line">                if(a&gt;50)&#123;    </div><div class="line">                    list.add(new ConcreteElement1());    </div><div class="line">                &#125;else&#123;    </div><div class="line">                    list.add(new ConcreteElement2());    </div><div class="line">                &#125;    </div><div class="line">            &#125;    </div><div class="line">            return list;    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">客户端</div><div class="line"></div><div class="line"></div><div class="line">    public class Client &#123;    </div><div class="line">        public static void main(String[] args)&#123;    </div><div class="line">            List&lt;Element&gt; list = ObjectStruture.getList();    </div><div class="line">            for(Element e: list)&#123;    </div><div class="line">                e.accept(new Visitor());    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。</li>
<li>扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>增加新的元素类比较困难。通过访问者模式的代码可以看到，在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。也就是说，在元素类数目不确定的情况下，应该慎用访问者模式。所以，访问者模式比较适用于对已有功能的重构，比如说，一个项目的基本功能已经确定下来，元素类的数据已经基本确定下来不会变了，会变的只是这些元素内的相关操作，这时候，我们可以使用访问者模式对原有的代码进行重构一遍，这样一来，就可以在不修改各个元素类的情况下，对原有功能进行修改。</li>
</ul>
</li>
<li><p>适用场景</p>
<ul>
<li>假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。</li>
<li>假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。</li>
</ul>
</li>
</ul>
<h2 id="21-状态模式"><a href="#21-状态模式" class="headerlink" title="21.状态模式"></a>21.状态模式</h2><ul>
<li><p>状态（state）模式的定义：定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类</p>
</li>
<li><p>状态模式(State)适用性</p>
<ul>
<li><p>1.一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。</p>
</li>
<li><p>2.一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。</p>
<ul>
<li><p>这个状态通常用一个或多个枚举常量表示。</p>
</li>
<li><p>通常,有多个操作包含这一相同的条件结构。</p>
</li>
<li><p>State模式将每一个条件分支放入一个独立的类中。</p>
</li>
<li><p>这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>状态模式(State)的参与者</p>
<ul>
<li><p>1.Context</p>
<ul>
<li><p>定义客户感兴趣的接口。</p>
</li>
<li><p>维护一个ConcreteState子类的实例，这个实例定义当前状态。</p>
</li>
</ul>
</li>
<li><p>2.State</p>
<pre><code>- 定义一个接口以封装与Context的一个特定状态相关的行为。
</code></pre></li>
<li><p>3.ConcreteStatesubclasses</p>
<pre><code>- 每一子类实现一个与Context的一个状态相关的行为。
</code></pre></li>
</ul>
</li>
</ul>
<p>　　　　　　</p>
<ul>
<li><p>具体代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">定义State</div><div class="line"></div><div class="line">//定义和Context中的状态相对应的行为</div><div class="line"> public interface State &#123;</div><div class="line">     //获取天气情况</div><div class="line">     String getState();</div><div class="line"> &#125;</div><div class="line"></div><div class="line">定义Context</div><div class="line"></div><div class="line"> //定义当前的状态</div><div class="line">public class Context &#123;</div><div class="line"></div><div class="line">	 private State state;</div><div class="line">	</div><div class="line">	 public State getState() &#123;</div><div class="line">	     return state;</div><div class="line">	 &#125;</div><div class="line">	</div><div class="line">	 public void setState(State state) &#123;</div><div class="line">	     this.state = state;</div><div class="line">	 &#125;</div><div class="line">	 public String stateMessage()&#123;</div><div class="line">	     return state.getState();</div><div class="line">	 &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">定义ConcreteStatesubclasses</div><div class="line"></div><div class="line"></div><div class="line">class Sunshine implements State&#123;</div><div class="line">  </div><div class="line">      @Override</div><div class="line">      public String getState() &#123;</div><div class="line">          </div><div class="line">          return &quot;晴天&quot;;</div><div class="line">      &#125;</div><div class="line">     </div><div class="line">&#125;</div><div class="line">class Rain implements State&#123;</div><div class="line"> </div><div class="line">     @Override</div><div class="line">     public String getState() &#123;</div><div class="line">         </div><div class="line">         return &quot;下雨&quot;;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line">测试一下</div><div class="line"> public class StateTest &#123;</div><div class="line"> </div><div class="line">     public static void main(String args[])&#123;</div><div class="line">         Context context=new Context();</div><div class="line">         context.setState(new Rain());</div><div class="line">         System.out.println(context.stateMessage());</div><div class="line">         context.setState(new Sunshine());</div><div class="line">         System.out.println(context.stateMessage());</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">运行结果：</div><div class="line">下雨</div><div class="line">晴天</div></pre></td></tr></table></figure>
</li>
<li><p>接下来我们用Java编程思想中的一个例子来讲解一下状态模式</p>
<ul>
<li>我们学习了多态，看起来似乎所有的东西都可以去继承，因为多态是一个如此巧妙的工具。事实上，当我们使用现成的类建立新类时，如果首先考虑使用继承技术，反倒会加重我们的设计负担，使得事情变得复杂起来。</li>
<li>更好的设计思想是首先选择”组合”,尤其是不能十分确定应该使用哪一种方式的时候。组合不会强制我们的程序设计进入继承的层次结构中。而且，组合更加灵活，因为它可以动态选择类型(因此也就选择了行为)，想法，继承在编译时就需要知道确定的类型，下面是具体代码体现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"> //相当于状态模式中的state</div><div class="line"> class Actor &#123;</div><div class="line">    public void act()&#123;&#125;</div><div class="line"> &#125;</div><div class="line"> //相当于状态模式中的ConcreteStateSubclassess</div><div class="line"> class HappyActor extends Actor&#123;</div><div class="line">     public void act()&#123;</div><div class="line">         System.out.println(&quot;HappyActor&quot;);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> class SadActor extends Actor&#123;</div><div class="line">     public void act()&#123;</div><div class="line">         System.out.println(&quot;SadActor&quot;);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> //相当于状态模式中的Context</div><div class="line"> class Stage&#123;</div><div class="line">     private Actor actor=new HappyActor();</div><div class="line">     //改变引用actor的指向的具体类型</div><div class="line">     public void change()&#123;</div><div class="line">         actor=new SadActor();</div><div class="line">     &#125;</div><div class="line">     //根据状态的不同执行不同的行为</div><div class="line">     public void performPlay()&#123;</div><div class="line">         actor.act();</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">测试一下：</div><div class="line"></div><div class="line"></div><div class="line"> public class Transmogrify &#123;</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">     public static void main(String[] args) &#123;</div><div class="line"> </div><div class="line">         Stage stage=new Stage();</div><div class="line">         stage.performPlay();</div><div class="line">         stage.change();</div><div class="line">         stage.performPlay();</div><div class="line">     &#125;</div><div class="line"> </div><div class="line"> &#125;</div><div class="line"></div><div class="line">运行结果：</div><div class="line">HappyActor</div><div class="line">SadActor</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>程序分析：在这里，Stage对象包含一个对Actor的引用，而Actor被初始化为HappyActor对象，这意味着performPlay()会产生某种特殊行为。既然引用在运行时可以和另一个不同的对象重新绑定起来，SadActor对象的引用可以在actor中被替换，然后由performPlay()产生的行为也随之改变，这样一来，我们在运行期间获得了动态灵活性。与此相反的是，我们不能在运行期间决定继承不同的对象，因为它要求在编译期间完全确定下来。</p>
</li>
<li><p>大家是不是觉得状态模式和策略模式不是一样的吗？我们讲一下他们之间的区别和联系：</p>
<ul>
<li>状态模式和策略模式的区别和联系(取自知乎网友的回答，很精辟)：<ul>
<li>区别：状态模式将各个状态所对应的操作分离开来，即对于不同的状态，由不同的子类实现具体操作，不同状态的切换由子类实现，当发现传入参数不是自己这个状态所对应的参数，则自己给Context类切换状态；而策略模式是直接依赖注入到Context类的参数进行选择策略，不存在切换状态的操作练习</li>
<li>联系状态模式和策略模式都是为具有多种可能情形设计的模式，把不同的处理情形抽象为一个相同的接口，符合对扩展开放，对修改封闭的原则。还有就是，策略模式更具有一般性一些，在实践中，可以用策略模式来封装几乎任何类型的规则，只要在分析过程中听到需要在不同实践应用不同的业务规则，就可以考虑使用策略模式处理，在这点上策略模式是包含状态模式的功能的，策略模式是一个重要的设计模式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="22-解释器模式"><a href="#22-解释器模式" class="headerlink" title="22.解释器模式"></a>22.解释器模式</h2><ul>
<li>概述<ul>
<li>解释器模式是一种用得比较少的行为型模式.提供了一种解释语言的语法或表达式的方式.</li>
<li>通过定义一个表达式接口,解释一个特定的上下文.</li>
</ul>
</li>
<li><p>定义</p>
<ul>
<li><p>给定一个语言，解释器模式可以定义出其文法的一种表示,并定义一个解释器,该解释器使用该表示来解释语言中的句子.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">解释器中涉及到的文法,就是符合一定规则的语句结构.</div><div class="line">如 abcd…….cdef(ab开头,ef结尾,中间N个cd)中,根据N值的不同,可以得到不同的字符串如,abef,abcdef,abcdcdef….</div><div class="line">假设我们有如下推导式</div><div class="line">S ::= abA*ef</div><div class="line">A ::= cd</div><div class="line">其中 ::=表示推导,*表示闭包,意思是A可以有0~N个重复,S是初始符号,abef和cd是终结符号.</div><div class="line">像这样的从一个具体的符号出发,通过不断地应用一些产生式规则 从而生成一个字符串的集合,我们将描述这个集合的文法称为形式文法.</div></pre></td></tr></table></figure>
</li>
<li><p>给定一个语言(如由abcdef六个字符组成的字符串集合),定义它的文法的一种表示(S::=abA*ef,A::=cd)并定义一个解释器,解释器使用该表示来解释语言中的句子.</p>
</li>
<li>其中的解释器类似一个翻译机</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>某个简单的语言需要解释执行并且可以将该语言中的语句表示为一个抽象语法树的时候.</li>
<li>在某些特定的领域出现不断重复的问题时,可以将该领域的问题转化为一种语法规则下的语句,并构建解释器来解释该语句.</li>
</ul>
</li>
<li><p>其中涉及到的角色有:</p>
<ul>
<li>AbstractExpression: 抽象表达式,声明一个抽象的解释操作父类,定义一个抽象的解释方法,具体的实现由子类解释器完成/</li>
<li>TerminalExpression: 终结符表达式,实现文法中与终结符有关的解释操作,文法中每一个终结符都有一个具体的终结表达式与之对应</li>
<li>NonterminalExpression: 非终结符表达式,实现文法中与非终结符有关的解释操作</li>
<li>Context: 上下文环境类,包含解释器之外的全局信息</li>
<li>Client: 客户端,解析表达式,构建抽象语法树,执行具体的解释操作等.</li>
</ul>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">如下我们通过对算术表达式的解释来看一个解释器模式的实现,</div><div class="line">如表达式m+n+p中,如果我们使用解释器模式对该表达式进行解释,那么m,n,p代表的三个字母可以看成是终结符号,而+代表的运算符则可以看成是非终结符号</div><div class="line"></div><div class="line"> 首先建立抽象解释器表示数学运算</div><div class="line">public abstract class ArithmeticExpression &#123;</div><div class="line">  public abstract int interptet();</div><div class="line">&#125;</div><div class="line"></div><div class="line">解释器中定义了interptet()方法,ArithmeticExpression有两个直接子类,NumExpression,和OperatorExpression</div><div class="line"></div><div class="line">建立NumExpression,对数字进行解释</div><div class="line">public class NumExpression extends ArithmeticExpression &#123;</div><div class="line">  private int num;</div><div class="line"></div><div class="line">  public NumExpression(int _num) &#123;</div><div class="line">    num = _num;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public int interptet() &#123;</div><div class="line">    return num;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">建立OperatorExpression,对运算符进行解释</div><div class="line">public abstract class OperatorExpression extends ArithmeticExpression &#123;</div><div class="line">  protected ArithmeticExpression mArithmeticExpression1,mArithmeticExpression2;</div><div class="line"></div><div class="line">  public OperatorExpression(ArithmeticExpression _arithmeticExpression1,</div><div class="line">      ArithmeticExpression _arithmeticExpression2) &#123;</div><div class="line">    mArithmeticExpression1 = _arithmeticExpression1;</div><div class="line">    mArithmeticExpression2 = _arithmeticExpression2;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">AdditionExpression,OperatorExpression的直接子类,加法运算解释器</div><div class="line"></div><div class="line">public class AdditionExpression extends OperatorExpression &#123;</div><div class="line">  public AdditionExpression(ArithmeticExpression _arithmeticExpression1,</div><div class="line">      ArithmeticExpression _arithmeticExpression2) &#123;</div><div class="line">    super(_arithmeticExpression1, _arithmeticExpression2);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public int interptet() &#123;</div><div class="line">    return mArithmeticExpression1.interptet() + mArithmeticExpression2.interptet();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">新增业务逻辑处理类</div><div class="line">public class Calculator &#123;</div><div class="line"></div><div class="line">  protected Stack&lt;ArithmeticExpression&gt; mArithmeticExpressionStack = new Stack&lt;&gt;();</div><div class="line"></div><div class="line">  public Calculator(String expression) &#123;</div><div class="line">    ArithmeticExpression arithmeticExpression1, arithmeticExpression2;</div><div class="line">    String[] elements = expression.split(&quot; &quot;);</div><div class="line">    for (int i = 0; i &lt; elements.length; ++i) &#123;</div><div class="line">      switch (elements[i].charAt(0)) &#123;</div><div class="line">        case &apos;+&apos;:</div><div class="line">          arithmeticExpression1 = mArithmeticExpressionStack.pop();</div><div class="line">          arithmeticExpression2 = new NumExpression(Integer.valueOf(elements[++i]));</div><div class="line">          mArithmeticExpressionStack.push(</div><div class="line">              new AdditionExpression(arithmeticExpression1, arithmeticExpression2));</div><div class="line">          break;</div><div class="line">        default:</div><div class="line">          mArithmeticExpressionStack.push(new NumExpression(Integer.valueOf(elements[i])));</div><div class="line">          break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public int calculate() &#123;</div><div class="line">    return mArithmeticExpressionStack.pop().interptet();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">客户端调用</div><div class="line"></div><div class="line">// 解释计算123+124+125+126的运算结果</div><div class="line">Calculator calculator = new Calculator(&quot;123+124+125+126&quot;);</div><div class="line">   Log.d(TAG, &quot;setBtnClick: --&gt;&quot; + calculator.calculate());</div></pre></td></tr></table></figure>
</li>
<li><p>优缺点</p>
<ul>
<li>优点<ul>
<li>灵活性强,如上边的例子,当我们想对文法规则进行扩展延伸时,只需要增加相应的非终结符解释器,并在构建语法树的时候使用新增的解释器对象进行具体的解释即可.</li>
</ul>
</li>
<li>缺点<ul>
<li>因为每一条文法都可以对应至少一个解释器,会生成大量的类,导致后期维护困难,而且对应复杂的文法,构建语法树会显得异常繁琐.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实例代码</p>
<h2 id="23-桥梁模式"><a href="#23-桥梁模式" class="headerlink" title="23.桥梁模式"></a>23.桥梁模式</h2><ul>
<li><p>应用场景</p>
<ul>
<li>举个例子，铅笔和钢笔，都可以用来写字和画画。邮局可以邮寄信件和包裹，两者都有平邮和挂号邮寄两种功能。明白使用场景后，我们可以提取主要元素：事物和功能。</li>
<li>可以这样定义：有一类事务的集合，{A1，A2，A3…}，每个事物都具有功能F1，F2，F3。当然会有个功能的集合{F1，F2，F3…}。在计算机的世界里我们如何表示呢，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class 信件&#123;</div><div class="line">    public void 平邮()&#123;&#125;</div><div class="line">    public void 挂号()&#123;&#125;</div><div class="line">&#125;   </div><div class="line"></div><div class="line">public class 包裹&#123;</div><div class="line">    public void 平邮()&#123;&#125;</div><div class="line">    public void 挂号()&#123;&#125;</div><div class="line">&#125;   </div><div class="line">每个事物是一个类，有m个事物，就有m个类，每个类有n个功能，一共下来有m*n个功能。显然，这种方法是不可取的。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>桥接模式概念</p>
<ul>
<li>桥接模式是关于怎么将抽象部分和它的实现部分分离，使它们都可以独立变化。像之前那种写法，会有大量的重复的代码。</li>
</ul>
</li>
<li><p>解决办法</p>
<pre><code>- 利用语义，对于平邮和挂号，它们是邮局发送的两种方式，所以一句话：邮局有发送功能，我们就可以先得到一个接口，代码如下：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package qj_1;</div><div class="line"></div><div class="line"></div><div class="line">public interface iPost &#123;//邮局</div><div class="line">        public void send();//发送功能</div><div class="line">&#125;</div><div class="line"></div><div class="line">有了这个接口后，我们当然想着的是它的实现类了。</div><div class="line"></div><div class="line">//平邮实现类</div><div class="line">public class Pmail implements iPost&#123;</div><div class="line">	@Override</div><div class="line">	public void send() &#123;</div><div class="line">		System.out.println(&quot;平邮发送。。&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//挂号实现类</div><div class="line">public class Gmail implements iPost&#123;</div><div class="line">	@Override</div><div class="line">	public void send() &#123;</div><div class="line">		System.out.println(&quot;挂号发送。。&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以上我们解决了问题的一半：邮局有平邮和挂号两种功能。信件和包裹，是两种不同的事物，它们有相同的功能，当然也有不同的。对于它们共同的部分我们可以将其封装到一个类中，但是该类又不能代替一个具体的事物，所以我们可以将其定义为抽象类。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractThing &#123;// 抽象类</div><div class="line">	private iPost post;// 多态成员</div><div class="line">	public AbstractThing(iPost obj) &#123;</div><div class="line">		post = obj;</div><div class="line">	&#125;</div><div class="line">	public void post() &#123;// 平邮和挂号两种功能</div><div class="line">		post.send();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>该抽象类是桥接模式的核心。重点是在该类中定义了多态成员，发送的两种方式是信件和包裹共享的功能。接下的就很明确了，信件和包裹两个具体的事物去继承抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//信件实现类</div><div class="line">public class Letter extends AbstractThing&#123;</div><div class="line">	public Letter(iPost obj) &#123;</div><div class="line">		super(obj);</div><div class="line">	&#125;</div><div class="line">	//其他独有的变量和方法</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//包裹实现类</div><div class="line">public class Parcel extends AbstractThing&#123;</div><div class="line">	public Parcel(iPost obj) &#123;</div><div class="line">		super(obj);</div><div class="line">	&#125;</div><div class="line">    //其他独有的变量和方法</div><div class="line">&#125;</div><div class="line"></div><div class="line">测试类代码如下：</div><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] str) &#123;</div><div class="line">		iPost post = new Gmail();</div><div class="line">		Letter letter = new Letter(post);</div><div class="line">		letter.post();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分析总结</p>
<ul>
<li>从测试类中我们可以看出，先功能类中选择一种发送方式，然后再在事物类中选择一种具体的事物类，然后完成发送任务。所以可以总结，桥接模式完成的是一个多条件选择问题，假设有二维条件，分别有N1，N2个选择，桥接模式就是要求在一维的条件中选一个条件，再在二维的条件中选一个，完成有效的组合。这种情景在生活中很常见，比如，10件上衣10件裤子，你想搭配出一套衣服，你肯定会上衣摆出一排，在其中选一件，裤子摆出一排，在其中选一件。而不是衣服裤子混在一起挑。你从家里到长春，必须经过中转站北京，从家到北京好多路线和方式，从北京到长春同样很多路线，你肯定从家到北京的路线先选择一条，从北京到长春的路线选一条，完成从家到北京这个事。</li>
</ul>
</li>
<li><p>当需求发生变化时，桥接模式是如何满足的呢？</p>
<pre><code>- 当添加了新的事物，从抽象类中派生一个类即可。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class NewThing extends AbstractThing&#123;</div><div class="line">	public NewThing(iPost obj) &#123;</div><div class="line">	super(obj);</div><div class="line">	&#125;</div><div class="line">	//其他独有的变量和方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当添加了新的发送方式，从接口派生出一个类即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class NewMail implements iPost&#123;</div><div class="line">	@Override</div><div class="line">	public void send() &#123;</div><div class="line">		System.out.println(&quot;新增的一种发送方式&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="彩蛋：女孩儿与设计模式"><a href="#彩蛋：女孩儿与设计模式" class="headerlink" title="彩蛋：女孩儿与设计模式"></a>彩蛋：女孩儿与设计模式</h1><blockquote>
<p>形象的总结一下设计模式。</p>
</blockquote>
<ul>
<li><p>1.SINGLETON 单例模式</p>
<ul>
<li><p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
</li>
<li><p>俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)。</p>
</li>
</ul>
</li>
<li><p>2.FACTORY METHOD 工厂方法模式</p>
<ul>
<li><p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
</li>
<li><p>请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。</p>
</li>
</ul>
</li>
<li><p>3.FACTORY 工厂模式</p>
<ul>
<li><p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
</li>
<li><p>追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory。</p>
</li>
</ul>
</li>
<li><p>4.BUILDER 建造模式</p>
<ul>
<li><p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
</li>
<li><p>MM最爱听的就是“我爱你”这句话了，见到不同地方的MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）</p>
</li>
</ul>
</li>
<li><p>5.PROTOTYPE 原型模式</p>
<ul>
<li><p>原型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
</li>
<li><p>跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。 原型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。</p>
</li>
</ul>
</li>
<li><p>6.ADAPTER 适配器模式</p>
<ul>
<li><p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
</li>
<li><p>在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)。</p>
</li>
</ul>
</li>
<li><p>7.BRIDGE 桥梁模式</p>
<ul>
<li><p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
</li>
<li><p>早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。</p>
</li>
</ul>
</li>
<li><p>8.COMPOSITE 合成模式</p>
<ul>
<li><p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
</li>
<li><p>Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？</p>
</li>
</ul>
</li>
<li><p>9.DECORATOR 装饰模式</p>
<ul>
<li><p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
</li>
<li><p>Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
</li>
</ul>
</li>
<li><p>10.FACADE 门面（外观）模式</p>
<ul>
<li><p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
</li>
<li><p>我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。</p>
</li>
</ul>
</li>
<li><p>11.FLYWEIGHT 享元模式</p>
<ul>
<li><p>享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
</li>
<li><p>每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。</p>
</li>
</ul>
</li>
<li><p>12.PROXY 代理模式</p>
<ul>
<li><p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
</li>
<li><p>跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
</li>
</ul>
</li>
<li><p>13.CHAIN OF RESPONSIBLEITY 责任链模式</p>
<ul>
<li><p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
</li>
<li><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!</p>
</li>
</ul>
</li>
<li><p>14.COMMAND 命令模式</p>
<ul>
<li><p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
</li>
<li><p>俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”</p>
</li>
</ul>
</li>
<li><p>15.INTERPRETER 解释器模式</p>
<ul>
<li><p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
</li>
<li><p>俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。</p>
</li>
</ul>
</li>
<li><p>16.ITERATOR 迭代子模式</p>
<ul>
<li><p>迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
</li>
<li><p>我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” ……</p>
</li>
</ul>
</li>
<li><p>17.MEDIATOR 调停者模式</p>
<ul>
<li><p>调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
</li>
<li><p>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
</li>
</ul>
</li>
<li><p>18.MEMENTO 备忘录模式</p>
<ul>
<li><p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
</li>
<li><p>同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
</li>
</ul>
</li>
<li><p>19.OBSERVER 观察者模式</p>
<ul>
<li><p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
</li>
<li><p>想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>
</li>
</ul>
</li>
<li><p>20.STATE 状态模式</p>
<ul>
<li><p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
</li>
<li><p>跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。</p>
</li>
</ul>
</li>
<li><p>21.STRATEGY 策略模式</p>
<ul>
<li><p>策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
</li>
<li><p>跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。</p>
</li>
</ul>
</li>
<li><p>22.TEMPLATE METHOD 模板模式</p>
<ul>
<li><p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
</li>
<li><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)。</p>
</li>
</ul>
</li>
<li><p>23.VISITOR 访问者模式</p>
<ul>
<li><p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
</li>
<li><p>情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述设计模式的文章
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GetLuckyMoneyPluginByMr.Wu_微信自动抢红包插件</title>
    <link href="http://yoursite.com/2017/01/25/GetLuckyMoneyPlugin_%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/01/25/GetLuckyMoneyPlugin_微信自动抢红包插件/</id>
    <published>2017-01-25T08:05:00.000Z</published>
    <updated>2017-01-25T09:45:22.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ul>
<li>使用AccessibilityService对程序进行模拟点击</li>
<li>使用系统服务监听应用UI变化</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul>
<li>打开『GetLuckyMoneyPluginByMr.Wu』的应用，开启插件。</li>
<li><p>等待微信红包进账。    </p>
<ul>
<li>注意:最好设置屏幕常亮<h1 id="软件截图"><a href="#软件截图" class="headerlink" title="软件截图"></a>软件截图</h1></li>
</ul>
</li>
<li><p>第一步打开软件</p>
</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/ee5da0b30b69187a.png" alt="step1"></p>
<ul>
<li>第二步查看服务的开启状态</li>
</ul>
<p><img src="http://i1.piimg.com/567571/4110ed8a2711aab7.png" alt="step2"></p>
<ul>
<li>第三步开启服务</li>
</ul>
<p><img src="http://i1.piimg.com/567571/a613fe8e11b60c26.png" alt="step3"></p>
<ul>
<li>第四步检查服务是否开启</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/2121008ddd2564a8.png" alt="step4"></p>
<h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h1><ul>
<li><a href="https://www.pgyer.com/zrCk" target="_blank" rel="external">最新版下载链接</a></li>
<li>下载密码：4321</li>
<li>由于不可描述的原因，应用的链接可能会失效，若发现失效请<a href="http://pan.baidu.com/s/1qYRN6zi" target="_blank" rel="external">点击该处通过百度云</a>获取应用最新安装包。</li>
</ul>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><ul>
<li>插件使用者自行承担随之而来的各种风险，包括但不限于“禁用红包功能”、“微信封号”，不过该插件用户群体较少，所以该风险较小。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一款微信抢红包的插件，适用于自动发现红包和自动点击打开红包，让你抢红包总是快人一步（注意：该插件无法控制抢到的金额，只是能在速度上取胜）。
    
    </summary>
    
      <category term="生活相关" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="微信红包，插件，自动点击打开" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%EF%BC%8C%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%87%AA%E5%8A%A8%E7%82%B9%E5%87%BB%E6%89%93%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>HappyNewYear</title>
    <link href="http://yoursite.com/2016/12/31/HappyNewYear_2017/"/>
    <id>http://yoursite.com/2016/12/31/HappyNewYear_2017/</id>
    <published>2016-12-31T13:05:00.000Z</published>
    <updated>2017-01-12T13:58:18.372Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=30394763&auto=1&height=66"></iframe>

<h4 id="故事的小黄花"><a href="#故事的小黄花" class="headerlink" title="故事的小黄花"></a>故事的小黄花</h4><h4 id="从出生那年就飘着"><a href="#从出生那年就飘着" class="headerlink" title="从出生那年就飘着"></a>从出生那年就飘着</h4><h4 id="童年的荡秋千"><a href="#童年的荡秋千" class="headerlink" title="童年的荡秋千"></a>童年的荡秋千</h4><h4 id="随记忆一直晃到现在"><a href="#随记忆一直晃到现在" class="headerlink" title="随记忆一直晃到现在"></a>随记忆一直晃到现在</h4><h4 id="rui-sou-sou-xi-dou-xi-la"><a href="#rui-sou-sou-xi-dou-xi-la" class="headerlink" title="rui sou sou xi dou xi la"></a>rui sou sou xi dou xi la</h4><h4 id="sou-la-xi-xi-xi-xi-la-xi-la-sou"><a href="#sou-la-xi-xi-xi-xi-la-xi-la-sou" class="headerlink" title="sou la xi xi xi xi la xi la sou"></a>sou la xi xi xi xi la xi la sou</h4><h4 id="吹着前奏望着天空"><a href="#吹着前奏望着天空" class="headerlink" title="吹着前奏望着天空"></a>吹着前奏望着天空</h4><h4 id="我想起花瓣试着掉落"><a href="#我想起花瓣试着掉落" class="headerlink" title="我想起花瓣试着掉落"></a>我想起花瓣试着掉落</h4><h4 id="为你翘课的那一天"><a href="#为你翘课的那一天" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天"><a href="#花落的那一天" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间"><a href="#教室的那一间" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="我怎么看不见"><a href="#我怎么看不见" class="headerlink" title="我怎么看不见"></a>我怎么看不见</h4><h4 id="消失的下雨天"><a href="#消失的下雨天" class="headerlink" title="消失的下雨天"></a>消失的下雨天</h4><h4 id="我好想再淋一遍"><a href="#我好想再淋一遍" class="headerlink" title="我好想再淋一遍"></a>我好想再淋一遍</h4><h4 id="没想到失去的勇气我还留着"><a href="#没想到失去的勇气我还留着" class="headerlink" title="没想到失去的勇气我还留着"></a>没想到失去的勇气我还留着</h4><h4 id="好想再问一遍"><a href="#好想再问一遍" class="headerlink" title="好想再问一遍"></a>好想再问一遍</h4><h4 id="你会等待还是离开"><a href="#你会等待还是离开" class="headerlink" title="你会等待还是离开"></a>你会等待还是离开</h4><h4 id="刮风这天我试过握着你手"><a href="#刮风这天我试过握着你手" class="headerlink" title="刮风这天我试过握着你手"></a>刮风这天我试过握着你手</h4><h4 id="但偏偏雨渐渐大到我看你不见"><a href="#但偏偏雨渐渐大到我看你不见" class="headerlink" title="但偏偏雨渐渐大到我看你不见"></a>但偏偏雨渐渐大到我看你不见</h4><h4 id="还要多久我才能在你身边"><a href="#还要多久我才能在你身边" class="headerlink" title="还要多久我才能在你身边"></a>还要多久我才能在你身边</h4><h4 id="等到放晴的那天也许我会比较好一点"><a href="#等到放晴的那天也许我会比较好一点" class="headerlink" title="等到放晴的那天也许我会比较好一点"></a>等到放晴的那天也许我会比较好一点</h4><h4 id="从前从前有个人爱你很久"><a href="#从前从前有个人爱你很久" class="headerlink" title="从前从前有个人爱你很久"></a>从前从前有个人爱你很久</h4><h4 id="但偏偏风渐渐把距离吹得好远"><a href="#但偏偏风渐渐把距离吹得好远" class="headerlink" title="但偏偏风渐渐把距离吹得好远"></a>但偏偏风渐渐把距离吹得好远</h4><h4 id="好不容易又能再多爱一天"><a href="#好不容易又能再多爱一天" class="headerlink" title="好不容易又能再多爱一天"></a>好不容易又能再多爱一天</h4><h4 id="但故事的最后你好像还是说了拜拜"><a href="#但故事的最后你好像还是说了拜拜" class="headerlink" title="但故事的最后你好像还是说了拜拜"></a>但故事的最后你好像还是说了拜拜</h4><h4 id="为你翘课的那一天-1"><a href="#为你翘课的那一天-1" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-1"><a href="#花落的那一天-1" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-1"><a href="#教室的那一间-1" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="我怎么看不见-1"><a href="#我怎么看不见-1" class="headerlink" title="我怎么看不见"></a>我怎么看不见</h4><h4 id="消失的下雨天-1"><a href="#消失的下雨天-1" class="headerlink" title="消失的下雨天"></a>消失的下雨天</h4><h4 id="我好想再淋一遍-1"><a href="#我好想再淋一遍-1" class="headerlink" title="我好想再淋一遍"></a>我好想再淋一遍</h4><h4 id="没想到失去的勇气我还留着-1"><a href="#没想到失去的勇气我还留着-1" class="headerlink" title="没想到失去的勇气我还留着"></a>没想到失去的勇气我还留着</h4><h4 id="好想再问一遍-1"><a href="#好想再问一遍-1" class="headerlink" title="好想再问一遍"></a>好想再问一遍</h4><h4 id="你会等待还是离开-1"><a href="#你会等待还是离开-1" class="headerlink" title="你会等待还是离开"></a>你会等待还是离开</h4><h4 id="刮风这天我试过握着你手-1"><a href="#刮风这天我试过握着你手-1" class="headerlink" title="刮风这天我试过握着你手"></a>刮风这天我试过握着你手</h4><h4 id="但偏偏雨渐渐大到我看你不见-1"><a href="#但偏偏雨渐渐大到我看你不见-1" class="headerlink" title="但偏偏雨渐渐大到我看你不见"></a>但偏偏雨渐渐大到我看你不见</h4><h4 id="还要多久我才能在你身边-1"><a href="#还要多久我才能在你身边-1" class="headerlink" title="还要多久我才能在你身边"></a>还要多久我才能在你身边</h4><h4 id="等到放晴的那天也许我会比较好一点-1"><a href="#等到放晴的那天也许我会比较好一点-1" class="headerlink" title="等到放晴的那天也许我会比较好一点"></a>等到放晴的那天也许我会比较好一点</h4><h4 id="从前从前有个人爱你很久-1"><a href="#从前从前有个人爱你很久-1" class="headerlink" title="从前从前有个人爱你很久"></a>从前从前有个人爱你很久</h4><h4 id="偏偏风渐渐把距离吹得好远"><a href="#偏偏风渐渐把距离吹得好远" class="headerlink" title="偏偏风渐渐把距离吹得好远"></a>偏偏风渐渐把距离吹得好远</h4><h4 id="好不容易又能再多爱一天-1"><a href="#好不容易又能再多爱一天-1" class="headerlink" title="好不容易又能再多爱一天"></a>好不容易又能再多爱一天</h4><h4 id="但故事的最后你好像还是说了拜拜-1"><a href="#但故事的最后你好像还是说了拜拜-1" class="headerlink" title="但故事的最后你好像还是说了拜拜"></a>但故事的最后你好像还是说了拜拜</h4><h4 id="为你翘课的那一天-2"><a href="#为你翘课的那一天-2" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="为你翘课的那一天-3"><a href="#为你翘课的那一天-3" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="为你翘课的那一天-4"><a href="#为你翘课的那一天-4" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-2"><a href="#花落的那一天-2" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-2"><a href="#教室的那一间-2" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="为你翘课的那一天-5"><a href="#为你翘课的那一天-5" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-3"><a href="#花落的那一天-3" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-3"><a href="#教室的那一间-3" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="为你翘课的那一天-6"><a href="#为你翘课的那一天-6" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-4"><a href="#花落的那一天-4" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-4"><a href="#教室的那一间-4" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><hr>
<h4 id="对今年的总结："><a href="#对今年的总结：" class="headerlink" title="对今年的总结："></a>对今年的总结：</h4><ul>
<li>今年是特殊的一年，鬼知道我到底经历了什么。</li>
</ul>
<h4 id="对来年的展望："><a href="#对来年的展望：" class="headerlink" title="对来年的展望："></a>对来年的展望：</h4><ul>
<li>愿新的一年，我们都能被这个世界温柔相待。</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/e8b8b80752ba1ecd.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      对今年的总结和对未来的展望
    
    </summary>
    
      <category term="生活相关" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="新年快乐，HappyNewYear" scheme="http://yoursite.com/tags/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%8CHappyNewYear/"/>
    
  </entry>
  
  <entry>
    <title>android里handler线程间的通信详解</title>
    <link href="http://yoursite.com/2016/09/07/Android%E4%B8%8B%E7%9A%84handler%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/09/07/Android下的handler线程间通信全解析/</id>
    <published>2016-09-06T16:00:00.000Z</published>
    <updated>2017-05-07T12:28:34.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android里handler线程间的通信详解"><a href="#android里handler线程间的通信详解" class="headerlink" title="android里handler线程间的通信详解"></a>android里handler线程间的通信详解</h1><p>本文基于Android 的源代码，来分析Java层的handler消息处理机制</p>
<ul>
<li><p>相关源码</p>
<pre><code>framework/base/core/java/andorid/os/Handler.java
framework/base/core/java/andorid/os/Looper.java
framework/base/core/java/andorid/os/Message.java
framework/base/core/java/andorid/os/MessageQueue.java
libcore/luni/src/main/java/java/lang/ThreadLocal.java
</code></pre><h1 id="一-概述："><a href="#一-概述：" class="headerlink" title="一.概述："></a>一.概述：</h1></li>
</ul>
<p>在整个Android的源码世界里，有两大利剑，其一是Binder IPC机制，，另一个便是消息机制(由Handler/Looper/MessageQueue等构成的)。<br>Android有大量的消息驱动方式来进行交互，比如Android的四剑客Activity, Service, Broadcast, ContentProvider的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。消息机制涉及MessageQueue/Message/Looper/Handler这4个类。</p>
<p>##1.1模型：<br>消息机制包含：</p>
<ul>
<li>Message:消息分为硬件产生的消息（如按钮、触摸）和软件生成的消息；</li>
<li>MessageQueue：消息队列的主要功能向消息池投递消息（MessageQueue.enqueueMessage）和取走消息池的消息（MessageQueue.next）</li>
<li>Handler:消息辅助类，主要的功能是向消息池发送各种消息事件（Handler.sendMessage）和处理响应的消息事件（Handler.handleMessage）</li>
<li>Looper:不断循环执行（Looper.loop）,按照分发机制将消息分发给目标处理者</li>
</ul>
<p>##1.2 构架图</p>
<p><img src="/img/Main.jpg" alt=""> </p>
<ul>
<li>Looper有一个MessageQueue消息队列；</li>
<li>MessageQueue有一组待处理的Message；</li>
<li>Message中有一个用于处理消息的Handler；</li>
<li>Handler中有Looper和MessageQueue。</li>
</ul>
<p>##1.3典型事例</p>
<ul>
<li>在android的实际开发中，一般我们都是在主线程里new出Handler的对象，然后在子线程里用该对象向主线程发送消息，然后我们在主线程里处理该消息；</li>
<li>那我们怎么实现主线程向子线程里传递数据呢？要实现这个目的我们必须在子线程里new一个Handler的对象，然后用该Handler对象在主线程发送消息到主线程。但是在子线程new Handler是会报错：没有Looper，不能new Handler。那么我们就必须先调用Looper.prepare方法准备一个Looper对象，然后调用Looper.loop方法开始轮询。</li>
<li><p>Android 系统的消息队列和消息循环都是针对具体线程的，一个线程可以存在（当然也可以不存在）一个消息队列和一个消息循环（Looper），特定线程的消息只能分发给本线程，不能进行跨线程，跨进程通讯。但是创建的工作线程默认是没有消息循环和消息队列的，如果想让该线程具有消息队列和消息循环，需要在线程中首先调用Looper.prepare()来创建消息队列，然后调用Looper.loop()进入消息循环。 如下例所示：</p>
<pre><code>class LooperThread extends Thread {
public Handler mHandler;

public void run() {
  Looper.prepare();//给线程创建一个消息循环  //【见 2.1】
  mHandler = new Handler() {  //【见 3.1】
    public void handleMessage(Message msg) {
     // process incoming messages here  定义消息处理逻辑. 【见 3.2】
    }
  };
  Looper.loop();//使消息循环起作用，从消息队列里取消息，处理消息【见 2.2】
  }
}
</code></pre></li>
</ul>
<blockquote>
<p>注：写在Looper.loop()之后的代码不会被立即执行，当调用后 mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。Looper对象通过MessageQueue 来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。这样你的线程就具有了消息处理机制了，在Handler中进行消息处理。</p>
</blockquote>
<h1 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h1><p>##2.1 prepare()</p>
<p>对于无参的情况，默认调用prepare(true)，表示的是这个Looper运行退出，而对于false的情况则表示当前Looper不运行退出。</p>
<pre><code>private static void prepare(boolean quitAllowed) {
    //每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    //创建Looper对象，并保存到当前线程的TLS区域
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre><p>这里的sThreadLocal是ThreadLocal类型，下面，先说说ThreadLocal。</p>
<p>ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法：</p>
<pre><code>ThreadLocal.set(T value)：将value存储到当前线程的TLS区域，源码如下：

  public void set(T value) {
      Thread currentThread = Thread.currentThread(); //获取当前线程
      Values values = values(currentThread); //查找当前线程的本地储存区
      if (values == null) {
          //当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象
          values = initializeValues(currentThread);
      }
      //保存数据value到当前线程this
      values.put(this, value);
  }

ThreadLocal.get()：获取当前线程TLS区域的数据，源码如下：

  public T get() {
      Thread currentThread = Thread.currentThread(); //获取当前线程
      Values values = values(currentThread); //查找当前线程的本地储存区
      if (values != null) {
          Object[] table = values.table;
          int index = hash &amp; values.mask;
          if (this.reference == table[index]) {
              return (T) table[index + 1]; //返回当前线程储存区中的数据
          }
      } else {
          //创建Values对象
          values = initializeValues(currentThread);
      }
      return (T) values.getAfterMiss(this); //从目标线程存储区没有查询是则返回null
  }
</code></pre><p>ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的sThreadLocal变量，其定义如下：</p>
<p>static final ThreadLocal<looper> sThreadLocal = new ThreadLocal<looper>()</looper></looper></p>
<p>可见sThreadLocal的get()和set()操作的类型都是Looper类型。</p>
<p>Looper.prepare()</p>
<p>Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。</p>
<p>对于Looper类型的构造方法如下：</p>
<pre><code>private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed);  //创建MessageQueue对象. 【见4.1】
    mThread = Thread.currentThread();  //记录当前线程.
}
</code></pre><p>另外，与prepare()相近功能的，还有一个prepareMainLooper()方法，该方法主要在ActivityThread类中使用。</p>
<pre><code>public static void prepareMainLooper() {
    prepare(false); //设置不允许退出的Looper
    synchronized (Looper.class) {
        //将当前的Looper保存为主Looper，每个线程只允许执行一次。
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}
</code></pre><p>##2.2loop()</p>
<pre><code>public static void loop() {
    final Looper me = myLooper();  //获取TLS存储的Looper对象 【见2.4】
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;  //获取Looper对象中的消息队列

    Binder.clearCallingIdentity();
    //确保在权限检查时基于本地进程，而不是基于最初调用进程。
    final long ident = Binder.clearCallingIdentity();

    for (;;) { //进入loop的主循环方法
        Message msg = queue.next(); //可能会阻塞 【见4.2】
        if (msg == null) { //没有消息，则退出循环
            return;
        }

        Printer logging = me.mLogging;  //默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }
        msg.target.dispatchMessage(msg); //用于分发Message 【见3.2】
        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        final long newIdent = Binder.clearCallingIdentity(); //确保分发过程中identity不会损坏
        if (ident != newIdent) {
             //打印identity改变的log，在分发消息过程中是不希望身份被改变的。
        }
        msg.recycleUnchecked();  //将Message放入消息池 【见5.2】
    }
}
</code></pre><p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p>
<pre><code>读取MessageQueue的下一条Message；
把Message分发给相应的target；
再把分发后的Message回收到消息池，以便重复利用。
</code></pre><p>这是这个消息处理的核心部分。另外，上面代码中可以看到有logging方法，这是用于debug的，默认情况下logging == null，通过设置setMessageLogging()用来开启debug工作。</p>
<p>##2.3 quit()</p>
<pre><code>public void quit() {
    mQueue.quit(false); //消息移除
}

public void quitSafely() {
    mQueue.quit(true); //安全地消息移除
}

Looper.quit()方法的实现最终调用的是MessageQueue.quit()方法

MessageQueue.quit()

void quit(boolean safe) {
        // 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常
        if (!mQuitAllowed) {
            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);
        }
        synchronized (this) {
            if (mQuitting) { //防止多次执行退出操作
                return;
            }
            mQuitting = true;
            if (safe) {
                removeAllFutureMessagesLocked(); //移除尚未触发的所有消息
            } else {
                removeAllMessagesLocked(); //移除所有的消息
            }
            //mQuitting=false，那么认定为 mPtr != 0
            nativeWake(mPtr);
        }
    }
</code></pre><p>消息退出的方式：</p>
<pre><code>当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；
当safe =flase时，移除所有的消息
</code></pre><p>##2.4 常用方法</p>
<ul>
<li>2.4.1 myLooper</li>
</ul>
<p>用于获取TLS存储的Looper对象</p>
<pre><code>public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
</code></pre><ul>
<li>2.4.2 post</li>
</ul>
<p>发送消息，并设置消息的callback，用于处理消息。</p>
<pre><code>public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}

private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
</code></pre><h1 id="三、Handler"><a href="#三、Handler" class="headerlink" title="三、Handler"></a>三、Handler</h1><p>##3.1 创建Handler</p>
<ul>
<li><p>3.1.1 无参构造</p>
<pre><code>public Handler() {
    this(null, false);
}

public Handler(Callback callback, boolean async) {
    //匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露
    if (FIND_POTENTIAL_LEAKS) {
        final Class&lt;? extends Handler&gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }
    //必须先执行Looper.prepare()，才能获取Looper对象，否则为null.
    mLooper = Looper.myLooper();  //从当前线程的TLS中获取Looper对象【见2.1】
    if (mLooper == null) {
        throw new RuntimeException(&quot;&quot;);
    }
    mQueue = mLooper.mQueue; //消息队列，来自Looper对象
    mCallback = callback;  //回调方法
    mAsynchronous = async; //设置消息是否为异步处理方式
}
</code></pre></li>
</ul>
<p>对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。</p>
<ul>
<li><p>3.1.2 有参构造</p>
<pre><code>public Handler(Looper looper) {
    this(looper, null, false);
}

public Handler(Looper looper, Callback callback, boolean async) {
    mLooper = looper;
    mQueue = looper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
</code></pre></li>
</ul>
<p>Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。</p>
<p>##3.2 消息分发机制</p>
<p>在Looper.loop()中，当发现有消息时，调用消息的目标handler，执行dispatchMessage()方法来分发消息。</p>
<pre><code>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        //当Message存在回调方法，回调msg.callback.run()方法；
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            //当Handler存在Callback成员变量时，回调方法handleMessage()；
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        //Handler自身的回调方法handleMessage()
        handleMessage(msg);
    }
}
</code></pre><p>分发消息流程：</p>
<pre><code>当Message的回调方法不为空时，则回调方法msg.callback.run()，其中callBack数据类型为Runnable,否则进入步骤2；
当Handler的mCallback成员变量不为空时，则回调方法mCallback.handleMessage(msg),否则进入步骤3；
调用Handler自身的回调方法handleMessage()，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。
</code></pre><p>对于很多情况下，消息分发后的处理方法是第3种情况，即Handler.handleMessage()，一般地往往通过覆写该方法从而实现自己的业务逻辑。</p>
<p>##3.3 消息发送</p>
<p>发送消息调用链：<br><img src="/img/java_sendmessage.png" alt=""></p>
<p>从上图，可以发现所有的发消息方式，最终都是调用MessageQueue.enqueueMessage();</p>
<ul>
<li><p>3.3.1 sendEmptyMessage</p>
<pre><code>public final boolean sendEmptyMessage(int what)
{
    return sendEmptyMessageDelayed(what, 0);
}
</code></pre></li>
<li><p>3.3.2 sendEmptyMessageDelayed</p>
<pre><code>public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
    Message msg = Message.obtain();
    msg.what = what;
    return sendMessageDelayed(msg, delayMillis);
}
</code></pre></li>
<li><p>3.3.3 sendMessageDelayed</p>
<pre><code>public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis &lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
</code></pre></li>
<li><p>3.3.4 sendMessageAtTime</p>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre></li>
<li><p>3.3.5 sendMessageAtFrontOfQueue</p>
<pre><code>public final boolean sendMessageAtFrontOfQueue(Message msg) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        return false;
    }
    return enqueueMessage(queue, msg, 0);
}
</code></pre></li>
</ul>
<p>该方法通过设置消息的触发时间为0，从而使Message加入到消息队列的队头。</p>
<ul>
<li><p>3.3.6 post</p>
<pre><code>public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}

private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
</code></pre></li>
<li><p>3.3.7 postAtFrontOfQueue</p>
<pre><code>public final boolean postAtFrontOfQueue(Runnable r)
{
    return sendMessageAtFrontOfQueue(getPostMessage(r));
}
</code></pre></li>
<li><p>3.3.8 enqueueMessage</p>
<pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis); 【见4.3】
}
</code></pre></li>
<li><p>3.3.8 小节</p>
</li>
</ul>
<p>Handler.sendEmptyMessage()等系列方法最终调用MessageQueue.enqueueMessage(msg, uptimeMillis)，将消息添加到消息队列中，其中uptimeMillis为系统当前的运行时间，不包括休眠时间。</p>
<p>##3.4 其他方法</p>
<ul>
<li>3.4.1 obtainMessage</li>
</ul>
<p>获取消息</p>
<pre><code>public final Message obtainMessage()
{
    return Message.obtain(this); 【见5.2】
}
</code></pre><p>Handler.obtainMessage()方法，最终调用Message.obtainMessage(this)，其中this为当前的Handler对象。</p>
<ul>
<li><p>3.4.2 removeMessages</p>
<pre><code>public final void removeMessages(int what) {
    mQueue.removeMessages(this, what, null); 【见 4.5】
}
</code></pre></li>
</ul>
<p>Handler是消息机制中非常重要的辅助类，更多的实现都是MessageQueue, Message中的方法，Handler的目的是为了更加方便的使用消息机制。</p>
<h1 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h1><p>MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，其中MessageQueue类中涉及的native方法如下：</p>
<pre><code>private native static long nativeInit();
private native static void nativeDestroy(long ptr);
private native void nativePollOnce(long ptr, int timeoutMillis);
private native static void nativeWake(long ptr);
private native static boolean nativeIsPolling(long ptr);
private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);
</code></pre><p>关于这些native方法的介绍，可以查阅相关资料</p>
<p>##4.1 创建MessageQueue</p>
<pre><code>MessageQueue(boolean quitAllowed) {
    mQuitAllowed = quitAllowed;
    //通过native方法初始化消息队列，其中mPtr是供native代码使用
    mPtr = nativeInit();
}
</code></pre><p>##4.2 next()</p>
<p>提取下一条message</p>
<pre><code>Message next() {
    final long ptr = mPtr;
    if (ptr == 0) { //当消息循环已经退出，则直接返回
        return null;
    }
    int pendingIdleHandlerCount = -1; // 循环迭代的首次为-1
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        //阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回
        nativePollOnce(ptr, nextPollTimeoutMillis);
        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                //当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，则退出循环。
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    //当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // 获取一条消息，并返回
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    //设置消息的使用状态，即flags |= FLAG_IN_USE
                    msg.markInUse();
                    return msg;   //成功地获取MessageQueue中的下一条即将要执行的消息
                }
            } else {
                //没有消息
                nextPollTimeoutMillis = -1;
            }
            //消息正在退出，返回null
            if (mQuitting) {
                dispose();
                return null;
            }
            //当消息队列为空，或者是消息队列的第一个消息时
            if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                //没有idle handlers 需要运行，则循环并等待。
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        //只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; //去掉handler的引用
            boolean keep = false;
            try {
                keep = idler.queueIdle();  //idle时执行的方法
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        //重置idle handler个数为0，以保证不会再次重复运行
        pendingIdleHandlerCount = 0;
        //当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre><p>nativePollOnce是阻塞操作，其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。</p>
<p>当处于空闲时，往往会执行IdleHandler中的方法。当nativePollOnce()返回后，next()从mMessages中提取一个消息。</p>
<p>nativePollOnce()在native做了大量的工作，想进一步了解可查看 Android消息机制2-Handler(native篇)。</p>
<p>##4.3 enqueueMessage</p>
<p>添加一条消息到消息队列</p>
<pre><code>boolean enqueueMessage(Message msg, long when) {
    // 每一个Message必须有一个target
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
    }
    synchronized (this) {
        if (mQuitting) {  //正在退出时，回收msg，加入到消息池
            msg.recycle();
            return false;
        }
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
            //p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked; //当阻塞时需要唤醒
        } else {
            //将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非
            //消息队头存在barrier，并且同时Message是队列中最早的异步消息。
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p;
            prev.next = msg;
        }
        //消息没有退出，我们认为此时mPtr != 0
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
</code></pre><p>MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<p>##4.4 removeMessages</p>
<pre><code>void removeMessages(Handler h, int what, Object object) {
    if (h == null) {
        return;
    }
    synchronized (this) {
        Message p = mMessages;
        //从消息队列的头部开始，移除所有符合条件的消息
        while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what
               &amp;&amp; (object == null || p.obj == object)) {
            Message n = p.next;
            mMessages = n;
            p.recycleUnchecked();
            p = n;
        }
        //移除剩余的符合要求的消息
        while (p != null) {
            Message n = p.next;
            if (n != null) {
                if (n.target == h &amp;&amp; n.what == what
                    &amp;&amp; (object == null || n.obj == object)) {
                    Message nn = n.next;
                    n.recycleUnchecked();
                    p.next = nn;
                    continue;
                }
            }
            p = n;
        }
    }
}
</code></pre><p>这个移除消息的方法，采用了两个while循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p>
<h1 id="五、-Message"><a href="#五、-Message" class="headerlink" title="五、 Message"></a>五、 Message</h1><h2 id="5-1-创建消息"><a href="#5-1-创建消息" class="headerlink" title="5.1 创建消息"></a>5.1 创建消息</h2><p>每个消息用Message表示，Message主要包含以下内容：<br>        数据类型     成员变量     解释<br>        int     what     消息类别<br>        long     when     消息触发时间<br>        int     arg1     参数1<br>        int     arg2     参数2<br>        Object     obj     消息内容<br>        Handler     target     消息响应方<br>        Runnable     callback     回调方法</p>
<p>创建消息的过程，就是填充消息的上述内容的一项或多项。</p>
<p>##5.2 消息池</p>
<p>在代码中，可能经常看到recycle()方法，咋一看，可能是在做虚拟机的gc()相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p>
<p>静态变量sPool的数据类型为Message，通过next成员变量，维护一个消息池；静态变量MAX_POOL_SIZE代表消息池的可用大小；消息池的默认大小为50。</p>
<p>消息池常用的操作方法是obtain()和recycle()。</p>
<ul>
<li>5.2.1 obtain</li>
</ul>
<p>从消息池中获取消息</p>
<pre><code>public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null; //从sPool中取出一个Message对象，并消息链表断开
            m.flags = 0; // 清除in-use flag
            sPoolSize--; //消息池的可用大小进行减1操作
            return m;
        }
    }
    return new Message(); // 当消息池为空时，直接创建Message对象
}
</code></pre><p>obtain()，从消息池取Message，都是把消息池表头的Message取走，再把表头指向next;</p>
<ul>
<li>5.2.2 recycle</li>
</ul>
<p>把不再使用的消息加入消息池</p>
<pre><code>public void recycle() {
    if (isInUse()) { //判断消息是否正在使用
        if (gCheckRecycle) { //Android 5.0以后的版本默认为true,之前的版本默认为false.
            throw new IllegalStateException(&quot;This message cannot be recycled because it is still in use.&quot;);
        }
        return;
    }
    recycleUnchecked();
}
</code></pre><p>//对于不再使用的消息，加入到消息池</p>
<pre><code>void recycleUnchecked() {
    //将消息标示位置为IN_USE，并清空消息所有的参数。
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = -1;
    when = 0;
    target = null;
    callback = null;
    data = null;
    synchronized (sPoolSync) {
        if (sPoolSize &lt; MAX_POOL_SIZE) { //当消息池没有满时，将Message对象加入消息池
            next = sPool;
            sPool = this;
            sPoolSize++; //消息池的可用大小进行加1操作
        }
    }
}
</code></pre><p>recycle()，将Message加入到消息池的过程，都是把Message加到链表的表头；</p>
<p>#六、总结</p>
<p>最后用一张图，来表示整个消息机制</p>
<p>图解：<br><img src="/img/handler_java.jpg" alt=""> </p>
<pre><code>Handler通过sendMessage()发送Message到MessageQueue队列；
Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；
经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。
将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。
</code></pre><p>消息分发的优先级：</p>
<pre><code>Message的回调方法：message.callback.run()，优先级最高；
Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于1；
Handler的默认方法：Handler.handleMessage(msg)，优先级最低。
</code></pre>]]></content>
    
    <summary type="html">
    
      这是一篇很好的Android的线程间通信的文章
    
    </summary>
    
      <category term="Android的线程间通信" scheme="http://yoursite.com/categories/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="Android的线程间通信" scheme="http://yoursite.com/tags/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android下的性能优化</title>
    <link href="http://yoursite.com/2016/05/31/android%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/05/31/android下的性能优化全解析/</id>
    <published>2016-05-31T13:16:33.000Z</published>
    <updated>2016-12-19T13:24:52.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下的性能优化"><a href="#Android下的性能优化" class="headerlink" title="Android下的性能优化"></a>Android下的性能优化</h1><h4 id="android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM-而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR-由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。"><a href="#android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM-而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR-由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。" class="headerlink" title="android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM,而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR,由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。"></a>android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM,而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR,由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。</h4><blockquote>
<p>1.布局优化</p>
</blockquote>
<ul>
<li>删除无用的控件和层级。可以使用HierarchyViewer来查看布局层级。</li>
<li>在布局层级相同的情况下，使用LinearLayout的效率比使用RelativeLayout的性能要高，因为RelativeLayout的性能要高，因为RelativeLayout的功能比较复杂，它的CPU渲染时间比较长，而LinearLayout和FragmentLayout都是简单高效的ViewGroup。</li>
<li>include标签配合merge标签使用来重用布局、减少布局层数。</li>
<li>使用ViewStub。它是一个非常轻量级的View，宽高都是0，因此它本身不参与任何布局和绘制的过程，它的意义在于按需加载所需要的布局，使用的时候再加载，不需要的时候不加载进来，提高程序初始化的性能，注意：ViewStub与设置visibility之间的差异；设置visibility只是可见，就算设置inVisible或者GONE，布局还是会加载的。</li>
</ul>
<blockquote>
<p>2.绘制优化</p>
</blockquote>
<ul>
<li>onDraw方法里不要做初始化对象的操作，因为onDraw方法会被频繁的调用。</li>
<li>onDraw方法不要做耗时的操作，这样会造成View的绘制过程不流畅。</li>
</ul>
<blockquote>
<p>3.内存泄漏优化</p>
</blockquote>
<ul>
<li>资源未关闭。使用了broadCastReceiver，ContentObserver,file,Cursor,Stream,Bitmap等资源的使用，应该在Avtivity销毁时及时的关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</li>
<li>静态成员变量持有类的引用。</li>
<li>非静态内部类持有外部类的引用，使用非静态内部类创建的静态变量。</li>
<li>单例引起的内存泄漏。</li>
<li>Handler造成的内存泄漏。</li>
<li>线程的生命周期不可控。</li>
<li>无限循环的属性动画引起的内存泄漏。</li>
</ul>
<blockquote>
<p>4.响应速度和ANR日志分析</p>
</blockquote>
<ul>
<li>响应速度优化的核心思想就是避免在主线程中做耗时操作，但是有的时候确实有很多耗时的操作，那就必须将这些耗时的操作放在线程中去执行，即采用异步的方式执行耗时的操作。</li>
<li>在实际开发中，ANR是很难从代码上发现的，如果在开发的过程中遇到了ANR,那么怎么定位问题呢？其实在一个进程发生ANR后，系统会在/data/anr目录下创建一个文件traces.txt,通过分析这个文件就能定位出ANR的原因。</li>
</ul>
<blockquote>
<p>5.Bitmap优化</p>
</blockquote>
<ul>
<li>目前比较常用的缓存策略是LruChache和DiskLruCache,其中LruCache常被用做内存缓存，而DiskLruCache常用做存储缓存。Lru是least Tecently Used的缩写，即最近最少使用算法，这种算法的核心思想为：当缓存快满的时候，会淘汰近期最少使用的缓存目标。</li>
<li>高效加载Bitmap的核心思想，其实很简单，那就是采用BitmapFactory.Options来加载所需的图片尺寸。主要用到了它的inSampleSize参数即采样率。</li>
</ul>
<blockquote>
<p>6.ListView优化</p>
</blockquote>
<ul>
<li>在adapter的getVIew（）方法里尽量少使用逻辑；</li>
<li>滑动的时候不要加载图片；</li>
<li>图片的加载使用异步方式；</li>
<li>将listView的scrollingCache和animateCache设置为false. scrollingCache本质上是drawing cache，你可以让一个View将他自己的drawing保存在cache中（保存为一个bitmap），这样下次再显示View的时候就不用重画了，而是从cache中取出。默认情况下drawing cahce是禁用的，因为它太耗内存了，但是它确实比重画来的更加平滑。而在ListView中，scrollingCache是默认开启的，我们可以手动将它关闭。ListView默认开启了animateCache，这会消耗大量的内存，因此会频繁调用GC，我们可以手动将它关闭掉。</li>
<li>listview 被多层嵌套，多次的onMessure导致卡顿，如果多层嵌套无法避免，建议把listview的高和宽设置为fill_parent. 如果是代码继承的listview，那么也请你别忘记为你的继承类添加上LayoutPrams，注意高和宽都是fill_parent的;  以往我一般都是将listview的高度设置成fill_parent，而这次我是设为wrap_content，这样做的问题在于，ListView没有取到实际的高度，他还要根据计算才能确定，而每一次计算应该会触发listview的渲染，所以就会出现getview的调用次数跟正常情况相比多了好几倍。所以在一般情况下，我建议把listiview在布局文件中的高度总是设置为：fill_parent（或者match_parent），这不仅仅是getview的调用次数问题，还涉及到布局的效率。</li>
<li>使用静态的viewHolder。</li>
</ul>
<blockquote>
<p>7.线程优化</p>
</blockquote>
<ul>
<li>线程优化的思想是采用线程池，避免程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了线程的创建和销毁带来的性能开销，同时线程池还能还能有效地控制线程池的最大并发数，避免大量的线程相互抢占系统资源从而导致阻塞现象的发生。因此在实际的开发中，我们应该尽量的采用线程池，而不是每次都创建一个Thread对象。</li>
</ul>
<blockquote>
<p>8.数据库优化</p>
</blockquote>
<ul>
<li>使用事务。大量的数据的增删如果不使用事务，而是循环调用Insert和Delete的话，会因为每一笔操作都需要打开、写入最后关闭Journal文件（这个文件是临时用来保存数据操作的中间结果）而使得开销非常大。<br>  使用的方法：<br>  db.beginTransaction();<br>  db.setTransactionSuccessful();<br>  db.endTransaction();</li>
<li>使用索引。索引维护这一个表某一列或者某几列的顺序，这样就可以快速的定位到某一组值，而不是扫描全表。所有的索引信息会被保存到一个独立的索引表中，所以会产生额外的空间占用，不过绝对物超所值，特别是你会在数据库中进行大量的读及搜索操作的时候。</li>
<li>sql语句拼接的时候用StringBuffer代替String</li>
<li>在写表的时候调用sqliteOpenHelper&amp;getWritableDatabase()，在读表的时候调用SqliteOpenHelper&amp;getReadableDatabase()</li>
<li>开启子线程进行数据库的读写</li>
</ul>
<blockquote>
<p>9.一些性能优化建议</p>
</blockquote>
<ul>
<li>避免创建过多的对象</li>
<li>不要过多的使用枚举，枚举占用的内存空间要比整形大</li>
<li>常量请使用static final来修饰</li>
<li>使用一些android特有的数据结构，比如SparseArray和Pair等，他们都具有更好的性能</li>
<li>适当的使用软引用和弱引用</li>
<li>采用内存缓存和磁盘缓存</li>
<li>尽量采用静态内部类。这样可以避免潜在的内部类而导致的内存泄漏</li>
<li>尽量使用google推荐的处理方式。比如序列化采用parcelable,而不用Serializable</li>
</ul>
<blockquote>
<p>10.内存优化可能会用到的工具（</p>
</blockquote>
<ul>
<li>HierarchyViewer（检查布局层级）</li>
<li>TraceView（对应用中方法耗时进行统计）</li>
<li>APT(对进程的CPU和内存进行监视和分析)</li>
<li>MAT(对内存泄漏分析的主要工具)</li>
</ul>
<blockquote>
<p>11.提高程序的可维护性</p>
</blockquote>
<ul>
<li>提高代码的可读性</li>
<li>灵活应用面向对象语言的三大特性和六大原则从而达成对修改关闭，对扩展开放的终极目标。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下的性能优化的文章
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android,性能优化" scheme="http://yoursite.com/tags/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java的JVM详解</title>
    <link href="http://yoursite.com/2016/05/09/Java%20JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/05/09/Java JVM内存模型详解/</id>
    <published>2016-05-09T01:21:12.000Z</published>
    <updated>2017-06-14T12:59:00.029Z</updated>
    
    <content type="html"><![CDATA[<p>#java JVM内存模型详解</p>
<blockquote>
<p>java是在java虚拟机上运行，一般地大家讲到的Java内存其实就是Jvm内存</p>
</blockquote>
<h2 id="一、内存模型"><a href="#一、内存模型" class="headerlink" title="一、内存模型"></a>一、内存模型</h2><p>Java内存模型，往往是指Java程序在运行时内存的模型，而Java代码是运行在Java虚拟机之上的，由Java虚拟机通过解释执行(解释器)或编译执行(即时编译器)来完成，故Java内存模型，也就是指Java虚拟机的运行时内存模型。</p>
<p>作为Java开发人员来说，并不需要像C/C++开发人员，需要时刻注意内存的释放，而是全权交给虚拟机去管理，那么有就必要了解虚拟机的运行时内存是如何构成的。运行时内存模型，分为线程私有和共享数据区两大类，其中线程私有的数据区包含程序计数器、虚拟机栈、本地方法区，所有线程共享的数据区包含Java堆、方法区，在方法区内有一个常量池。</p>
<p><img src="/img/jvm/jvm_memory_1.png" alt="jvm_memory_1"></p>
<p>（1）线程私有区：</p>
<ul>
<li>程序计数器，记录正在执行的虚拟机字节码的地址；</li>
<li>虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；</li>
<li>本地方法栈：虚拟机的Native方法执行的内存区；</li>
</ul>
<p>（2）线程共享区：</p>
<ul>
<li>Java堆：对象分配内存的区域；</li>
<li>方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；<ul>
<li>常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。</li>
</ul>
</li>
</ul>
<p>对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈，然而Java内存模型远比这更复杂，想深入了解Java的内存，还是有必要明白整个内存模型。</p>
<h2 id="二、-详细模型"><a href="#二、-详细模型" class="headerlink" title="二、 详细模型"></a>二、 详细模型</h2><p>运行时内存分为五大块区域（常量池属于方法区，算作一块区域），前面简要介绍了每个区域的功能，那接下来再详细说明每个区域的内容，Java内存总体结构图如下：</p>
<p><img src="/img/jvm/stack_heap_info.png" alt="stack_heap_info"></p>
<h3 id="2-1-程序计数器PC"><a href="#2-1-程序计数器PC" class="headerlink" title="2.1 程序计数器PC"></a>2.1 程序计数器PC</h3><p>程序计数器PC，当前线程所执行的字节码行号指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。</p>
<p>当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址；当线程正在执行的一个Native方法时，PC计数器则为空（Undefined）。</p>
<h3 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h3><p>虚拟机栈，生命周期与线程相同，是Java方法执行的内存模型。每个方法(不包含native方法)执行的同时都会创建一个栈帧结构，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。</p>
<p><strong>栈帧(Stack Frame)结构</strong></p>
<p>栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机站的栈元素。见上图， 栈帧包括：</p>
<ol>
<li>局部变量表 (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位。</li>
<li>操作栈(stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配</li>
<li>动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。<ul>
<li>前面的解析过程其实是静态解析；</li>
<li>对于运行期转化为直接引用，称为动态解析。</li>
</ul>
</li>
<li>方法返回地址<ul>
<li>正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者</li>
<li>异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。</li>
</ul>
</li>
<li>额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。</li>
</ol>
<p>因此，一个栈帧的大小不会受到</p>
<p><strong>异常(Exception)</strong></p>
<p>Java虚拟机规范规定该区域有两种异常：</p>
<ul>
<li>StackOverFlowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出</li>
<li>OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出</li>
</ul>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>本地方法栈则为虚拟机使用到的Native方法提供内存空间，而前面讲的虚拟机栈式为Java方法提供内存空间。有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如非常典型的Sun HotSpot虚拟机。</p>
<p><strong>异常(Exception)</strong>：Java虚拟机规范规定该区域可抛出StackOverFlowError和OutOfMemoryError。</p>
<h3 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h3><p>Java堆，是Java虚拟机管理的最大的一块内存，也是GC的主战场，里面存放的是几乎所有的对象实例和数组数据。JIT编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在Java堆，而是栈内存。</p>
<ul>
<li>从内存回收角度，Java堆被分为新生代和老年代；这样划分的好处是为了更快的回收内存；</li>
<li>从内存分配角度，Java堆可以划分出线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)；这样划分的好处是为了更快的分配内存；</li>
</ul>
<p>对象创建的过程是在堆上分配着实例对象，那么对象实例的具体结构如下：</p>
<p><img src="/img/jvm/java_object.png" alt="java_object"></p>
<p>对于填充数据不是一定存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例数据不是8的倍数，便需要填充数据来保证8字节的对齐。该功能类似于高速缓存行的对齐。</p>
<p>另外，关于在堆上内存分配是并发进行的，虚拟机采用CAS加失败重试保证原子操作，或者是采用每个线程预先分配TLAB内存.</p>
<p><strong>异常(Exception)</strong>：Java虚拟机规范规定该区域可抛出OutOfMemoryError。</p>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。GC在该区域出现的比较少。</p>
<p><strong>异常(Exception)</strong>：Java虚拟机规范规定该区域可抛出OutOfMemoryError。</p>
<h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译期产生的Class文件的常量池，还可以在运行期间，将新的常量加入常量池，比较常见的是String类的intern()方法。</p>
<ul>
<li>字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。</li>
<li>符号引用：编译语言层面的概念，包括以下3类：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>但是该区域不会抛出OutOfMemoryError异常。</p>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述java JVM内存模型的文章
    
    </summary>
    
      <category term="java JVM memory" scheme="http://yoursite.com/categories/java-JVM-memory/"/>
    
    
      <category term="java JVM memory" scheme="http://yoursite.com/tags/java-JVM-memory/"/>
    
  </entry>
  
  <entry>
    <title>Linux的内存详解</title>
    <link href="http://yoursite.com/2016/04/19/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/04/19/linux内存管理详解/</id>
    <published>2016-04-19T01:21:12.000Z</published>
    <updated>2017-06-14T12:59:48.715Z</updated>
    
    <content type="html"><![CDATA[<p>关于Linux的内存管理，本文分别从内核空间和用户空间两个视角来阐述</p>
<h2 id="一、内核空间"><a href="#一、内核空间" class="headerlink" title="一、内核空间"></a>一、内核空间</h2><h3 id="1-1-页"><a href="#1-1-页" class="headerlink" title="1.1 页"></a>1.1 页</h3><p>页(page)是内核的内存管理基本单位。</p>
<p>==&gt; linux/mm_types.h</p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct page &#123;</div><div class="line">       page_flags_t flags;  页标志符</div><div class="line">       atomic_t _count;    页引用计数</div><div class="line">       atomic_t _mapcount;     页映射计数</div><div class="line">       unsigned long private;    私有数据指针</div><div class="line">       struct address_space *mapping;    该页所在地址空间描述结构指针，用于内容为文件的页帧</div><div class="line">       pgoff_t index;               该页描述结构在地址空间radix树page_tree中的对象索引号即页号</div><div class="line">       struct list_head lru;        最近最久未使用struct slab结构指针链表头变量</div><div class="line">       void *virtual;               页虚拟地址</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br></div>

<ul>
<li>flags：页标志包含是不是脏的，是否被锁定等等，每一位单独表示一种状态，可同时表示出32种不同状态，定义在<linux page-flags.h=""></linux></li>
<li>_count：计数值为-1表示未被使用。</li>
<li>virtual：页在虚拟内存中的地址，对于不能永久映射到内核空间的内存(比如高端内存)，该值为NULL；需要事必须动态映射这些内存。</li>
</ul>
<p>尽管处理器的最小可寻址单位通常为字或字节，但内存管理单元(MMU，把虚拟地址转换为物理地址的硬件设备)通常以页为单位处理。内核用struct page结构体表示每个物理页，struct page结构体占40个字节，假定系统物理页大小为4KB，对于4GB物理内存，1M个页面，故所有的页面page结构体共占有内存大小为40MB，相对系统4G，这个代价并不高。</p>
<h3 id="1-2-区"><a href="#1-2-区" class="headerlink" title="1.2 区"></a>1.2 区</h3><p>内核把页划分在不同的区(zone)</p>
<p>总共3个区，具体如下：</p>
<table>
<thead>
<tr>
<th>区</th>
<th>描述</th>
<th>物理内存（MB）</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>DMA使用的页</td>
<td>&lt;16</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>可正常寻址的页</td>
<td>16 ~896</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>动态映射的页</td>
<td>&gt;896</td>
</tr>
</tbody>
</table>
<ul>
<li>执行DMA操作的内存必须从ZONE_DMA区分配</li>
<li>一般内存，既可从ZONE_DMA，也可从ZONE_NORMAL分配，但不能同时从两个区分配；</li>
</ul>
<h3 id="1-3-页分配与释放"><a href="#1-3-页分配与释放" class="headerlink" title="1.3 页分配与释放"></a>1.3 页分配与释放</h3><p>下面列举所有的页为单位进行连续物理内存分配，也称为低级页分配器：</p>
<table>
<thead>
<tr>
<th>页分配函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>分配2^order个页，返回指向第一页的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask)</td>
<td>分配一页，返回指向页的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>分配2^order个页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask)</td>
<td>分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>分配一页，并填充内容为0，返回指向其逻辑地址的指针</td>
</tr>
</tbody>
</table>
<ul>
<li>get_zeroed_page：对于用户空间，这个方法能保障系统敏感数据不会泄露</li>
<li>page_address: 把给定的页转换成逻辑地址</li>
</ul>
<table>
<thead>
<tr>
<th>页释放函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__free_pages(page, order)</td>
<td>从page开始，释放2^order个页</td>
</tr>
<tr>
<td>free_pages(addr, order)</td>
<td>从地址addr开始，释放2^order个页</td>
</tr>
<tr>
<td>free_page(addr)</td>
<td>释放addr所在的那一页</td>
</tr>
</tbody>
</table>
<h3 id="1-4-字节分配与释放"><a href="#1-4-字节分配与释放" class="headerlink" title="1.4 字节分配与释放"></a>1.4 字节分配与释放</h3><p>kmalloc，vmalloc分配都是以字节为单位</p>
<p><strong>(1) kmalloc</strong></p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void * kmalloc(size_t size, gfp_t flags)</div></pre></td></tr></table></figure><br><br></div>

<p>该函数返回的是一个指向内存块的指针，其内存块大小至少为size,所分配的内存在<strong>物理内存</strong>中连续且保持原有的数据(不清零)</p>
<p>其中部分flags取值说明：</p>
<ul>
<li>GFP_USER： 用于用户空间的分配内存，可能休眠；</li>
<li>GFP_KERNEL：用于内核空间的内存分配，可能休眠；</li>
<li>GFP_ATOMIC：用于原子性的内存分配，不会休眠；典型原子性场景有中断处理程序，软中断，tasklet等</li>
</ul>
<p>kmalloc内存分配最终总是调用__get_free<em>pages 来进行实际的分配，故前缀都是GFP</em>开头。 kmalloc分最多只能分配32个page大小的内存，每个page=4k，也就是128K大小，其中16个字节用来记录页描述结构。kmalloc分配的是常驻内存，不会被交换到文件中。最小分配单位是32或64字节。</p>
<p><strong>kzalloc</strong></p>
<p><code>kzalloc()</code>等价于先用 <code>kmalloc()</code> 申请空间， 再用<code>memset()</code>来初始化，所有申请的元素都被初始化为0。</p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static inline void *kzalloc(size_t size, gfp_t flags)</div><div class="line">&#123;</div><div class="line">    return kmalloc(size, flags | __GFP_ZERO); //通过或标志位__GFP_ZERO，初始化元素为0</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></div>

<p><strong>(2) vmalloc</strong></p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void * vmalloc(unsigned long size)</div></pre></td></tr></table></figure><br><br></div>

<p>该函数返回的是一个指向内存块的指针，其内存块大小至少为size,所分配的内存是<strong>逻辑上连续</strong>的。</p>
<p>kmalloc不同，该函数乜有flags,默认是可以休眠的。</p>
<p><strong>小结：</strong></p>
<table>
<thead>
<tr>
<th>分配函数</th>
<th>区域</th>
<th>连续性</th>
<th>大小</th>
<th>释放函数</th>
<th>优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>kmalloc</td>
<td>内核空间</td>
<td>物理地址连续</td>
<td>最大值128K-16</td>
<td>kfree</td>
<td>性能更佳</td>
</tr>
<tr>
<td>vmalloc</td>
<td>内核空间</td>
<td>虚拟地址连续</td>
<td>更大</td>
<td>vfree</td>
<td>更易分配大内存</td>
</tr>
<tr>
<td>malloc</td>
<td>用户空间</td>
<td>虚拟地址连续</td>
<td>更大</td>
<td>free</td>
</tr>
</tbody>
</table>
<h3 id="1-5-slab层"><a href="#1-5-slab层" class="headerlink" title="1.5 slab层"></a>1.5 slab层</h3><p>slab分配器的作用：</p>
<ul>
<li>对于频繁地分配和释放的数据结构，会缓存它；</li>
<li>频繁分配和回收比如导致内存碎片，为了避免，空闲链表的缓存会连续的存放，已释放的数据结构又会放回空闲链表，不会导致碎片；</li>
<li>让部分缓存专属单个处理器，分配和释放操作可以不加SMP锁；</li>
</ul>
<p>slab层把不同的对象划分为高速缓存组，每个高速缓存组都存放不同类型的对象，每个对象类型对应一个高速缓存。kmalloc接口监理在slab层只是，使用一组通用高速缓存。</p>
<p>每个高速缓存都是用kmem_cache结构来表示</p>
<ul>
<li>kmem_cache_crreate：创建高速缓存</li>
<li>kmem_cache_destroy: 撤销高速缓存</li>
<li>kmem_cache_alloc: 从高速缓存中返回一个指向对象的指针</li>
<li>kmem_cache_free：释放一个对象</li>
</ul>
<p>实例分析： 内核初始化期间，/kernel/fork.c的fork_init()中会创建一个名叫task_struct的高速缓存； 每当进程调用fork（）时，会通过dup_task_struct()创建一个新的进程描述符，并调用do_fork(),完成从高速缓存中获取对象。</p>
<h3 id="1-6-栈的静态分配"><a href="#1-6-栈的静态分配" class="headerlink" title="1.6 栈的静态分配"></a>1.6 栈的静态分配</h3><p>当设置单页内核栈，那么每个进程的内核栈只有一页大小，这取决于编译时配置选项。 好处：</p>
<ul>
<li>可以减少每个进程内存的消耗；</li>
<li>随着机器运行时间的增加，寻找两个未分配的、连续的页越来越困难，物理内存碎片化不断加重，那么给每个新进程分配虚拟内存的压力也增大；</li>
<li>每个进程的调用链在自己的内核栈中，当单页栈选项被激活时，中断处理程序可获得自己的栈；</li>
</ul>
<p>任意函数必须尽量节省栈资源， 方法就是所有函数让局部变量所占空间之和不要超过几百字节。</p>
<h3 id="1-7-高端内存的映射"><a href="#1-7-高端内存的映射" class="headerlink" title="1.7 高端内存的映射"></a>1.7 高端内存的映射</h3><p>高端内存中的页不能永久地映射到内核地址空间。</p>
<ul>
<li>kmap：把给定page结构映射到内核地址空间；<ul>
<li>当page位于低端内存，函数返回该页的虚拟地址</li>
<li>当page位于高端内存，建立一个永久映射，再返回地址</li>
</ul>
</li>
<li>kunmap: 永久映射的数量有限，应通过kunmap及时解除映射</li>
<li>kmap_atomic: 临时映射</li>
<li>kunmap_atomic: 解除临时映射</li>
</ul>
<h3 id="1-8-每个CPU数据"><a href="#1-8-每个CPU数据" class="headerlink" title="1.8 每个CPU数据"></a>1.8 每个CPU数据</h3><ul>
<li>alloc_percpu: 给系统的每个处理器分配一个指定类型对象的实例，以单字节对齐；</li>
<li>free_percpu: 释放每个处理器的对象实例；</li>
<li>get_cpu_var: 返回一个执行当前处理器数据的特殊实例，同时会禁止内核抢占</li>
<li>put_cpu_var: 会重新激活内核抢占</li>
</ul>
<p>使用每个CPU数据好处：</p>
<ul>
<li>减少了数据锁定，每个CPU访问自己CPU数据</li>
<li>大大减少缓存失效，失效往往发生在一个处理器操作某个数据，而其他处理器缓存了该数据，那么必须清理或刷新缓存。持续不断的缓存失效称为缓存抖动。</li>
</ul>
<h3 id="1-9-小结"><a href="#1-9-小结" class="headerlink" title="1.9 小结"></a>1.9 小结</h3><p>分配函数选择：</p>
<ol>
<li>连续的物理页，使用低级页分配器 或kmalloc();</li>
<li>高端内存分配，使用alloc_pages(),返回page结构指针； 想获取地址指针，应使用kmap(),把高端内存映射到内核的逻辑地址空间；</li>
<li>仅仅需要虚拟地址连续页，使用vmalloc()，性能有所损失；</li>
<li>频繁创建和撤销大量数据结构，考虑建立slab高速缓存。</li>
</ol>
<h2 id="二、用户空间"><a href="#二、用户空间" class="headerlink" title="二、用户空间"></a>二、用户空间</h2><p>用户空间中进程的内存，往往称为进程地址空间。Linux采用虚拟内存技术</p>
<h3 id="2-1-地址空间"><a href="#2-1-地址空间" class="headerlink" title="2.1 地址空间"></a>2.1 地址空间</h3><p>每个进程都有一个32位或64位的地址空间，取决于体系结构。 一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，也彼此互不相干，对于这种共享地址空间的进程称之为线程。一个进程可寻址4GB的虚拟内存（32位地址空间中），但不是所有虚拟地址都有权访问。对于进程可访问的地址空间称为内存区域。每个内存区域都具有对相关进程的可读、可写、可执行属性等相关权限设置。</p>
<p>内存区域可包含的对象：</p>
<ul>
<li>代码段(text section)： 可执行文件代码</li>
<li>数据段(data section)： 可执行文件的已初始化全局变量（静态分配的变量和全局变量）。</li>
<li>bss段：程序中未初始化的全局变量，零页映射（页面的信息全部为0值）。</li>
<li>进程用户空间栈的零页映射（进程的内核栈独立存在并由内核维护）</li>
<li>每一个诸如C库或动态连接程序等共享库的代码段、数据段和bss也会被载入进程的地址空间</li>
<li>任何内存映射文件</li>
<li>任何共享内存段</li>
<li>任何匿名的内存映射（比如由malloc()分配的内存）</li>
</ul>
<p>这些内存区域不能相互覆盖，每一个进程都有不同的内存片段。</p>
<h3 id="2-2-内存描述符"><a href="#2-2-内存描述符" class="headerlink" title="2.2 内存描述符"></a>2.2 内存描述符</h3><p>内存描述符由<code>mm_struct</code>结构体表示，</p>
<p>==&gt; linux/sched.h</p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct mm_struct</div><div class="line">&#123;</div><div class="line">    struct vm_area_struct *mmap;</div><div class="line">    rb_root_t mm_rb;</div><div class="line">    ...</div><div class="line">    atomic_t mm_users;</div><div class="line">    atomic_t mm_count;</div><div class="line"></div><div class="line">    struct list_head mmlist;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br></div>

<ul>
<li>mm_users：代表正在使用该地址的进程数目，当该值为0时mm_count也变为0；</li>
<li>mm_count: 代表mm_struct的主引用计数，当该值为0说明没有任何指向该mm_struct结构体的引用，结构体会被撤销。</li>
<li>mmap和mm_rb：描述的对象都是相同的<ul>
<li>mmap以链表形式存放， 利于高效地遍历所有元素</li>
<li>mm_rb以红黑树形式存放，适合搜索指定元素</li>
</ul>
</li>
<li>mmlist：所有的mm_struct结构体都通过mmlist连接在一个双向链表中，该链表的首元素是init_mm内存描述符，它代表init进程的地址空间。</li>
</ul>
<p>在进程的进程描述符（<linux sched.h="">中定义的task_struct结构体）中，mm域记录该进程使用的内存描述符。故current-&gt;mm代表当前进程的内存描述符。</linux></p>
<p><strong>fork()函数</strong> 利用copy_mm函数复制父进程的内存描述符，子进程中的mm_struct结构体通过allcote_mm()从高速缓存中分配得到。通常，每个进程都有唯一的mm_struct结构体，即唯一的进程地址空间。</p>
<p>当子进程与父进程是共享地址空间，可调用clone()，那么不再调用allcote_mm()，而是仅仅是将mm域指向父进程的mm，即 tsk-&gt;mm = current-&gt;mm。</p>
<p>相反地，撤销内存是exit_mm()函数，该函数会进行常规的撤销工作，更新一些统计量。</p>
<p><strong>内核线程</strong></p>
<ul>
<li>没有进程地址空间，即内核线程对应的进程描述符中mm=NULL</li>
<li>内核线程直接使用前一个进程的内存描述符，仅仅使用地址空间中和内核内存相关的信息</li>
</ul>
<h3 id="2-3-虚拟内存区域-VMA"><a href="#2-3-虚拟内存区域-VMA" class="headerlink" title="2.3 虚拟内存区域(VMA)"></a>2.3 虚拟内存区域(VMA)</h3><p>虚拟内存区域由vm_area_struct结构体描述， 指定地址空间内连续区间的一个独立内存范围。 每个VMA代表不同类型的内存区域。</p>
<p>==&gt; linux/mm_types.h</p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct vm_area_struct &#123;</div><div class="line">    struct mm_struct * vm_mm;  //内存描述符</div><div class="line">    unsigned long  vm_start;   //区域的首地址</div><div class="line">    unsigned long vm_end;      //区域的尾地址</div><div class="line">    struct vm_area_struct * vm_next; //VMA链表</div><div class="line">    pgrot t_vm_page_prot;   //访问控制权限</div><div class="line">    unsigned long vm_flags;   //保护标志位和属性标志位</div><div class="line">    struct rb_node_ vm_rb;   //VMA的红黑树结构</div><div class="line">    ...</div><div class="line">    struct vm_operations_struct * vm_ops; //相关的操作表</div><div class="line">    struct file * vm_file; //指向被映射的文件的指针</div><div class="line">    void * vm_private_data; //设备驱动私有数据，与内存管理无关。</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></div>

<p>每个内存描述符对应于进程地址空间的唯一区间，vm_end - vm_start便是内存区间的长度。</p>
<p><strong>VMA操作</strong></p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct vm_operations_struct &#123;</div><div class="line">    void (*open) (struct vm_area_struct * area);</div><div class="line">    void (*close) (struct vm_area_struct * area);</div><div class="line">    struct page * (*nopage)(struct vm_area_struct *area, unsigned long address, int write_access);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br></div>

<p><strong>查看进程内存空间</strong></p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/&lt;pid&gt;/maps</div></pre></td></tr></table></figure><br><br></div>

<p>每行数据格式： 开始-结束 访问权限 偏移 主设备号：次设备号 i节点 文件</p>
<ul>
<li>设备表示为00：00, 索引节点标示页为0，这个区域就是零页（所有数据全为零）</li>
<li>数据段和bss具有可读、可写但不可执行权限；而堆栈可读、可写、甚至可执行</li>
</ul>
<p>也可通过工具pmap</p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pmap &lt;pid&gt;</div></pre></td></tr></table></figure><br><br></div>

<h3 id="2-4-内存区域操作"><a href="#2-4-内存区域操作" class="headerlink" title="2.4 内存区域操作"></a>2.4 内存区域操作</h3><p><strong>find_vma</strong> 查看mm_struct所属于的VMA，搜索第一个vm_end大于addr的内存区域</p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct vm_area_struct *find_vma(struct mm_struct *mm, usigned long addr)</div></pre></td></tr></table></figure><br><br></div>

<ol>
<li>检查mmap_cache，查看缓存VMA是否包含所需地址，如果没有找到，进入2</li>
<li>通过红黑树搜索；</li>
</ol>
<p><strong>find_vma_prev</strong> 查看mm_struct所属于的VMA，搜索第一个vm_end小于addr的内存区域</p>
<div class="highlighter-rouge"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct vm_area_struct * find_vma_prev(struct mm_struct *mm, unsigned long addr, struct vm_area_struct **pprev)</div></pre></td></tr></table></figure><br><br></div>

<p><strong>mmap</strong></p>
<ul>
<li>内核使用do_mmap()创建一个新的线性地址区间，如果创建的地址区间和一个已存在的相邻地址区间有相同的访问权限，则将两个区间合并为一个。</li>
<li>mmap()系统调用获取内核函数do_mmap()的功能。</li>
<li>do_mummap()从特定的进程地址空间中删除指定地址区间</li>
<li>mummap()与 mmap功能相反。</li>
</ul>
<h3 id="2-5-页表"><a href="#2-5-页表" class="headerlink" title="2.5 页表"></a>2.5 页表</h3><p>应用程序操作的对象时映射到物理内存之上的虚拟内存，而处理器直接操作的是物理内存。故应用程序访问一个虚拟地址时，需要将虚拟地址转换为物理地址，然后处理器才能解析地址访问请求，这个转换工作通过查询页表完成。</p>
<p>Linux使用三级页表完成地址转换。</p>
<p><img src="/img/kernel_memory/page_admin.jpg" alt="page_admin"></p>
<ol>
<li>顶级页表：页全局目录(PGD)，指向二级页目录；</li>
<li>二级页表：中间页目录(PMD)，指向PTE中的表项；</li>
<li>最后一级：页表(PTE)，指向物理页面。</li>
</ol>
<p>多数体系结构，搜索页表工作由硬件完成。每个进程都有自己的页表(线程会共享页表)。为了加快搜索，实现了翻译后缓冲器(TLB)，作为将虚拟地址映射到物理地址的硬件缓存。还有写时拷贝方式共享页表，当fork()时，父子进程共享页表，只有当子进程或父进程试图修改特定页表项时，内核才创建该页表项的新拷贝，之后父子进程不再共享该页表项。可见，利用共享页表可以消除fork()操作中页表拷贝所带来的消耗。</p>
<h2 id="三、进程与内存"><a href="#三、进程与内存" class="headerlink" title="三、进程与内存"></a>三、进程与内存</h2><p>所有进程都必须占用一定数量的内存，这些内存用来存放从磁盘载入的程序代码，或存放来自用户输入的数据等。内存可以提前静态分配和统一回收，也可以按需动态分配和回收。</p>
<p>对于普通进程对应的内存空间包含5种不同的数据区：</p>
<ul>
<li>代码段</li>
<li>数据段</li>
<li>BSS段</li>
<li>堆：动态分配的内存段，大小不固定，可动态扩张(malloc等函数分配内存)，或动态缩减(free等函数释放)；</li>
<li>栈：存放临时创建的局部变量；</li>
</ul>
<p><img src="/img/kernel_memory/user_space.jpg" alt="process memory"></p>
<h3 id="3-1-进程内存空间"><a href="#3-1-进程内存空间" class="headerlink" title="3.1 进程内存空间"></a>3.1 进程内存空间</h3><p>Linux采用虚拟内存管理技术，每个进程都有各自独立的进程地址空间(即4G的线性虚拟空间)，无法直接访问物理内存。这样起到保护操作系统，并且让用户程序可使用比实际物理内存更大的地址空间。</p>
<ul>
<li>4G进程地址空间被划分两部分，内核空间和用户空间。用户空间从0到3G，内核空间从3G到4G；</li>
<li>用户进程通常情况只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址。只有用户进程进行系统调用(代表用户进程在内核态执行)等情况可访问到内核空间；</li>
<li>用户空间对应进程，所以当进程切换，用户空间也会跟着变化；</li>
<li>内核空间是由内核负责映射，不会跟着进程变化；内核空间地址有自己对应的页表，用户进程各自有不同额页表。</li>
</ul>
<p><img src="/img/kernel_memory/kernel_memory.jpg" alt="kernel memory"></p>
<h3 id="3-2-内存分配"><a href="#3-2-内存分配" class="headerlink" title="3.2 内存分配"></a>3.2 内存分配</h3><p>进程分配内存，陷入内核态分别由brk和mmap完成，但这两种分配还没有分配真正的物理内存，真正分配在后面会讲。</p>
<ul>
<li>brk： 数据段的最高地址指针_edata往高地址推<ul>
<li>当malloc需要分配的内存&lt;M_MMAP_THRESHOLD（默认128k）时，采用brk;</li>
<li>brk分配的内存需高地址内存全部释放之后才会释放。(由于是通过推动指针方式)</li>
<li>当最高地址空间的空闲内存大于M_TRIM_THRESHOLD时(默认128k)，执行内存紧缩操作；</li>
</ul>
</li>
<li>do_mmap：在堆栈中间的文件映射区域找空闲的虚拟内存<ul>
<li>当malloc需要分配的内存&gt;M_MMAP_THRESHOLD（默认128k）时，采用do_map();</li>
<li>mmap分配的内存可以单独释放</li>
</ul>
</li>
</ul>
<h3 id="3-3-物理内存"><a href="#3-3-物理内存" class="headerlink" title="3.3 物理内存"></a>3.3 物理内存</h3><ul>
<li>物理内存只有进程真正去访问虚拟地址，发生缺页中断时，才分配实际的物理页面，建立物理内存和虚拟内存的映射关系。</li>
<li>应用程序操作的是虚拟内存；而处理器直接操作的却是物理内存。当应用程序访问虚拟地址，必须将虚拟地址转化为物理地址，处理器才能解析地址访问请求。</li>
<li>物理内存是通过分页机制实现的</li>
<li>物理页在系统中由也结构struct page描述，所有的page都存储在数组mem_map[]中，可通过该数组找到系统中的每一页。</li>
</ul>
<p><strong>虚拟内存 转化为 真实物理内存：</strong></p>
<ul>
<li>虚拟进程空间：通过查询进程页表，获取实际物理内存地址；</li>
<li>虚拟内核空间：通过查询内核页表，获取实际物理内存地址；</li>
<li>物理内存映射区：物理内存映射区与实际物理去偏移量仅PAGE_OFFSET，通过通过virt_to_phys()转化；</li>
</ul>
<p>虚拟内存与真实物理内存映射关系：</p>
<p><img src="/img/kernel_memory/memory_map.jpg" alt="memory"></p>
<p>其中物理地址空间中除了896M(ZONE_DMA + ZONE_NORMAL)的区域是绝对的物理连续，其他内存都不是物理内存连续。在虚拟内核地址空间中的安全保护区域的指针都是非法的，用于保证指针非法越界类的操作，vm_struct是连续的虚拟内核空间，对应的物理页面可以不连续，地址范围(3G + 896M + 8M) ~ 4G；另外在虚拟用户空间中 vm_area_struct同样也是一块连续的虚拟进程空间，地址空间范围0~3G。</p>
<h3 id="3-4-碎片问题"><a href="#3-4-碎片问题" class="headerlink" title="3.4 碎片问题"></a>3.4 碎片问题</h3><ul>
<li>外部碎片：未被分配的内存，由于太多零碎的不连续小内存，无法满足当前较大内存的申请要求；<ul>
<li>原因：频繁的分配与回收物理页导致大量的小块内存夹杂在已分配页面中间；</li>
<li>解决方案：伙伴算法有所改善</li>
</ul>
</li>
<li>内部碎片：已经分配的内存，却不能被利用的内存空间；<ul>
<li>缘由：所有内存分配必须起始可被4、8或16(体系结构决定)整除的地址或者MMU分页机制限制；</li>
<li>解决方案：slab分配器有所改善</li>
<li>实例：请求一个11Byte的内存块，系统可能会分配12Byte、16Byte等稍大一些的字节，这些多余空间就产生碎片</li>
</ul>
</li>
</ul>
<hr>
<p><strong>相关文章</strong></p>
<ul>
<li><a href="http://blog.csdn.net/qingen1/article/details/13615055" target="_blank" rel="external">http://blog.csdn.net/qingen1/article/details/13615055</a></li>
<li><a href="http://blog.csdn.net/dlutbrucezhang/article/details/9168255" target="_blank" rel="external">http://blog.csdn.net/dlutbrucezhang/article/details/9168255</a></li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Linux内存管理的文章
    
    </summary>
    
      <category term="Linux memory" scheme="http://yoursite.com/categories/Linux-memory/"/>
    
    
      <category term="Linux memory" scheme="http://yoursite.com/tags/Linux-memory/"/>
    
  </entry>
  
  <entry>
    <title>Linux的内存详解</title>
    <link href="http://yoursite.com/2016/04/19/%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2016/04/19/高性能IO模型浅析/</id>
    <published>2016-04-19T01:21:12.000Z</published>
    <updated>2017-06-14T13:00:26.770Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>服务器端编程经常需要构造高性能的IO模型，常见的IO模型有四种：<ul>
<li>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。</li>
<li>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</li>
<li>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</li>
<li>（4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</li>
</ul>
</li>
<li>同步和异步的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</li>
<li>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</li>
<li>另外，Richard Stevens 在《Unix 网络编程》卷1中提到的基于信号驱动的IO（Signal Driven IO）模型，由于该模型并不常用，本文不作涉及。接下来，我们详细分析四种常见的IO模型的实现原理。为了方便描述，我们统一使用IO的读操作作为示例。<h2 id="一、同步阻塞IO"><a href="#一、同步阻塞IO" class="headerlink" title="一、同步阻塞IO"></a>一、同步阻塞IO</h2></li>
<li><p>同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。<br><img src="/img/IO_desc/pic_同步阻塞io.png" alt="pic_同步阻塞io"><br>图1 同步阻塞IO</p>
<ul>
<li>如图1所示，用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</li>
<li><p>用户线程使用同步阻塞IO模型的伪代码描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	read(socket, buffer);</div><div class="line">	process(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>即用户需要等待read将socket中的数据读取到buffer后，才继续处理接收的数据。整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。</p>
<h2 id="二、同步非阻塞IO"><a href="#二、同步非阻塞IO" class="headerlink" title="二、同步非阻塞IO"></a>二、同步非阻塞IO</h2></li>
</ul>
</li>
<li><p>同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。<br><img src="/img/IO_desc/pic2_同步非阻塞io.png" alt="pic2_同步非阻塞io"><br>图2 同步非阻塞IO</p>
<ul>
<li>如图2所示，由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</li>
<li><p>用户线程使用同步非阻塞IO模型的伪代码描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	while(read(socket, buffer) != SUCCESS);</div><div class="line">	process(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p>
<h2 id="三、IO多路复用"><a href="#三、IO多路复用" class="headerlink" title="三、IO多路复用"></a>三、IO多路复用</h2></li>
</ul>
</li>
<li><p>IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。<br><img src="/img/IO_desc/pic3_多路分离函数select.png" alt="pic3_多路分离函数select"><br>图3 多路分离函数select</p>
<ul>
<li>如图3所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</li>
<li>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</li>
<li><p>用户线程使用select函数的伪代码描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	select(socket);</div><div class="line">	while(1) &#123;</div><div class="line">		sockets = select();</div><div class="line">		for(socket in sockets) &#123;</div><div class="line">			if(can_read(socket)) &#123;</div><div class="line">				read(socket, buffer);</div><div class="line">				process(buffer);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>其中while循环前将socket添加到select监视中，然后在while内一直调用select获取被激活的socket，一旦socket可读，便调用read函数将socket中的数据读取出来。</p>
</li>
<li>然而，使用select函数的优点并不仅限于此。虽然上述方式允许单线程内处理多个IO请求，但是每个IO请求的过程还是阻塞的（在select函数上阻塞），平均时间甚至比同步阻塞IO模型还要长。如果用户线程只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率。</li>
<li>IO多路复用模型使用了Reactor设计模式(反应器设计模式)实现了这一机制。<br><img src="/img/IO_desc/pic4_Reactor设计模式.png" alt="pic4_Reactor设计模式.png"><br>图4 Reactor设计模式</li>
<li>如图4所示，EventHandler抽象类表示IO事件处理器，它拥有IO文件句柄Handle（通过get_handle获取），以及对Handle的操作handle_event（读/写等）。继承于EventHandler的子类可以对事件处理器的行为进行定制。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。<br><img src="/img/IO_desc/pic5_IO多路复用.png" alt="pic5_IO多路复用.png"><br>图5 IO多路复用</li>
<li>如图5所示，通过Reactor的方式，可以将用户线程轮询IO操作状态的工作统一交给handle_events事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态。当有socket被激活时，则通知相应的用户线程（或执行用户线程的回调函数），执行handle_event进行数据读取、处理的工作。由于select函数是阻塞的，因此多路IO复用模型也被称为异步阻塞IO模型。注意，这里的所说的阻塞是指select函数执行时线程被阻塞，而不是指socket。一般在使用IO多路复用模型时，socket都是设置为NONBLOCK的，不过这并不会产生影响，因为用户发起IO请求时，数据已经到达了，用户线程一定不会被阻塞。</li>
<li><p>用户线程使用IO多路复用模型的伪代码描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void UserEventHandler::handle_event() &#123;</div><div class="line">	if(can_read(socket)) &#123;</div><div class="line">		read(socket, buffer);</div><div class="line">		process(buffer);</div><div class="line">	&#125;</div><div class="line">		&#125;</div><div class="line">&#123;</div><div class="line">	Reactor.register(new UserEventHandler(socket));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Reactor::handle_events() &#123;</div><div class="line">	while(1) &#123;</div><div class="line">		sockets = select();</div><div class="line">		for(socket in sockets) &#123;</div><div class="line">			get_event_handler(socket).handle_event();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。</p>
</li>
<li>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。<h2 id="四、异步IO"><a href="#四、异步IO" class="headerlink" title="四、异步IO"></a>四、异步IO</h2></li>
</ul>
</li>
<li>“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</li>
<li><p>异步IO模型使用了Proactor设计模式(前摄器设计模式)实现了这一机制。<br><img src="/img/IO_desc/pic6_Proactor设计模式.jpg" alt="pic6_Proactor设计模式.jpg"><br>图6 Proactor设计模式</p>
<ul>
<li>如图6，Proactor模式和Reactor模式在结构上比较相似，不过在用户（Client）使用方式上差别较大。Reactor模式中，用户线程通过向Reactor对象注册感兴趣的事件监听，然后事件触发时调用事件处理函数。而Proactor模式中，用户线程将AsynchronousOperation（读/写等）、Proactor以及操作完成时的CompletionHandler注册到AsynchronousOperationProcessor。AsynchronousOperationProcessor使用Facade模式提供了一组异步操作API（读/写等）供用户使用，当用户线程调用异步API后，便继续执行自己的任务。AsynchronousOperationProcessor 会开启独立的内核线程执行异步操作，实现真正的异步。当异步IO操作完成时，AsynchronousOperationProcessor将用户线程与AsynchronousOperation一起注册的Proactor和CompletionHandler取出，然后将CompletionHandler与IO操作的结果数据一起转发给Proactor，Proactor负责回调每一个异步操作的事件完成处理函数handle<em>event。虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象，但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。<br>![pic7</em>异步io.png](/img/IO<em>desc/pic7</em>异步io.png)<br>图7 异步IO</li>
<li>如图7所示，异步IO模型中，用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。</li>
<li><p>用户线程使用异步IO模型的伪代码描述为：、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void UserCompletionHandler::handle_event(buffer) &#123;</div><div class="line">	process(buffer);</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">	aio_read(socket, new UserCompletionHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</p>
</li>
<li>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</li>
<li>本文从基本概念、工作流程和代码示例三个层次简要描述了常见的四种高性能IO模型的结构和原理，理清了同步、异步、阻塞、非阻塞这些容易混淆的概念。通过对高性能IO模型的理解，可以在服务端程序的开发中选择更符合实际业务特点的IO模型，提高服务质量。希望本文对你有所帮助。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Linux内存管理的文章
    
    </summary>
    
      <category term="Linux memory" scheme="http://yoursite.com/categories/Linux-memory/"/>
    
    
      <category term="Linux memory" scheme="http://yoursite.com/tags/Linux-memory/"/>
    
  </entry>
  
  <entry>
    <title>MVC,MVP和MVVM开发模式解析</title>
    <link href="http://yoursite.com/2016/03/21/MVC,MVP%E5%92%8CMVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20-%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <id>http://yoursite.com/2016/03/21/MVC,MVP和MVVM开发模式解析 -升级版/</id>
    <published>2016-03-21T07:13:48.000Z</published>
    <updated>2016-12-19T14:00:45.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC应用于Ruby on Rails, Spring Framework, iOS开发和 ASP.NET等。</p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>Controller: 操作Model层获取数据传递给UI</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/1f0f053ee41dd60f.png" alt=""></p>
<h3 id="服务器端的MVC"><a href="#服务器端的MVC" class="headerlink" title="服务器端的MVC"></a>服务器端的MVC</h3><p><img src="http://p1.bpimg.com/567571/32dbc1b0db151baa.png" alt=""></p>
<h3 id="Android中MVC"><a href="#Android中MVC" class="headerlink" title="Android中MVC"></a>Android中MVC</h3><p>Android中并没有清晰的MVC框架，如果把Activity当做Controller,根据我们实际开发经验，里面会有大量的UI操作，所以V和C就傻傻分不清了。</p>
<ul>
<li>Model:Java Bean, NetworkManager, DataBaseHelper</li>
<li>View: xml res</li>
<li>Controller: Activity Fragment</li>
<li>ArrayList-ListView-Adapter(MVC)</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP主要应用于ASP.NET等。<strong>MVP与MVC主要区别是View和Model不再耦合。</strong></p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>Presenter: 操作Model层获取数据传递给UI<br><img src="http://p1.bpimg.com/567571/55fb6e5522f46de2.png" alt=""></li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM主要应用于WPF, Silverlight, Caliburn, nRoute等。</p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>ViewModel: 将View和Model绑定</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/1e2bf8b8c8d87d7c.png" alt=""></p>
<h3 id="Android中MVVM"><a href="#Android中MVVM" class="headerlink" title="Android中MVVM"></a>Android中MVVM</h3><p><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">Data Binding Library</a><br><a href="http://www.jianshu.com/p/b1df61a4df77" target="_blank" rel="external">中文翻译</a></p>
<h2 id="软件架构的核心思想"><a href="#软件架构的核心思想" class="headerlink" title="软件架构的核心思想"></a>软件架构的核心思想</h2><blockquote>
<p>分层分模块</p>
</blockquote>
<p><img src="http://p1.bpimg.com/567571/7297425199586e4e.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android architecture</a></p>
<p><a href="http://www.jianshu.com/p/6a86f7fdc0cb" target="_blank" rel="external">MVC,MVP和MVVM模式如何选择</a></p>
<p><a href="http://www.dotnettricks.com/learn/designpatterns/understanding-mvc-mvp-and-mvvm-design-patterns" target="_blank" rel="external">Understanding MVC, MVP and MVVM Design Patterns</a></p>
<p><a href="http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/" target="_blank" rel="external">教你认清MVC，MVP和MVVM</a></p>
<p><a href="https://github.com/LyndonChin/MasteringAndroidDataBinding" target="_blank" rel="external">Android Data Binding</a></p>
<p><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">Clean Architecture</a></p>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述MVC,MVP和MVVM开发模式解析的文章
    
    </summary>
    
      <category term="软件架构" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Android,软件构架,mvc,mvp,mvvm" scheme="http://yoursite.com/tags/Android-%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%9E%B6-mvc-mvp-mvvm/"/>
    
  </entry>
  
  <entry>
    <title>Android下数据库的解析</title>
    <link href="http://yoursite.com/2016/01/16/Android%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/16/Android下数据库的解析/</id>
    <published>2016-01-16T05:18:53.000Z</published>
    <updated>2016-12-19T13:24:09.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下数据库的解析"><a href="#Android下数据库的解析" class="headerlink" title="Android下数据库的解析"></a>Android下数据库的解析</h1><h2 id="建表的语句："><a href="#建表的语句：" class="headerlink" title="建表的语句："></a>建表的语句：</h2><ul>
<li><p>以下语句就可以在数据库文件里创建一个名为students的表名，他有id， name, age 三个字段。</p>
<pre><code>继承 SqlliteOpenHelper
在构造里写出数据库名，然后在onCreate里写出创建表的语句：
db.execSQL(&quot;create table students(_id interger primary key autoincrement,name varchar(20), age integer(20)&quot;);
</code></pre></li>
</ul>
<h2 id="数据库文件的赠删改查："><a href="#数据库文件的赠删改查：" class="headerlink" title="数据库文件的赠删改查："></a>数据库文件的赠删改查：</h2><ul>
<li><p>以下语句可以实现数据库的增删改查：</p>
<pre><code>Sql语句：
add:
insert into  students(id,name,age) values(1,&apos;huge&apos;,38);

delete：
delete from students where name = &apos;lxr&apos;;

update:
update students set age = 34 where name = &apos;lxr&apos;;

query:
select name age from students where name = &apos;lxr&apos;;
</code></pre></li>
</ul>
<h2 id="数据库的模糊查询"><a href="#数据库的模糊查询" class="headerlink" title="数据库的模糊查询"></a>数据库的模糊查询</h2><ul>
<li>使用like可以实现数据库的模糊查询</li>
<li><pre><code>select name age from students where name LIKE&apos;Mc%&apos;; 
SQL模糊查询，使用like比较字，加上SQL里的通配符，请参考以下：
  　　1、LIKE&apos;Mc%&apos; 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
  　　2、LIKE&apos;%inger&apos; 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
  　　3、LIKE&apos;%en%&apos; 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
  　　4、LIKE&apos;_heryl&apos; 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
  　　5、LIKE&apos;[CK]ars[eo]n&apos; 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
  　　6、LIKE&apos;[M-Z]inger&apos; 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
  　　7、LIKE&apos;M[^c]%&apos; 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。
</code></pre></li>
</ul>
<h2 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h2><ul>
<li><p>使用事务。大量数据增加或删除时如果不使用事务，而是循环调用 INSERT 和 DELETE 的话，会因为每一笔操作都需要打开、写入最后关闭 journal  文件（这个文件是临时用来保存数据操作的中间结果）而使得开销非常大。<br>使用方法：</p>
<ul>
<li>db.beginTransaction()。</li>
<li>开始进行循环添加或者删除操作。    </li>
<li>db.setTransactionSuccessful()。</li>
<li>db.endTransaction()。</li>
</ul>
</li>
<li><p>使用索引。索引维护着一个表中某一列或某几列的顺序，这样就可 以快速定位到一组值，而不用扫遍全表。所有的索引信息会被保存在一个 独立的索引表中，所以会产生额外的空间占用，不过绝对物超所值，特别 是当你会在数据库中进行大量的读及搜索操作时。</p>
<ul>
<li>创建语句：CREATE INDEX name_index ON username(firstname, lastname)</li>
<li><p>索引分类：</p>
<ul>
<li>普通索引和唯一性索引。 </li>
<li>单个索引：索引建立语句中仅包含单个字段。复合索引：在索引建立语句中同时包含多个字段。</li>
<li><p>聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照 顺序排列。非聚簇索引。</p>
</li>
<li><p>使用场景：</p>
<ul>
<li>当某字段数据更新频率较低，查询频率较高，经常有范围 查询(&gt;, &lt;, =, &gt;=, &lt;=)或 order by、group by 发生时建议使用索引。</li>
<li>经常同时存取多列，且每列都含有重复值可考虑建立复合索引。</li>
<li>使用注意项（较难）：<ul>
<li>对于复合索引，把使用最频繁的列做为前导列 (索引中第一个字段)。<ul>
<li>避免对索引列进行计算，对 where 子句列的任何计算如果不能被编译 优化，都会导致查询时索引失效。</li>
</ul>
</li>
<li>比较值避免使用 NULL。 </li>
<li>多表查询时要注意是选择合适的表做为内表。内外表的选择可由公式： 外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳 方案。</li>
<li>把过滤记录数最多的条件放在最前面。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>sql 语句拼接时可以使用 StringBuffer 代替 String。 </p>
</li>
<li>在写表时调用 sqliteOpenHelper..getWritableDatabase()，<br>在读表时候调用 sqliteOpenHelper..getReadableDatabase()，getReadableDatabase 性能更优。</li>
<li>开启子线程进行数据库读写。</li>
</ul>
<h2 id="版本迭代中数据库的更新问题"><a href="#版本迭代中数据库的更新问题" class="headerlink" title="版本迭代中数据库的更新问题"></a>版本迭代中数据库的更新问题</h2><ul>
<li><p>应用程序如何知道数据库需要升级：SQLiteOpenHelper类的构造函数有 一个参数是int version，它的意思就是指数据库版本号。比如在应用1.0版本 中，我们使用SQLiteOpenHelper访问数据库时，该参数为1，那么数据库版本号 1就会写在我们的数据库中。到了1.1版本，我们的数据库需要发生变化，那么 我们1.1版本的程序中就要使用一个大于1的整数来构造SQLiteOpenHelper类， 用于访问新的数据库，比如2。当我们的1.1新程序读取1.0版本的老数据库时， 就发现老数据库里存储的数据库版本是1，而我们新程序访问它时填的版本号为 2，系统就知道数据库需要升级。<br>何时触发数据库升级：当系统在构造 SQLiteOpenHelper 类的对象时，如果 发现版本号不一样，就会自动调用   onUpgrade    函数，让你在这里对数据库进行升级。</p>
</li>
<li><p>升级时应该考虑的问题：数据库中的原数据不能丢失。</p>
<ul>
<li>如何升级：在 onUpgrade 方法中执行相应的更新数据库的 sql 语句就行了。下 面列举一些常见的更新的sql 语句。<ul>
<li>增加新表：CREATE TABLE table_name(_id integer primary key autoincrement, region varchar, code varchar)。 增加或者删除列：SQLite数库对ALTER TABLE命令支持非常有限，只能在表末尾 添加列，不能修改列定义，不能删除已有的列。那么如果要修改表呢？我们可 以采用临时表的办法。具体来说有四步：<ul>
<li>将表明改为临时表：ALTER TABLE table_name RENAME TO table_name_temp </li>
<li>创建新表。</li>
<li>将临时表的数据导入新表（不能出现values关键字）：insert into table_name (_id, region, code, country) select _id, region, code, \”CHINA\” from table_name_temp</li>
<li>删除临时表：DROP TABLE table_name _temp</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跨版本的数据库升级问题：应用程序发布了多个版本，以致出现了三个及 以上数据库版本。如何确保所有的用户升级应用后数据库都能用呢？</p>
<ul>
<li><p>方法一：确定相邻版本的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3这样依次下去。 优点：每次更新数据库的时候只需要在onUpgrade方法的末尾加一段从上个版 本升级到新版本的代码，易于理解和维护。 缺点：是当版本变多之后，多次迭代升级可能需要花费不少时间，增加用户等 待时间；</p>
</li>
<li><p>方式二：为每个版本确定与现在数据库的差别，为每个case撰写专门的升级代码。 优点：则是可以保证每个版本的用户都可以在消耗最少的时间升级到最新的数据库而无需做无用的数据多次转存。缺点：是强迫开发者记忆所有版本数据库的完整结构，且每次升级时 onUpgrade方法都必须全部重写。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下数据库的解析的文章
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Android,数据库" scheme="http://yoursite.com/tags/Android-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>静态代理和动态代理解析</title>
    <link href="http://yoursite.com/2015/09/11/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/09/11/静态代理和动态代理解析/</id>
    <published>2015-09-11T14:13:34.000Z</published>
    <updated>2016-12-19T13:35:18.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>1.相关概念</p>
</blockquote>
<ul>
<li>1.1 代理</li>
</ul>
<p>在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。<br>这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。<br>代理优点有：</p>
<pre><code>隐藏委托类的实现
解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作
</code></pre><p>根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。</p>
<ul>
<li>1.2 静态代理</li>
</ul>
<p>代理类在程序运行前已经存在的代理方式称为静态代理。<br>通过上面解释可以知道，由开发人员编写或是编译器生成代理类的方式都属于静态代理，如下是简单的静态代理实例：</p>
<pre><code>class ClassA {
    public void operateMethod1() {};

    public void operateMethod2() {};

    public void operateMethod3() {};
}

public class ClassB {
    private ClassA a;

    public ClassB(ClassA a) {
        this.a = a;
    }

    public void operateMethod1() {
        a.operateMethod1();
    };

    public void operateMethod2() {
        a.operateMethod2();
    };

    // not export operateMethod3()
}
</code></pre><p>上面ClassA是委托类，ClassB是代理类，ClassB中的函数都是直接调用ClassA相应函数，并且隐藏了Class的operateMethod3()函数。</p>
<p>静态代理中代理类和委托类也常常继承同一父类或实现同一接口。</p>
<p>*　1.3 动态代理</p>
<ul>
<li><p>代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。</p>
</li>
<li><p>Java 提供了动态代理的实现方式，可以在运行时刻动态生成代理类。这种代理方式的一大好处是可以方便对代理类的函数做统一或特殊处理，如记录所有函数执行时间、所有函数执行前添加验证判断、对某个特殊函数进行特殊操作，而不用像静态代理方式那样需要修改每个函数。</p>
</li>
<li><p>A:动态代理概述</p>
<ul>
<li>代理：本来应该自己做的事情，请了别人来做，被请的人就是代理对象。</li>
<li>举例：春节回家买票让人代买</li>
<li>动态代理：在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理</li>
<li>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象<blockquote>
<p>动态代理实例</p>
</blockquote>
</li>
</ul>
</li>
<li><p>实现动态代理包括三步：</p>
<ul>
<li>新建委托类；</li>
<li>实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；</li>
<li>通过Proxy类新建代理类对象。</li>
<li>proxy中的方法</li>
<li>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</li>
<li>最终会调用InvocationHandler的方法</li>
<li>InvocationHandler接口 </li>
<li>public Object invoke(Object proxy,Method method,Object[] args)；</li>
</ul>
</li>
<li><pre><code>//step1: 定义User接口

public interface User {
    public void add();

    public void delete();
}

//step2: 定义类实现User接口

public class UserImp implements User {
    @Override
    public void add() {
        //System.out.println(&quot;权限校验&quot;);
        System.out.println(&quot;添加功能&quot;);
        //System.out.println(&quot;日志记录&quot;);
    }

    @Override
    public void delete() {
        //System.out.println(&quot;权限校验&quot;);
        System.out.println(&quot;删除功能&quot;);
        //System.out.println(&quot;日志记录&quot;);
    }

}

//step3: InvocationHandler的实现类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyInvocationHandler implements InvocationHandler {

    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {
        System.out.println(&quot;权限校验&quot;);
        method.invoke(target, args);                    //执行被代理target对象的方法
        System.out.println(&quot;日志记录&quot;);
        return null;
    }

}

//定义测试类
import java.lang.reflect.Proxy;
public class Test {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*UserImp ui = new UserImp();
        ui.add();  //添加功能
        ui.delete(); //删除功能

        System.out.println(&quot;-------------------------------&quot;);*/
        /*
         * public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,
         * InvocationHandler h)
         */
        /*
        MyInvocationHandler m = new MyInvocationHandler(ui);
        User u = (User)Proxy.newProxyInstance(ui.getClass().getClassLoader(), ui.getClass().getInterfaces(), m);
        u.add();   //权限校验    添加功能    日志记录
        u.delete(); //权限校验 删除功能  日志记录
        */

        StudentImp si = new StudentImp();
        si.login();//登录
        si.submit();//提交

        System.out.println(&quot;-------------------------------&quot;);
        MyInvocationHandler m = new MyInvocationHandler(si);
        Student s = (Student)Proxy.newProxyInstance(si.getClass().getClassLoader(), si.getClass().getInterfaces(), m);

        s.login();  //权限校验    登录    日志记录
        s.submit(); //权限校验 提交  日志记录
    }

}

//类似step1: 定义Student接口
public interface Student {
    public void login();

    public void submit();
}

//类似step2: 定义类实现Student接口
public class StudentImp implements Student {
    @Override
    public void login() {
        System.out.println(&quot;登录&quot;);
    }

    @Override
    public void submit() {
        System.out.println(&quot;提交&quot;);
    }

}
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述静态代理和动态代理解析的文章
    
    </summary>
    
      <category term="代理" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="Android,静态代理,动态代理" scheme="http://yoursite.com/tags/Android-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入的解析</title>
    <link href="http://yoursite.com/2015/06/07/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/06/07/依赖注入的解析/</id>
    <published>2015-06-07T12:18:43.000Z</published>
    <updated>2016-12-19T13:36:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="依赖注入的解析"><a href="#依赖注入的解析" class="headerlink" title="依赖注入的解析"></a>依赖注入的解析</h1><blockquote>
<ol>
<li>依赖</li>
</ol>
</blockquote>
<p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human() {
        father = new Father();
    }
}
</code></pre><p>仔细看这段代码我们会发现存在一些问题：</p>
<ul>
<li>如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码；</li>
<li>如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；</li>
<li>如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。</li>
</ul>
<blockquote>
<p>2.依赖注入</p>
</blockquote>
<p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human(Father father) {
        this.father = father;
    }
}
</code></pre><p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。<br>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：</p>
<ul>
<li>解耦，将依赖之间解耦。</li>
<li>因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</li>
</ul>
<blockquote>
<p>3.Java 中的依赖注入</p>
</blockquote>
<p>依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。</p>
<pre><code>public class Human {
    ...
    @Inject Father father;
    ...
    public Human() {
    }
}
</code></pre><p>上面这段代码看起来很神奇：只是增加了一个注解，Father 对象就能自动注入了？这个注入过程是怎么完成的？实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。现在 Java 语言中较流行的依赖注入框架有 Google Guice、Spring 等，而在 Android 上比较流行的有 RoboGuice、Dagger 等。</p>
<blockquote>
<p>另外：mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。比如通过Butter Knife、Dagger依赖注入库实现，都是使用注解来实现依赖注入，但它利用 APT(Annotation Process Tool) 在编译时生成辅助类，这些类继承特定父类或实现特定接口，程序在运行时加载这些辅助类，调用相应接口完成依赖生成和注入。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android依赖注入的文章
    
    </summary>
    
      <category term="依赖注入" scheme="http://yoursite.com/categories/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="Android,依赖注入" scheme="http://yoursite.com/tags/Android-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>注解Annotation解析</title>
    <link href="http://yoursite.com/2015/05/01/%E6%B3%A8%E8%A7%A3Annotation%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/05/01/注解Annotation解析/</id>
    <published>2015-05-01T13:10:33.000Z</published>
    <updated>2016-12-19T13:41:13.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解Annotation解析"><a href="#注解Annotation解析" class="headerlink" title="注解Annotation解析"></a>注解Annotation解析</h1><p>不少开源库都用到了注解的方式来简化代码提高开发效率。本文简单介绍下 Annotation 示例、概念及作用、分类、自定义、解析，并对几个 Android 开源库 Annotation 原理进行简析。</p>
<blockquote>
<ol>
<li>Annotation 示例</li>
</ol>
</blockquote>
<pre><code>Override Annotation

@Override //重写的注解
public void onCreate(Bundle savedInstanceState);

Retrofit Annotation

@GET(&quot;/users/{username}&quot;)
User getUser(@Path(&quot;username&quot;) String username);

Butter Knife Annotation

@InjectView(R.id.user) EditText username;

ActiveAndroid Annotation

@Column(name = “Name&quot;) public String name;

Retrofit 为符合 RESTful 规范的网络请求框架
Butter Knife 为 View 及事件等依赖注入框架
Active Android 为 ORM 框架
</code></pre><blockquote>
<p>2.Annotation 概念及作用</p>
</blockquote>
<ul>
<li><p>2.1 概念</p>
<p>  An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate.</p>
</li>
</ul>
<p>能够添加到 Java 源代码的语法元数据。类、方法、变量、参数、包都可以被注解，可用来将信息元数据与程序元素进行关联。Annotation 中文常译为“注解”。</p>
<ul>
<li>2.2 作用</li>
</ul>
<p>a. 标记，用于告诉编译器一些信息<br>b. 编译时动态处理，如动态生成代码<br>c. 运行时动态处理，如得到注解信息<br>这里的三个作用实际对应着后面自定义 Annotation 时说的 @Retention 三种值分别表示的 Annotation</p>
<pre><code>public class Person {

    private int    id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public boolean equals(Person person) {
        return person.id == id;
    }

    public int hashCode() {
        return id;
    }

    public static void main(String[] args) {

        Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();
        for (int i = 0; i &lt; 10; i++) {
            set.add(new Person(i, &quot;Jim&quot;));
        }
        System.out.println(set.size());
    }
}
</code></pre><p>上面的运行结果是多少？</p>
<blockquote>
<p>3.Annotation 分类</p>
</blockquote>
<ul>
<li>3.1 标准 Annotation，Override, Deprecated, SuppressWarnings</li>
</ul>
<p>标准 Annotation 是指 Java 自带的几个 Annotation，上面三个分别表示重写函数，不鼓励使用(有更好方式、使用有风险或已不在维护)，忽略某项 Warning</p>
<ul>
<li>3.2 元 Annotation，@Retention, @Target, @Inherited, @Documented</li>
</ul>
<p>元 Annotation 是指用来定义 Annotation 的 Annotation，在后面 Annotation 自定义部分会详细介绍含义</p>
<ul>
<li>3.3 自定义 Annotation</li>
</ul>
<p>自定义 Annotation 表示自己根据需要定义的 Annotation，定义时需要用到上面的元 Annotation<br>这里是一种分类而已，也可以根据作用域分为源码时、编译时、运行时 Annotation，后面在自定义 Annotation 时会具体介绍</p>
<blockquote>
<p>4.Annotation 自定义</p>
</blockquote>
<ul>
<li><p>4.1 调用</p>
<pre><code>public class App {
    @MethodInfo(
        author = “trinea.cn+android@gmail.com”,
        date = &quot;2014/02/14&quot;,
        version = 2)
    public String getAppName() {
        return &quot;trinea&quot;;
    }
}
</code></pre></li>
</ul>
<p>这里是调用自定义 Annotation——MethodInfo 的示例。<br>MethodInfo Annotation 作用为给方法添加相关信息，包括 author、date、version。</p>
<ul>
<li><p>4.2 定义</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Inherited
public @interface MethodInfo {

    String author() default &quot;trinea@gmail.com&quot;;

    String date();

    int version() default 1;
}

这里是 MethodInfo 的实现部分
(1). 通过 @interface 定义，注解名即为自定义注解名
(2). 注解配置参数名为注解类的方法名，且：
a. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public，不允许抛异常
b. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组
c. 若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation
(3). 可以加 default 表示默认值
</code></pre></li>
<li><p>4.3 元 Annotation</p>
<pre><code>@Documented 是否会保存到 Javadoc 文档中
@Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings
@Target 可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有
@Inherited 是否可以被继承，默认为 false
</code></pre></li>
</ul>
<blockquote>
<p>5.Annotation 解析</p>
</blockquote>
<ul>
<li><p>5.1 运行时 Annotation 解析</p>
<pre><code>(1) 运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析

method.getAnnotation(AnnotationName.class);
method.getAnnotations();
method.isAnnotationPresent(AnnotationName.class);

其他 @Target 如 Field，Class 方法类似
getAnnotation(AnnotationName.class) 表示得到该 Target 某个 Annotation 的信息，因为一个 Target 可以被多个 Annotation 修饰
getAnnotations() 则表示得到该 Target 所有 Annotation
isAnnotationPresent(AnnotationName.class) 表示该 Target 是否被某个 Annotation 修饰
(2) 解析示例如下：

public static void main(String[] args) {
    try {
        Class cls = Class.forName(&quot;cn.trinea.java.test.annotation.App&quot;);
        for (Method method : cls.getMethods()) {
            MethodInfo methodInfo = method.getAnnotation(
MethodInfo.class);
            if (methodInfo != null) {
                System.out.println(&quot;method name:&quot; + method.getName());
                System.out.println(&quot;method author:&quot; + methodInfo.author());
                System.out.println(&quot;method version:&quot; + methodInfo.version());
                System.out.println(&quot;method date:&quot; + methodInfo.date());
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}

以之前自定义的 MethodInfo 为例，利用 Target（这里是 Method）getAnnotation 函数得到 Annotation 信息，然后就可以调用 Annotation 的方法得到响应属性值
</code></pre></li>
<li><p>5.2 编译时 Annotation 解析</p>
<pre><code>(1) 编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，甴编译器自动解析。需要做的
a. 自定义类集成自 AbstractProcessor
b. 重写其中的 process 函数
这块很多同学不理解，实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理
(2) 假设 MethodInfo 的 @Retention 为 CLASS，解析示例如下：

@SupportedAnnotationTypes({ &quot;cn.trinea.java.test.annotation.MethodInfo&quot; })
public class MethodInfoProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {
        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        for (TypeElement te : annotations) {
            for (Element element : env.getElementsAnnotatedWith(te)) {
                MethodInfo methodInfo = element.getAnnotation(MethodInfo.class);
                map.put(element.getEnclosingElement().toString(), methodInfo.author());
            }
        }
        return false;
    }
}

SupportedAnnotationTypes 表示这个 Processor 要处理的 Annotation 名字。
process 函数中参数 annotations 表示待处理的 Annotations，参数 env 表示当前或是之前的运行环境
process 函数返回值表示这组 annotations 是否被这个 Processor 接受，如果接受后续子的 rocessor 不会再对这个 Annotations 进行处理
</code></pre></li>
</ul>
<blockquote>
<p>6.几个 Android 开源库 Annotation 原理简析</p>
<ul>
<li>6.1 Annotation — Retrofit<pre><code>(1) 调用
</code></pre></li>
</ul>
</blockquote>
<pre><code>@GET(&quot;/users/{username}&quot;)
User getUser(@Path(&quot;username&quot;) String username);
(2) 定义
@Documented
@Target(METHOD)
@Retention(RUNTIME)
@RestMethod(&quot;GET&quot;)
public @interface GET {
  String value();
}
从定义可看出 Retrofit 的 Get Annotation 是运行时 Annotation，并且只能用于修饰 Method
(3) 原理
private void parseMethodAnnotations() {
    for (Annotation methodAnnotation : method.getAnnotations()) {
    Class&lt;? extends Annotation&gt; annotationType = methodAnnotation.annotationType();
    RestMethod methodInfo = null;

    for (Annotation innerAnnotation : annotationType.getAnnotations()) {
        if (RestMethod.class == innerAnnotation.annotationType()) {
            methodInfo = (RestMethod) innerAnnotation;
            break;
        }
    }
    ……
    }
}   
RestMethodInfo.java 的 parseMethodAnnotations 方法如上，会检查每个方法的每个 Annotation， 看是否被 RestMethod 这个 Annotation 修饰的 Annotation 修饰，这个有点绕，就是是否被 GET、DELETE、POST、PUT、HEAD、PATCH 这些 Annotation 修饰，然后得到 Annotation 信息，在对接口进行动态代理时会掉用到这些 Annotation 信息从而完成调用。

Retrofit 原理涉及到动态代理，这里原理都只介绍 Annotation，具体原理分析请见 Android 开源项目实现原理解析
</code></pre><ul>
<li><p>6.2 Annotation — Butter Knife</p>
<pre><code>(1) 调用

@InjectView(R.id.user) 
EditText username;

(2) 定义

@Retention(CLASS) 
@Target(FIELD)
public @interface InjectView {
  int value();
}

可看出 Butter Knife 的 InjectView Annotation 是编译时 Annotation，并且只能用于修饰属性
(3) 原理

@Override 
public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {
    Map&lt;TypeElement, ViewInjector&gt; targetClassMap = findAndParseTargets(env);

    for (Map.Entry&lt;TypeElement, ViewInjector&gt; entry : targetClassMap.entrySet()) {
        TypeElement typeElement = entry.getKey();
        ViewInjector viewInjector = entry.getValue();

        try {
            JavaFileObject jfo = filer.createSourceFile(viewInjector.getFqcn(), typeElement);
            Writer writer = jfo.openWriter();
            writer.write(viewInjector.brewJava());
            writer.flush();
            writer.close();
        } catch (IOException e) {
            error(typeElement, &quot;Unable to write injector for type %s: %s&quot;, typeElement, e.getMessage());
        }
    }

    return true;
}

ButterKnifeProcessor.java 的 process 方法如上，编译时，在此方法中过滤 InjectView 这个 Annotation 到 targetClassMap 后，会根据 targetClassMap 中元素生成不同的 class 文件到最终的 APK 中，然后在运行时调用 ButterKnife.inject(x) 函数时会到之前编译时生成的类中去找。 这里原理都只介绍 Annotation，具体原理分析请见 Android 开源项目实现原理解析
</code></pre></li>
<li><p>6.3 Annotation — ActiveAndroid</p>
<pre><code>(1) 调用

@Column(name = “Name&quot;) 
public String name;

(2) 定义

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
  ……
}

可看出 ActiveAndroid 的 Column Annotation 是运行时 Annotation，并且只能用于修饰属性。
(3) 原理

Field idField = getIdField(type);
mColumnNames.put(idField, mIdName);

List&lt;Field&gt; fields = new LinkedList&lt;Field&gt;(ReflectionUtils.getDeclaredColumnFields(type));
Collections.reverse(fields);

for (Field field : fields) {
    if (field.isAnnotationPresent(Column.class)) {
        final Column columnAnnotation = field.getAnnotation(Column.class);
        String columnName = columnAnnotation.name();
        if (TextUtils.isEmpty(columnName)) {
            columnName = field.getName();
        }

        mColumnNames.put(field, columnName);
    }
}

TableInfo.java 的构造函数如上，运行时，得到所有行信息并存储起来用来构件表信息。
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android注解Annotation的文章
    
    </summary>
    
      <category term="注解" scheme="http://yoursite.com/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="Android,注解,Annotation" scheme="http://yoursite.com/tags/Android-%E6%B3%A8%E8%A7%A3-Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Android下屏幕适配全解析</title>
    <link href="http://yoursite.com/2014/05/16/android%E4%B8%8B%E7%9A%84%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2014/05/16/android下的屏幕适配全解析/</id>
    <published>2014-05-16T14:19:43.000Z</published>
    <updated>2016-12-19T13:24:09.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下屏幕适配全解析"><a href="#Android下屏幕适配全解析" class="headerlink" title="Android下屏幕适配全解析"></a>Android下屏幕适配全解析</h1><h2 id="屏幕适配分为两部分：图片适配和尺寸适配。"><a href="#屏幕适配分为两部分：图片适配和尺寸适配。" class="headerlink" title="屏幕适配分为两部分：图片适配和尺寸适配。"></a>屏幕适配分为两部分：图片适配和尺寸适配。</h2><h3 id="图片适配："><a href="#图片适配：" class="headerlink" title="图片适配："></a>图片适配：</h3><ul>
<li>目前流行的是切一套最大的图——1920*1080（1080P），在低分辨率的 手机上可以通过设置 imageView 的大小和 scaleType 来将图片压缩。（这 样做的目的是减小 APK 体积）针对那些常用的、比较重要的 icon 会切多套图。</li>
</ul>
<h3 id="尺寸适配："><a href="#尺寸适配：" class="headerlink" title="尺寸适配："></a>尺寸适配：</h3><ul>
<li>较为通俗的方法就是根据不同的手机分辨率在 res 文件夹下创建不同 的 values 文件夹，在每个都有一个 dimens 文件，dimens 文件里就写<br>着所有的尺寸。每种分辨率的手机就到不同的 values 文件夹里面的 dimens 文件去进行尺寸匹配。</li>
<li>使用谷歌官方推出的 percent library 来进行适配。但是谷歌只推出了PercentRelativeLayout、PercentFrameLayout供大家使用，那么其他就可以写自定义VIew来实现了</li>
<li>使用国内hongyang大神写的 AutoLayout 来进行适配。</li>
</ul>
<h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><ul>
<li>屏幕尺寸：屏幕对角线的长度。</li>
<li>屏幕分辨率：横纵向上的像素点数。</li>
<li>dpi:是 dot per inch 的缩写，表示每英寸上的像素点数。与屏幕尺寸和 屏幕分辨率有关。</li>
<li>dip/dp: 是 Density Independent Pixels 的缩写，即密度无关像素</li>
<li>px:像素。</li>
<li>sp: 即 scale-independent pixels，与 dp 类似，但是可以根据文字大小 首选项进行放缩，是设置字体大小的御用单位。 mdpi、hdpi、xdpi、xxdpi：用来修饰 Android 中的 drawable 文件 夹及 values 文件夹，用来区分不同像素密度下的图片和 dimen 值。</li>
<li>mdpi:480*320,</li>
<li>hdpi:800<em>480,854</em>480,960*540</li>
<li>xhdpi:1280*720</li>
<li>xxhdpi:1920*1080</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下屏幕适配全解析的文章
    
    </summary>
    
      <category term="屏幕适配" scheme="http://yoursite.com/categories/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android,屏幕适配" scheme="http://yoursite.com/tags/Android-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
</feed>
