<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Wu&#39;s Blog</title>
  <subtitle>The closer you think you are,the less you will actually see.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-31T13:06:19.155Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HappyNewYear</title>
    <link href="http://yoursite.com/2017/12/31/HappyNewYear_2017/"/>
    <id>http://yoursite.com/2017/12/31/HappyNewYear_2017/</id>
    <published>2017-12-31T13:05:00.000Z</published>
    <updated>2016-12-31T13:06:19.155Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=30394763&auto=1&height=66"></iframe>

<h4 id="故事的小黄花"><a href="#故事的小黄花" class="headerlink" title="故事的小黄花"></a>故事的小黄花</h4><h4 id="从出生那年就飘着"><a href="#从出生那年就飘着" class="headerlink" title="从出生那年就飘着"></a>从出生那年就飘着</h4><h4 id="童年的荡秋千"><a href="#童年的荡秋千" class="headerlink" title="童年的荡秋千"></a>童年的荡秋千</h4><h4 id="随记忆一直晃到现在"><a href="#随记忆一直晃到现在" class="headerlink" title="随记忆一直晃到现在"></a>随记忆一直晃到现在</h4><h4 id="rui-sou-sou-xi-dou-xi-la"><a href="#rui-sou-sou-xi-dou-xi-la" class="headerlink" title="rui sou sou xi dou xi la"></a>rui sou sou xi dou xi la</h4><h4 id="sou-la-xi-xi-xi-xi-la-xi-la-sou"><a href="#sou-la-xi-xi-xi-xi-la-xi-la-sou" class="headerlink" title="sou la xi xi xi xi la xi la sou"></a>sou la xi xi xi xi la xi la sou</h4><h4 id="吹着前奏望着天空"><a href="#吹着前奏望着天空" class="headerlink" title="吹着前奏望着天空"></a>吹着前奏望着天空</h4><h4 id="我想起花瓣试着掉落"><a href="#我想起花瓣试着掉落" class="headerlink" title="我想起花瓣试着掉落"></a>我想起花瓣试着掉落</h4><h4 id="为你翘课的那一天"><a href="#为你翘课的那一天" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天"><a href="#花落的那一天" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间"><a href="#教室的那一间" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="我怎么看不见"><a href="#我怎么看不见" class="headerlink" title="我怎么看不见"></a>我怎么看不见</h4><h4 id="消失的下雨天"><a href="#消失的下雨天" class="headerlink" title="消失的下雨天"></a>消失的下雨天</h4><h4 id="我好想再淋一遍"><a href="#我好想再淋一遍" class="headerlink" title="我好想再淋一遍"></a>我好想再淋一遍</h4><h4 id="没想到失去的勇气我还留着"><a href="#没想到失去的勇气我还留着" class="headerlink" title="没想到失去的勇气我还留着"></a>没想到失去的勇气我还留着</h4><h4 id="好想再问一遍"><a href="#好想再问一遍" class="headerlink" title="好想再问一遍"></a>好想再问一遍</h4><h4 id="你会等待还是离开"><a href="#你会等待还是离开" class="headerlink" title="你会等待还是离开"></a>你会等待还是离开</h4><h4 id="刮风这天我试过握着你手"><a href="#刮风这天我试过握着你手" class="headerlink" title="刮风这天我试过握着你手"></a>刮风这天我试过握着你手</h4><h4 id="但偏偏雨渐渐大到我看你不见"><a href="#但偏偏雨渐渐大到我看你不见" class="headerlink" title="但偏偏雨渐渐大到我看你不见"></a>但偏偏雨渐渐大到我看你不见</h4><h4 id="还要多久我才能在你身边"><a href="#还要多久我才能在你身边" class="headerlink" title="还要多久我才能在你身边"></a>还要多久我才能在你身边</h4><h4 id="等到放晴的那天也许我会比较好一点"><a href="#等到放晴的那天也许我会比较好一点" class="headerlink" title="等到放晴的那天也许我会比较好一点"></a>等到放晴的那天也许我会比较好一点</h4><h4 id="从前从前有个人爱你很久"><a href="#从前从前有个人爱你很久" class="headerlink" title="从前从前有个人爱你很久"></a>从前从前有个人爱你很久</h4><h4 id="但偏偏风渐渐把距离吹得好远"><a href="#但偏偏风渐渐把距离吹得好远" class="headerlink" title="但偏偏风渐渐把距离吹得好远"></a>但偏偏风渐渐把距离吹得好远</h4><h4 id="好不容易又能再多爱一天"><a href="#好不容易又能再多爱一天" class="headerlink" title="好不容易又能再多爱一天"></a>好不容易又能再多爱一天</h4><h4 id="但故事的最后你好像还是说了拜拜"><a href="#但故事的最后你好像还是说了拜拜" class="headerlink" title="但故事的最后你好像还是说了拜拜"></a>但故事的最后你好像还是说了拜拜</h4><h4 id="为你翘课的那一天-1"><a href="#为你翘课的那一天-1" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-1"><a href="#花落的那一天-1" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-1"><a href="#教室的那一间-1" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="我怎么看不见-1"><a href="#我怎么看不见-1" class="headerlink" title="我怎么看不见"></a>我怎么看不见</h4><h4 id="消失的下雨天-1"><a href="#消失的下雨天-1" class="headerlink" title="消失的下雨天"></a>消失的下雨天</h4><h4 id="我好想再淋一遍-1"><a href="#我好想再淋一遍-1" class="headerlink" title="我好想再淋一遍"></a>我好想再淋一遍</h4><h4 id="没想到失去的勇气我还留着-1"><a href="#没想到失去的勇气我还留着-1" class="headerlink" title="没想到失去的勇气我还留着"></a>没想到失去的勇气我还留着</h4><h4 id="好想再问一遍-1"><a href="#好想再问一遍-1" class="headerlink" title="好想再问一遍"></a>好想再问一遍</h4><h4 id="你会等待还是离开-1"><a href="#你会等待还是离开-1" class="headerlink" title="你会等待还是离开"></a>你会等待还是离开</h4><h4 id="刮风这天我试过握着你手-1"><a href="#刮风这天我试过握着你手-1" class="headerlink" title="刮风这天我试过握着你手"></a>刮风这天我试过握着你手</h4><h4 id="但偏偏雨渐渐大到我看你不见-1"><a href="#但偏偏雨渐渐大到我看你不见-1" class="headerlink" title="但偏偏雨渐渐大到我看你不见"></a>但偏偏雨渐渐大到我看你不见</h4><h4 id="还要多久我才能在你身边-1"><a href="#还要多久我才能在你身边-1" class="headerlink" title="还要多久我才能在你身边"></a>还要多久我才能在你身边</h4><h4 id="等到放晴的那天也许我会比较好一点-1"><a href="#等到放晴的那天也许我会比较好一点-1" class="headerlink" title="等到放晴的那天也许我会比较好一点"></a>等到放晴的那天也许我会比较好一点</h4><h4 id="从前从前有个人爱你很久-1"><a href="#从前从前有个人爱你很久-1" class="headerlink" title="从前从前有个人爱你很久"></a>从前从前有个人爱你很久</h4><h4 id="偏偏风渐渐把距离吹得好远"><a href="#偏偏风渐渐把距离吹得好远" class="headerlink" title="偏偏风渐渐把距离吹得好远"></a>偏偏风渐渐把距离吹得好远</h4><h4 id="好不容易又能再多爱一天-1"><a href="#好不容易又能再多爱一天-1" class="headerlink" title="好不容易又能再多爱一天"></a>好不容易又能再多爱一天</h4><h4 id="但故事的最后你好像还是说了拜拜-1"><a href="#但故事的最后你好像还是说了拜拜-1" class="headerlink" title="但故事的最后你好像还是说了拜拜"></a>但故事的最后你好像还是说了拜拜</h4><h4 id="为你翘课的那一天-2"><a href="#为你翘课的那一天-2" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="为你翘课的那一天-3"><a href="#为你翘课的那一天-3" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="为你翘课的那一天-4"><a href="#为你翘课的那一天-4" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-2"><a href="#花落的那一天-2" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-2"><a href="#教室的那一间-2" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="为你翘课的那一天-5"><a href="#为你翘课的那一天-5" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-3"><a href="#花落的那一天-3" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-3"><a href="#教室的那一间-3" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><h4 id="为你翘课的那一天-6"><a href="#为你翘课的那一天-6" class="headerlink" title="为你翘课的那一天"></a>为你翘课的那一天</h4><h4 id="花落的那一天-4"><a href="#花落的那一天-4" class="headerlink" title="花落的那一天"></a>花落的那一天</h4><h4 id="教室的那一间-4"><a href="#教室的那一间-4" class="headerlink" title="教室的那一间"></a>教室的那一间</h4><hr>
<h4 id="对今年的总结："><a href="#对今年的总结：" class="headerlink" title="对今年的总结："></a>对今年的总结：</h4><ul>
<li>今年是特殊的一年，鬼知道我到底经历了什么。</li>
</ul>
<h4 id="对来年的展望："><a href="#对来年的展望：" class="headerlink" title="对来年的展望："></a>对来年的展望：</h4><ul>
<li>愿新的一年，我们都能被这个世界温柔相待。</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/e8b8b80752ba1ecd.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      对今年的总结和对未来的展望
    
    </summary>
    
      <category term="生活相关" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="新年快乐，HappyNewYear" scheme="http://yoursite.com/tags/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90%EF%BC%8CHappyNewYear/"/>
    
  </entry>
  
  <entry>
    <title>Android下的性能优化</title>
    <link href="http://yoursite.com/2016/05/31/android%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/05/31/android下的性能优化全解析/</id>
    <published>2016-05-31T13:16:33.000Z</published>
    <updated>2016-12-19T13:24:52.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下的性能优化"><a href="#Android下的性能优化" class="headerlink" title="Android下的性能优化"></a>Android下的性能优化</h1><h4 id="android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM-而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR-由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。"><a href="#android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM-而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR-由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。" class="headerlink" title="android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM,而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR,由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。"></a>android设备作为一种移动设备，不管是内存还是CPU的性能都受到了一定的限制，无法做到像PC设备那样具有超大的内存和高性能的CPU，鉴于这一点，这也意味着Android程序不可能无限制地使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM,而过多地使用CPU资源，一般指做大量的耗时任务，会导致手机变得卡顿甚至出现程序无法响应的情况，即ANR,由此看来，ANdroid程序的性能问题就变得异常突出了。以下介绍了一些有效的性能优化的方法。</h4><blockquote>
<p>1.布局优化</p>
</blockquote>
<ul>
<li>删除无用的控件和层级。可以使用HierarchyViewer来查看布局层级。</li>
<li>在布局层级相同的情况下，使用LinearLayout的效率比使用RelativeLayout的性能要高，因为RelativeLayout的性能要高，因为RelativeLayout的功能比较复杂，它的CPU渲染时间比较长，而LinearLayout和FragmentLayout都是简单高效的ViewGroup。</li>
<li>include标签配合merge标签使用来重用布局、减少布局层数。</li>
<li>使用ViewStub。它是一个非常轻量级的View，宽高都是0，因此它本身不参与任何布局和绘制的过程，它的意义在于按需加载所需要的布局，使用的时候再加载，不需要的时候不加载进来，提高程序初始化的性能，注意：ViewStub与设置visibility之间的差异；设置visibility只是可见，就算设置inVisible或者GONE，布局还是会加载的。</li>
</ul>
<blockquote>
<p>2.绘制优化</p>
</blockquote>
<ul>
<li>onDraw方法里不要做初始化对象的操作，因为onDraw方法会被频繁的调用。</li>
<li>onDraw方法不要做耗时的操作，这样会造成View的绘制过程不流畅。</li>
</ul>
<blockquote>
<p>3.内存泄漏优化</p>
</blockquote>
<ul>
<li>资源未关闭。使用了broadCastReceiver，ContentObserver,file,Cursor,Stream,Bitmap等资源的使用，应该在Avtivity销毁时及时的关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</li>
<li>静态成员变量持有类的引用。</li>
<li>非静态内部类持有外部类的引用，使用非静态内部类创建的静态变量。</li>
<li>单例引起的内存泄漏。</li>
<li>Handler造成的内存泄漏。</li>
<li>线程的生命周期不可控。</li>
<li>无限循环的属性动画引起的内存泄漏。</li>
</ul>
<blockquote>
<p>4.响应速度和ANR日志分析</p>
</blockquote>
<ul>
<li>响应速度优化的核心思想就是避免在主线程中做耗时操作，但是有的时候确实有很多耗时的操作，那就必须将这些耗时的操作放在线程中去执行，即采用异步的方式执行耗时的操作。</li>
<li>在实际开发中，ANR是很难从代码上发现的，如果在开发的过程中遇到了ANR,那么怎么定位问题呢？其实在一个进程发生ANR后，系统会在/data/anr目录下创建一个文件traces.txt,通过分析这个文件就能定位出ANR的原因。</li>
</ul>
<blockquote>
<p>5.Bitmap优化</p>
</blockquote>
<ul>
<li>目前比较常用的缓存策略是LruChache和DiskLruCache,其中LruCache常被用做内存缓存，而DiskLruCache常用做存储缓存。Lru是least Tecently Used的缩写，即最近最少使用算法，这种算法的核心思想为：当缓存快满的时候，会淘汰近期最少使用的缓存目标。</li>
<li>高效加载Bitmap的核心思想，其实很简单，那就是采用BitmapFactory.Options来加载所需的图片尺寸。主要用到了它的inSampleSize参数即采样率。</li>
</ul>
<blockquote>
<p>6.ListView优化</p>
</blockquote>
<ul>
<li>在adapter的getVIew（）方法里尽量少使用逻辑；</li>
<li>滑动的时候不要加载图片；</li>
<li>图片的加载使用异步方式；</li>
<li>将listView的scrollingCache和animateCache设置为false. scrollingCache本质上是drawing cache，你可以让一个View将他自己的drawing保存在cache中（保存为一个bitmap），这样下次再显示View的时候就不用重画了，而是从cache中取出。默认情况下drawing cahce是禁用的，因为它太耗内存了，但是它确实比重画来的更加平滑。而在ListView中，scrollingCache是默认开启的，我们可以手动将它关闭。ListView默认开启了animateCache，这会消耗大量的内存，因此会频繁调用GC，我们可以手动将它关闭掉。</li>
<li>listview 被多层嵌套，多次的onMessure导致卡顿，如果多层嵌套无法避免，建议把listview的高和宽设置为fill_parent. 如果是代码继承的listview，那么也请你别忘记为你的继承类添加上LayoutPrams，注意高和宽都是fill_parent的;  以往我一般都是将listview的高度设置成fill_parent，而这次我是设为wrap_content，这样做的问题在于，ListView没有取到实际的高度，他还要根据计算才能确定，而每一次计算应该会触发listview的渲染，所以就会出现getview的调用次数跟正常情况相比多了好几倍。所以在一般情况下，我建议把listiview在布局文件中的高度总是设置为：fill_parent（或者match_parent），这不仅仅是getview的调用次数问题，还涉及到布局的效率。</li>
<li>使用静态的viewHolder。</li>
</ul>
<blockquote>
<p>7.线程优化</p>
</blockquote>
<ul>
<li>线程优化的思想是采用线程池，避免程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了线程的创建和销毁带来的性能开销，同时线程池还能还能有效地控制线程池的最大并发数，避免大量的线程相互抢占系统资源从而导致阻塞现象的发生。因此在实际的开发中，我们应该尽量的采用线程池，而不是每次都创建一个Thread对象。</li>
</ul>
<blockquote>
<p>8.数据库优化</p>
</blockquote>
<ul>
<li>使用事务。大量的数据的增删如果不使用事务，而是循环调用Insert和Delete的话，会因为每一笔操作都需要打开、写入最后关闭Journal文件（这个文件是临时用来保存数据操作的中间结果）而使得开销非常大。<br>  使用的方法：<br>  db.beginTransaction();<br>  db.setTransactionSuccessful();<br>  db.endTransaction();</li>
<li>使用索引。索引维护这一个表某一列或者某几列的顺序，这样就可以快速的定位到某一组值，而不是扫描全表。所有的索引信息会被保存到一个独立的索引表中，所以会产生额外的空间占用，不过绝对物超所值，特别是你会在数据库中进行大量的读及搜索操作的时候。</li>
<li>sql语句拼接的时候用StringBuffer代替String</li>
<li>在写表的时候调用sqliteOpenHelper&amp;getWritableDatabase()，在读表的时候调用SqliteOpenHelper&amp;getReadableDatabase()</li>
<li>开启子线程进行数据库的读写</li>
</ul>
<blockquote>
<p>9.一些性能优化建议</p>
</blockquote>
<ul>
<li>避免创建过多的对象</li>
<li>不要过多的使用枚举，枚举占用的内存空间要比整形大</li>
<li>常量请使用static final来修饰</li>
<li>使用一些android特有的数据结构，比如SparseArray和Pair等，他们都具有更好的性能</li>
<li>适当的使用软引用和弱引用</li>
<li>采用内存缓存和磁盘缓存</li>
<li>尽量采用静态内部类。这样可以避免潜在的内部类而导致的内存泄漏</li>
<li>尽量使用google推荐的处理方式。比如序列化采用parcelable,而不用Serializable</li>
</ul>
<blockquote>
<p>10.内存优化可能会用到的工具（</p>
</blockquote>
<ul>
<li>HierarchyViewer（检查布局层级）</li>
<li>TraceView（对应用中方法耗时进行统计）</li>
<li>APT(对进程的CPU和内存进行监视和分析)</li>
<li>MAT(对内存泄漏分析的主要工具)</li>
</ul>
<blockquote>
<p>11.提高程序的可维护性</p>
</blockquote>
<ul>
<li>提高代码的可读性</li>
<li>灵活应用面向对象语言的三大特性和六大原则从而达成对修改关闭，对扩展开放的终极目标。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下的性能优化的文章
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android,性能优化" scheme="http://yoursite.com/tags/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MVC,MVP和MVVM开发模式解析</title>
    <link href="http://yoursite.com/2016/03/21/MVC,MVP%E5%92%8CMVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20-%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <id>http://yoursite.com/2016/03/21/MVC,MVP和MVVM开发模式解析 -升级版/</id>
    <published>2016-03-21T07:13:48.000Z</published>
    <updated>2016-12-19T14:00:45.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC应用于Ruby on Rails, Spring Framework, iOS开发和 ASP.NET等。</p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>Controller: 操作Model层获取数据传递给UI</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/1f0f053ee41dd60f.png" alt=""></p>
<h3 id="服务器端的MVC"><a href="#服务器端的MVC" class="headerlink" title="服务器端的MVC"></a>服务器端的MVC</h3><p><img src="http://p1.bpimg.com/567571/32dbc1b0db151baa.png" alt=""></p>
<h3 id="Android中MVC"><a href="#Android中MVC" class="headerlink" title="Android中MVC"></a>Android中MVC</h3><p>Android中并没有清晰的MVC框架，如果把Activity当做Controller,根据我们实际开发经验，里面会有大量的UI操作，所以V和C就傻傻分不清了。</p>
<ul>
<li>Model:Java Bean, NetworkManager, DataBaseHelper</li>
<li>View: xml res</li>
<li>Controller: Activity Fragment</li>
<li>ArrayList-ListView-Adapter(MVC)</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP主要应用于ASP.NET等。<strong>MVP与MVC主要区别是View和Model不再耦合。</strong></p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>Presenter: 操作Model层获取数据传递给UI<br><img src="http://p1.bpimg.com/567571/55fb6e5522f46de2.png" alt=""></li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM主要应用于WPF, Silverlight, Caliburn, nRoute等。</p>
<ul>
<li>Model: 获取数据的业务逻辑，网络操作，数据库操作</li>
<li>View: UI</li>
<li>ViewModel: 将View和Model绑定</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/1e2bf8b8c8d87d7c.png" alt=""></p>
<h3 id="Android中MVVM"><a href="#Android中MVVM" class="headerlink" title="Android中MVVM"></a>Android中MVVM</h3><p><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">Data Binding Library</a><br><a href="http://www.jianshu.com/p/b1df61a4df77" target="_blank" rel="external">中文翻译</a></p>
<h2 id="软件架构的核心思想"><a href="#软件架构的核心思想" class="headerlink" title="软件架构的核心思想"></a>软件架构的核心思想</h2><blockquote>
<p>分层分模块</p>
</blockquote>
<p><img src="http://p1.bpimg.com/567571/7297425199586e4e.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android architecture</a></p>
<p><a href="http://www.jianshu.com/p/6a86f7fdc0cb" target="_blank" rel="external">MVC,MVP和MVVM模式如何选择</a></p>
<p><a href="http://www.dotnettricks.com/learn/designpatterns/understanding-mvc-mvp-and-mvvm-design-patterns" target="_blank" rel="external">Understanding MVC, MVP and MVVM Design Patterns</a></p>
<p><a href="http://zjutkz.net/2016/04/13/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM/" target="_blank" rel="external">教你认清MVC，MVP和MVVM</a></p>
<p><a href="https://github.com/LyndonChin/MasteringAndroidDataBinding" target="_blank" rel="external">Android Data Binding</a></p>
<p><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">Clean Architecture</a></p>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述MVC,MVP和MVVM开发模式解析的文章
    
    </summary>
    
      <category term="软件架构" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Android,软件构架,mvc,mvp,mvvm" scheme="http://yoursite.com/tags/Android-%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%9E%B6-mvc-mvp-mvvm/"/>
    
  </entry>
  
  <entry>
    <title>Android下数据库的解析</title>
    <link href="http://yoursite.com/2016/01/16/Android%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/16/Android下数据库的解析/</id>
    <published>2016-01-16T05:18:53.000Z</published>
    <updated>2016-12-19T13:24:09.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下数据库的解析"><a href="#Android下数据库的解析" class="headerlink" title="Android下数据库的解析"></a>Android下数据库的解析</h1><h2 id="建表的语句："><a href="#建表的语句：" class="headerlink" title="建表的语句："></a>建表的语句：</h2><ul>
<li><p>以下语句就可以在数据库文件里创建一个名为students的表名，他有id， name, age 三个字段。</p>
<pre><code>继承 SqlliteOpenHelper
在构造里写出数据库名，然后在onCreate里写出创建表的语句：
db.execSQL(&quot;create table students(_id interger primary key autoincrement,name varchar(20), age integer(20)&quot;);
</code></pre></li>
</ul>
<h2 id="数据库文件的赠删改查："><a href="#数据库文件的赠删改查：" class="headerlink" title="数据库文件的赠删改查："></a>数据库文件的赠删改查：</h2><ul>
<li><p>以下语句可以实现数据库的增删改查：</p>
<pre><code>Sql语句：
add:
insert into  students(id,name,age) values(1,&apos;huge&apos;,38);

delete：
delete from students where name = &apos;lxr&apos;;

update:
update students set age = 34 where name = &apos;lxr&apos;;

query:
select name age from students where name = &apos;lxr&apos;;
</code></pre></li>
</ul>
<h2 id="数据库的模糊查询"><a href="#数据库的模糊查询" class="headerlink" title="数据库的模糊查询"></a>数据库的模糊查询</h2><ul>
<li>使用like可以实现数据库的模糊查询</li>
<li><pre><code>select name age from students where name LIKE&apos;Mc%&apos;; 
SQL模糊查询，使用like比较字，加上SQL里的通配符，请参考以下：
  　　1、LIKE&apos;Mc%&apos; 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
  　　2、LIKE&apos;%inger&apos; 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
  　　3、LIKE&apos;%en%&apos; 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
  　　4、LIKE&apos;_heryl&apos; 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
  　　5、LIKE&apos;[CK]ars[eo]n&apos; 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
  　　6、LIKE&apos;[M-Z]inger&apos; 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
  　　7、LIKE&apos;M[^c]%&apos; 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。
</code></pre></li>
</ul>
<h2 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h2><ul>
<li><p>使用事务。大量数据增加或删除时如果不使用事务，而是循环调用 INSERT 和 DELETE 的话，会因为每一笔操作都需要打开、写入最后关闭 journal  文件（这个文件是临时用来保存数据操作的中间结果）而使得开销非常大。<br>使用方法：</p>
<ul>
<li>db.beginTransaction()。</li>
<li>开始进行循环添加或者删除操作。    </li>
<li>db.setTransactionSuccessful()。</li>
<li>db.endTransaction()。</li>
</ul>
</li>
<li><p>使用索引。索引维护着一个表中某一列或某几列的顺序，这样就可 以快速定位到一组值，而不用扫遍全表。所有的索引信息会被保存在一个 独立的索引表中，所以会产生额外的空间占用，不过绝对物超所值，特别 是当你会在数据库中进行大量的读及搜索操作时。</p>
<ul>
<li>创建语句：CREATE INDEX name_index ON username(firstname, lastname)</li>
<li><p>索引分类：</p>
<ul>
<li>普通索引和唯一性索引。 </li>
<li>单个索引：索引建立语句中仅包含单个字段。复合索引：在索引建立语句中同时包含多个字段。</li>
<li><p>聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照 顺序排列。非聚簇索引。</p>
</li>
<li><p>使用场景：</p>
<ul>
<li>当某字段数据更新频率较低，查询频率较高，经常有范围 查询(&gt;, &lt;, =, &gt;=, &lt;=)或 order by、group by 发生时建议使用索引。</li>
<li>经常同时存取多列，且每列都含有重复值可考虑建立复合索引。</li>
<li>使用注意项（较难）：<ul>
<li>对于复合索引，把使用最频繁的列做为前导列 (索引中第一个字段)。<ul>
<li>避免对索引列进行计算，对 where 子句列的任何计算如果不能被编译 优化，都会导致查询时索引失效。</li>
</ul>
</li>
<li>比较值避免使用 NULL。 </li>
<li>多表查询时要注意是选择合适的表做为内表。内外表的选择可由公式： 外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳 方案。</li>
<li>把过滤记录数最多的条件放在最前面。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>sql 语句拼接时可以使用 StringBuffer 代替 String。 </p>
</li>
<li>在写表时调用 sqliteOpenHelper..getWritableDatabase()，<br>在读表时候调用 sqliteOpenHelper..getReadableDatabase()，getReadableDatabase 性能更优。</li>
<li>开启子线程进行数据库读写。</li>
</ul>
<h2 id="版本迭代中数据库的更新问题"><a href="#版本迭代中数据库的更新问题" class="headerlink" title="版本迭代中数据库的更新问题"></a>版本迭代中数据库的更新问题</h2><ul>
<li><p>应用程序如何知道数据库需要升级：SQLiteOpenHelper类的构造函数有 一个参数是int version，它的意思就是指数据库版本号。比如在应用1.0版本 中，我们使用SQLiteOpenHelper访问数据库时，该参数为1，那么数据库版本号 1就会写在我们的数据库中。到了1.1版本，我们的数据库需要发生变化，那么 我们1.1版本的程序中就要使用一个大于1的整数来构造SQLiteOpenHelper类， 用于访问新的数据库，比如2。当我们的1.1新程序读取1.0版本的老数据库时， 就发现老数据库里存储的数据库版本是1，而我们新程序访问它时填的版本号为 2，系统就知道数据库需要升级。<br>何时触发数据库升级：当系统在构造 SQLiteOpenHelper 类的对象时，如果 发现版本号不一样，就会自动调用   onUpgrade    函数，让你在这里对数据库进行升级。</p>
</li>
<li><p>升级时应该考虑的问题：数据库中的原数据不能丢失。</p>
<ul>
<li>如何升级：在 onUpgrade 方法中执行相应的更新数据库的 sql 语句就行了。下 面列举一些常见的更新的sql 语句。<ul>
<li>增加新表：CREATE TABLE table_name(_id integer primary key autoincrement, region varchar, code varchar)。 增加或者删除列：SQLite数库对ALTER TABLE命令支持非常有限，只能在表末尾 添加列，不能修改列定义，不能删除已有的列。那么如果要修改表呢？我们可 以采用临时表的办法。具体来说有四步：<ul>
<li>将表明改为临时表：ALTER TABLE table_name RENAME TO table_name_temp </li>
<li>创建新表。</li>
<li>将临时表的数据导入新表（不能出现values关键字）：insert into table_name (_id, region, code, country) select _id, region, code, \”CHINA\” from table_name_temp</li>
<li>删除临时表：DROP TABLE table_name _temp</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跨版本的数据库升级问题：应用程序发布了多个版本，以致出现了三个及 以上数据库版本。如何确保所有的用户升级应用后数据库都能用呢？</p>
<ul>
<li><p>方法一：确定相邻版本的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3这样依次下去。 优点：每次更新数据库的时候只需要在onUpgrade方法的末尾加一段从上个版 本升级到新版本的代码，易于理解和维护。 缺点：是当版本变多之后，多次迭代升级可能需要花费不少时间，增加用户等 待时间；</p>
</li>
<li><p>方式二：为每个版本确定与现在数据库的差别，为每个case撰写专门的升级代码。 优点：则是可以保证每个版本的用户都可以在消耗最少的时间升级到最新的数据库而无需做无用的数据多次转存。缺点：是强迫开发者记忆所有版本数据库的完整结构，且每次升级时 onUpgrade方法都必须全部重写。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下数据库的解析的文章
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Android,数据库" scheme="http://yoursite.com/tags/Android-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>静态代理和动态代理解析</title>
    <link href="http://yoursite.com/2015/09/11/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/09/11/静态代理和动态代理解析/</id>
    <published>2015-09-11T14:13:34.000Z</published>
    <updated>2016-12-19T13:35:18.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>1.相关概念</p>
</blockquote>
<ul>
<li>1.1 代理</li>
</ul>
<p>在某些情况下，我们不希望或是不能直接访问对象 A，而是通过访问一个中介对象 B，由 B 去访问 A 达成目的，这种方式我们就称为代理。<br>这里对象 A 所属类我们称为委托类，也称为被代理类，对象 B 所属类称为代理类。<br>代理优点有：</p>
<pre><code>隐藏委托类的实现
解耦，不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作
</code></pre><p>根据程序运行前代理类是否已经存在，可以将代理分为静态代理和动态代理。</p>
<ul>
<li>1.2 静态代理</li>
</ul>
<p>代理类在程序运行前已经存在的代理方式称为静态代理。<br>通过上面解释可以知道，由开发人员编写或是编译器生成代理类的方式都属于静态代理，如下是简单的静态代理实例：</p>
<pre><code>class ClassA {
    public void operateMethod1() {};

    public void operateMethod2() {};

    public void operateMethod3() {};
}

public class ClassB {
    private ClassA a;

    public ClassB(ClassA a) {
        this.a = a;
    }

    public void operateMethod1() {
        a.operateMethod1();
    };

    public void operateMethod2() {
        a.operateMethod2();
    };

    // not export operateMethod3()
}
</code></pre><p>上面ClassA是委托类，ClassB是代理类，ClassB中的函数都是直接调用ClassA相应函数，并且隐藏了Class的operateMethod3()函数。</p>
<p>静态代理中代理类和委托类也常常继承同一父类或实现同一接口。</p>
<p>*　1.3 动态代理</p>
<ul>
<li><p>代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。</p>
</li>
<li><p>Java 提供了动态代理的实现方式，可以在运行时刻动态生成代理类。这种代理方式的一大好处是可以方便对代理类的函数做统一或特殊处理，如记录所有函数执行时间、所有函数执行前添加验证判断、对某个特殊函数进行特殊操作，而不用像静态代理方式那样需要修改每个函数。</p>
</li>
<li><p>A:动态代理概述</p>
<ul>
<li>代理：本来应该自己做的事情，请了别人来做，被请的人就是代理对象。</li>
<li>举例：春节回家买票让人代买</li>
<li>动态代理：在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理</li>
<li>在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象<blockquote>
<p>动态代理实例</p>
</blockquote>
</li>
</ul>
</li>
<li><p>实现动态代理包括三步：</p>
<ul>
<li>新建委托类；</li>
<li>实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；</li>
<li>通过Proxy类新建代理类对象。</li>
<li>proxy中的方法</li>
<li>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</li>
<li>最终会调用InvocationHandler的方法</li>
<li>InvocationHandler接口 </li>
<li>public Object invoke(Object proxy,Method method,Object[] args)；</li>
</ul>
</li>
<li><pre><code>//step1: 定义User接口

public interface User {
    public void add();

    public void delete();
}

//step2: 定义类实现User接口

public class UserImp implements User {
    @Override
    public void add() {
        //System.out.println(&quot;权限校验&quot;);
        System.out.println(&quot;添加功能&quot;);
        //System.out.println(&quot;日志记录&quot;);
    }

    @Override
    public void delete() {
        //System.out.println(&quot;权限校验&quot;);
        System.out.println(&quot;删除功能&quot;);
        //System.out.println(&quot;日志记录&quot;);
    }

}

//step3: InvocationHandler的实现类

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyInvocationHandler implements InvocationHandler {

    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {
        System.out.println(&quot;权限校验&quot;);
        method.invoke(target, args);                    //执行被代理target对象的方法
        System.out.println(&quot;日志记录&quot;);
        return null;
    }

}

//定义测试类
import java.lang.reflect.Proxy;
public class Test {
    /**
     * @param args
     */
    public static void main(String[] args) {
        /*UserImp ui = new UserImp();
        ui.add();  //添加功能
        ui.delete(); //删除功能

        System.out.println(&quot;-------------------------------&quot;);*/
        /*
         * public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,
         * InvocationHandler h)
         */
        /*
        MyInvocationHandler m = new MyInvocationHandler(ui);
        User u = (User)Proxy.newProxyInstance(ui.getClass().getClassLoader(), ui.getClass().getInterfaces(), m);
        u.add();   //权限校验    添加功能    日志记录
        u.delete(); //权限校验 删除功能  日志记录
        */

        StudentImp si = new StudentImp();
        si.login();//登录
        si.submit();//提交

        System.out.println(&quot;-------------------------------&quot;);
        MyInvocationHandler m = new MyInvocationHandler(si);
        Student s = (Student)Proxy.newProxyInstance(si.getClass().getClassLoader(), si.getClass().getInterfaces(), m);

        s.login();  //权限校验    登录    日志记录
        s.submit(); //权限校验 提交  日志记录
    }

}

//类似step1: 定义Student接口
public interface Student {
    public void login();

    public void submit();
}

//类似step2: 定义类实现Student接口
public class StudentImp implements Student {
    @Override
    public void login() {
        System.out.println(&quot;登录&quot;);
    }

    @Override
    public void submit() {
        System.out.println(&quot;提交&quot;);
    }

}
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述静态代理和动态代理解析的文章
    
    </summary>
    
      <category term="代理" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="Android,静态代理,动态代理" scheme="http://yoursite.com/tags/Android-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入的解析</title>
    <link href="http://yoursite.com/2015/06/07/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/06/07/依赖注入的解析/</id>
    <published>2015-06-07T12:18:43.000Z</published>
    <updated>2016-12-19T13:36:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="依赖注入的解析"><a href="#依赖注入的解析" class="headerlink" title="依赖注入的解析"></a>依赖注入的解析</h1><blockquote>
<ol>
<li>依赖</li>
</ol>
</blockquote>
<p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human() {
        father = new Father();
    }
}
</code></pre><p>仔细看这段代码我们会发现存在一些问题：</p>
<ul>
<li>如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码；</li>
<li>如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；</li>
<li>如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。</li>
</ul>
<blockquote>
<p>2.依赖注入</p>
</blockquote>
<p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：</p>
<pre><code>public class Human {
    ...
    Father father;
    ...
    public Human(Father father) {
        this.father = father;
    }
}
</code></pre><p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。<br>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：</p>
<ul>
<li>解耦，将依赖之间解耦。</li>
<li>因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</li>
</ul>
<blockquote>
<p>3.Java 中的依赖注入</p>
</blockquote>
<p>依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。</p>
<pre><code>public class Human {
    ...
    @Inject Father father;
    ...
    public Human() {
    }
}
</code></pre><p>上面这段代码看起来很神奇：只是增加了一个注解，Father 对象就能自动注入了？这个注入过程是怎么完成的？实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。现在 Java 语言中较流行的依赖注入框架有 Google Guice、Spring 等，而在 Android 上比较流行的有 RoboGuice、Dagger 等。</p>
<blockquote>
<p>另外：mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。比如通过Butter Knife、Dagger依赖注入库实现，都是使用注解来实现依赖注入，但它利用 APT(Annotation Process Tool) 在编译时生成辅助类，这些类继承特定父类或实现特定接口，程序在运行时加载这些辅助类，调用相应接口完成依赖生成和注入。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android依赖注入的文章
    
    </summary>
    
      <category term="依赖注入" scheme="http://yoursite.com/categories/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
    
      <category term="Android,依赖注入" scheme="http://yoursite.com/tags/Android-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>注解Annotation解析</title>
    <link href="http://yoursite.com/2015/05/01/%E6%B3%A8%E8%A7%A3Annotation%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/05/01/注解Annotation解析/</id>
    <published>2015-05-01T13:10:33.000Z</published>
    <updated>2016-12-19T13:41:13.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注解Annotation解析"><a href="#注解Annotation解析" class="headerlink" title="注解Annotation解析"></a>注解Annotation解析</h1><p>不少开源库都用到了注解的方式来简化代码提高开发效率。本文简单介绍下 Annotation 示例、概念及作用、分类、自定义、解析，并对几个 Android 开源库 Annotation 原理进行简析。</p>
<blockquote>
<ol>
<li>Annotation 示例</li>
</ol>
</blockquote>
<pre><code>Override Annotation

@Override //重写的注解
public void onCreate(Bundle savedInstanceState);

Retrofit Annotation

@GET(&quot;/users/{username}&quot;)
User getUser(@Path(&quot;username&quot;) String username);

Butter Knife Annotation

@InjectView(R.id.user) EditText username;

ActiveAndroid Annotation

@Column(name = “Name&quot;) public String name;

Retrofit 为符合 RESTful 规范的网络请求框架
Butter Knife 为 View 及事件等依赖注入框架
Active Android 为 ORM 框架
</code></pre><blockquote>
<p>2.Annotation 概念及作用</p>
</blockquote>
<ul>
<li><p>2.1 概念</p>
<p>  An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate.</p>
</li>
</ul>
<p>能够添加到 Java 源代码的语法元数据。类、方法、变量、参数、包都可以被注解，可用来将信息元数据与程序元素进行关联。Annotation 中文常译为“注解”。</p>
<ul>
<li>2.2 作用</li>
</ul>
<p>a. 标记，用于告诉编译器一些信息<br>b. 编译时动态处理，如动态生成代码<br>c. 运行时动态处理，如得到注解信息<br>这里的三个作用实际对应着后面自定义 Annotation 时说的 @Retention 三种值分别表示的 Annotation</p>
<pre><code>public class Person {

    private int    id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public boolean equals(Person person) {
        return person.id == id;
    }

    public int hashCode() {
        return id;
    }

    public static void main(String[] args) {

        Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();
        for (int i = 0; i &lt; 10; i++) {
            set.add(new Person(i, &quot;Jim&quot;));
        }
        System.out.println(set.size());
    }
}
</code></pre><p>上面的运行结果是多少？</p>
<blockquote>
<p>3.Annotation 分类</p>
</blockquote>
<ul>
<li>3.1 标准 Annotation，Override, Deprecated, SuppressWarnings</li>
</ul>
<p>标准 Annotation 是指 Java 自带的几个 Annotation，上面三个分别表示重写函数，不鼓励使用(有更好方式、使用有风险或已不在维护)，忽略某项 Warning</p>
<ul>
<li>3.2 元 Annotation，@Retention, @Target, @Inherited, @Documented</li>
</ul>
<p>元 Annotation 是指用来定义 Annotation 的 Annotation，在后面 Annotation 自定义部分会详细介绍含义</p>
<ul>
<li>3.3 自定义 Annotation</li>
</ul>
<p>自定义 Annotation 表示自己根据需要定义的 Annotation，定义时需要用到上面的元 Annotation<br>这里是一种分类而已，也可以根据作用域分为源码时、编译时、运行时 Annotation，后面在自定义 Annotation 时会具体介绍</p>
<blockquote>
<p>4.Annotation 自定义</p>
</blockquote>
<ul>
<li><p>4.1 调用</p>
<pre><code>public class App {
    @MethodInfo(
        author = “trinea.cn+android@gmail.com”,
        date = &quot;2014/02/14&quot;,
        version = 2)
    public String getAppName() {
        return &quot;trinea&quot;;
    }
}
</code></pre></li>
</ul>
<p>这里是调用自定义 Annotation——MethodInfo 的示例。<br>MethodInfo Annotation 作用为给方法添加相关信息，包括 author、date、version。</p>
<ul>
<li><p>4.2 定义</p>
<pre><code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Inherited
public @interface MethodInfo {

    String author() default &quot;trinea@gmail.com&quot;;

    String date();

    int version() default 1;
}

这里是 MethodInfo 的实现部分
(1). 通过 @interface 定义，注解名即为自定义注解名
(2). 注解配置参数名为注解类的方法名，且：
a. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public，不允许抛异常
b. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组
c. 若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation
(3). 可以加 default 表示默认值
</code></pre></li>
<li><p>4.3 元 Annotation</p>
<pre><code>@Documented 是否会保存到 Javadoc 文档中
@Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings
@Target 可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有
@Inherited 是否可以被继承，默认为 false
</code></pre></li>
</ul>
<blockquote>
<p>5.Annotation 解析</p>
</blockquote>
<ul>
<li><p>5.1 运行时 Annotation 解析</p>
<pre><code>(1) 运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析

method.getAnnotation(AnnotationName.class);
method.getAnnotations();
method.isAnnotationPresent(AnnotationName.class);

其他 @Target 如 Field，Class 方法类似
getAnnotation(AnnotationName.class) 表示得到该 Target 某个 Annotation 的信息，因为一个 Target 可以被多个 Annotation 修饰
getAnnotations() 则表示得到该 Target 所有 Annotation
isAnnotationPresent(AnnotationName.class) 表示该 Target 是否被某个 Annotation 修饰
(2) 解析示例如下：

public static void main(String[] args) {
    try {
        Class cls = Class.forName(&quot;cn.trinea.java.test.annotation.App&quot;);
        for (Method method : cls.getMethods()) {
            MethodInfo methodInfo = method.getAnnotation(
MethodInfo.class);
            if (methodInfo != null) {
                System.out.println(&quot;method name:&quot; + method.getName());
                System.out.println(&quot;method author:&quot; + methodInfo.author());
                System.out.println(&quot;method version:&quot; + methodInfo.version());
                System.out.println(&quot;method date:&quot; + methodInfo.date());
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}

以之前自定义的 MethodInfo 为例，利用 Target（这里是 Method）getAnnotation 函数得到 Annotation 信息，然后就可以调用 Annotation 的方法得到响应属性值
</code></pre></li>
<li><p>5.2 编译时 Annotation 解析</p>
<pre><code>(1) 编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，甴编译器自动解析。需要做的
a. 自定义类集成自 AbstractProcessor
b. 重写其中的 process 函数
这块很多同学不理解，实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理
(2) 假设 MethodInfo 的 @Retention 为 CLASS，解析示例如下：

@SupportedAnnotationTypes({ &quot;cn.trinea.java.test.annotation.MethodInfo&quot; })
public class MethodInfoProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {
        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        for (TypeElement te : annotations) {
            for (Element element : env.getElementsAnnotatedWith(te)) {
                MethodInfo methodInfo = element.getAnnotation(MethodInfo.class);
                map.put(element.getEnclosingElement().toString(), methodInfo.author());
            }
        }
        return false;
    }
}

SupportedAnnotationTypes 表示这个 Processor 要处理的 Annotation 名字。
process 函数中参数 annotations 表示待处理的 Annotations，参数 env 表示当前或是之前的运行环境
process 函数返回值表示这组 annotations 是否被这个 Processor 接受，如果接受后续子的 rocessor 不会再对这个 Annotations 进行处理
</code></pre></li>
</ul>
<blockquote>
<p>6.几个 Android 开源库 Annotation 原理简析</p>
<ul>
<li>6.1 Annotation — Retrofit<pre><code>(1) 调用
</code></pre></li>
</ul>
</blockquote>
<pre><code>@GET(&quot;/users/{username}&quot;)
User getUser(@Path(&quot;username&quot;) String username);
(2) 定义
@Documented
@Target(METHOD)
@Retention(RUNTIME)
@RestMethod(&quot;GET&quot;)
public @interface GET {
  String value();
}
从定义可看出 Retrofit 的 Get Annotation 是运行时 Annotation，并且只能用于修饰 Method
(3) 原理
private void parseMethodAnnotations() {
    for (Annotation methodAnnotation : method.getAnnotations()) {
    Class&lt;? extends Annotation&gt; annotationType = methodAnnotation.annotationType();
    RestMethod methodInfo = null;

    for (Annotation innerAnnotation : annotationType.getAnnotations()) {
        if (RestMethod.class == innerAnnotation.annotationType()) {
            methodInfo = (RestMethod) innerAnnotation;
            break;
        }
    }
    ……
    }
}   
RestMethodInfo.java 的 parseMethodAnnotations 方法如上，会检查每个方法的每个 Annotation， 看是否被 RestMethod 这个 Annotation 修饰的 Annotation 修饰，这个有点绕，就是是否被 GET、DELETE、POST、PUT、HEAD、PATCH 这些 Annotation 修饰，然后得到 Annotation 信息，在对接口进行动态代理时会掉用到这些 Annotation 信息从而完成调用。

Retrofit 原理涉及到动态代理，这里原理都只介绍 Annotation，具体原理分析请见 Android 开源项目实现原理解析
</code></pre><ul>
<li><p>6.2 Annotation — Butter Knife</p>
<pre><code>(1) 调用

@InjectView(R.id.user) 
EditText username;

(2) 定义

@Retention(CLASS) 
@Target(FIELD)
public @interface InjectView {
  int value();
}

可看出 Butter Knife 的 InjectView Annotation 是编译时 Annotation，并且只能用于修饰属性
(3) 原理

@Override 
public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {
    Map&lt;TypeElement, ViewInjector&gt; targetClassMap = findAndParseTargets(env);

    for (Map.Entry&lt;TypeElement, ViewInjector&gt; entry : targetClassMap.entrySet()) {
        TypeElement typeElement = entry.getKey();
        ViewInjector viewInjector = entry.getValue();

        try {
            JavaFileObject jfo = filer.createSourceFile(viewInjector.getFqcn(), typeElement);
            Writer writer = jfo.openWriter();
            writer.write(viewInjector.brewJava());
            writer.flush();
            writer.close();
        } catch (IOException e) {
            error(typeElement, &quot;Unable to write injector for type %s: %s&quot;, typeElement, e.getMessage());
        }
    }

    return true;
}

ButterKnifeProcessor.java 的 process 方法如上，编译时，在此方法中过滤 InjectView 这个 Annotation 到 targetClassMap 后，会根据 targetClassMap 中元素生成不同的 class 文件到最终的 APK 中，然后在运行时调用 ButterKnife.inject(x) 函数时会到之前编译时生成的类中去找。 这里原理都只介绍 Annotation，具体原理分析请见 Android 开源项目实现原理解析
</code></pre></li>
<li><p>6.3 Annotation — ActiveAndroid</p>
<pre><code>(1) 调用

@Column(name = “Name&quot;) 
public String name;

(2) 定义

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
  ……
}

可看出 ActiveAndroid 的 Column Annotation 是运行时 Annotation，并且只能用于修饰属性。
(3) 原理

Field idField = getIdField(type);
mColumnNames.put(idField, mIdName);

List&lt;Field&gt; fields = new LinkedList&lt;Field&gt;(ReflectionUtils.getDeclaredColumnFields(type));
Collections.reverse(fields);

for (Field field : fields) {
    if (field.isAnnotationPresent(Column.class)) {
        final Column columnAnnotation = field.getAnnotation(Column.class);
        String columnName = columnAnnotation.name();
        if (TextUtils.isEmpty(columnName)) {
            columnName = field.getName();
        }

        mColumnNames.put(field, columnName);
    }
}

TableInfo.java 的构造函数如上，运行时，得到所有行信息并存储起来用来构件表信息。
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android注解Annotation的文章
    
    </summary>
    
      <category term="注解" scheme="http://yoursite.com/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="Android,注解,Annotation" scheme="http://yoursite.com/tags/Android-%E6%B3%A8%E8%A7%A3-Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Android下屏幕适配全解析</title>
    <link href="http://yoursite.com/2014/05/16/android%E4%B8%8B%E7%9A%84%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2014/05/16/android下的屏幕适配全解析/</id>
    <published>2014-05-16T14:19:43.000Z</published>
    <updated>2016-12-19T13:24:09.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android下屏幕适配全解析"><a href="#Android下屏幕适配全解析" class="headerlink" title="Android下屏幕适配全解析"></a>Android下屏幕适配全解析</h1><h2 id="屏幕适配分为两部分：图片适配和尺寸适配。"><a href="#屏幕适配分为两部分：图片适配和尺寸适配。" class="headerlink" title="屏幕适配分为两部分：图片适配和尺寸适配。"></a>屏幕适配分为两部分：图片适配和尺寸适配。</h2><h3 id="图片适配："><a href="#图片适配：" class="headerlink" title="图片适配："></a>图片适配：</h3><ul>
<li>目前流行的是切一套最大的图——1920*1080（1080P），在低分辨率的 手机上可以通过设置 imageView 的大小和 scaleType 来将图片压缩。（这 样做的目的是减小 APK 体积）针对那些常用的、比较重要的 icon 会切多套图。</li>
</ul>
<h3 id="尺寸适配："><a href="#尺寸适配：" class="headerlink" title="尺寸适配："></a>尺寸适配：</h3><ul>
<li>较为通俗的方法就是根据不同的手机分辨率在 res 文件夹下创建不同 的 values 文件夹，在每个都有一个 dimens 文件，dimens 文件里就写<br>着所有的尺寸。每种分辨率的手机就到不同的 values 文件夹里面的 dimens 文件去进行尺寸匹配。</li>
<li>使用谷歌官方推出的 percent library 来进行适配。但是谷歌只推出了PercentRelativeLayout、PercentFrameLayout供大家使用，那么其他就可以写自定义VIew来实现了</li>
<li>使用国内hongyang大神写的 AutoLayout 来进行适配。</li>
</ul>
<h3 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h3><ul>
<li>屏幕尺寸：屏幕对角线的长度。</li>
<li>屏幕分辨率：横纵向上的像素点数。</li>
<li>dpi:是 dot per inch 的缩写，表示每英寸上的像素点数。与屏幕尺寸和 屏幕分辨率有关。</li>
<li>dip/dp: 是 Density Independent Pixels 的缩写，即密度无关像素</li>
<li>px:像素。</li>
<li>sp: 即 scale-independent pixels，与 dp 类似，但是可以根据文字大小 首选项进行放缩，是设置字体大小的御用单位。 mdpi、hdpi、xdpi、xxdpi：用来修饰 Android 中的 drawable 文件 夹及 values 文件夹，用来区分不同像素密度下的图片和 dimen 值。</li>
<li>mdpi:480*320,</li>
<li>hdpi:800<em>480,854</em>480,960*540</li>
<li>xhdpi:1280*720</li>
<li>xxhdpi:1920*1080</li>
</ul>
]]></content>
    
    <summary type="html">
    
      这是一篇很好的阐述Android下屏幕适配全解析的文章
    
    </summary>
    
      <category term="屏幕适配" scheme="http://yoursite.com/categories/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android,屏幕适配" scheme="http://yoursite.com/tags/Android-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
</feed>
